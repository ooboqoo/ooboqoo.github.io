# ISO C++


## 预备知识

C++ 语言容纳了好几种编程范式，包括 *面向对象编程*、*泛型编程*和传统的 *过程化编程*。这表明 C++ 强调的是实用价值，而不是意识形态方法，这也是该语言获得成功的原因之一。

ISO C++ 标准根据年份区分版本，主要有 03 11 14 17 这几个版本。

*C++ 是 C 语言的超集*，任何有效的 C 程序都是有效的 C++ 程序。名称 C++ 来自 C 语言中的递增运算符。

C++ 在 C 语言的基础上添加了面向对象编程和泛型编程的支持。C++ 继承了 C 语言高效、简洁、快速和可移植性的传统，同时为应付复杂程度不断提高的现代编程任务而引入了面向对象的特性。

### C++ 简史

一般来说，计算机语言要处理两个概念——数据和算法，*数据是程序使用和处理的信息，而算法是程序使用的方法*。

C 语言在最初面世时也是过程性 procedural 语言，这意味着它强调的是编程的算法方面。随着程序规模的扩大，计算机科学家开发了一种更有序的编程方法——结构化编程 structured programming。另一个新原则是自顶向下 top-down 的设计，C 语言的理念是将大型程序分解成小型、便于管理的任务。*结构化编程技术反应了过程性编程的思想*。

虽然结构化编程的理念提高了程序的清晰度、可靠性，并使之便于维护，但它在编写大型程序时，仍面临着挑战，为应付这种挑战，OOP 提供了一种新方法。*与强调算法的过程性编程不同的是，OOP 强调的是数据，其理念是设计与问题的本质特性相对应的数据格式*。在 C++ 中类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。OOP 不是将重点放在任务上，而是放在表示概念上。

泛型编程 generic programming 是 C++ 支持的另一种编程模式。术语泛型指的是创建独立于类型的代码。C++ 的数据表示有多种类型，要对不同类型的数据进行排序通常必须为每种类型创建一个排序函数，而有了泛型后，只编写一个泛型函数就搞定了。C++ 模板提供了完成这种任务的机制。

### 可移植性和标准

C++ 的流行导致大量用于各种计算平台的 C++ 实现得以面世，而 ISO C++ 标准为确保众多实现的相互兼容提供了基础。这些标准规定了语言必须具备的特性、语言呈现出的行为、标准库函数、类和模板，旨在实现该语言在不同计算平台和实现之间的可移植性。

在 **ANSI C** 出现之前，C 语言社区遵循一种事实标准，该标准基于 Kernighan 和 Ritchie 编写的 The C Programming Language 一书，通常被称为 **K&R C**。

ANSI C 标准不仅定义了 C 语言，还定义了一个 ANSI C 实现必须支持的标准 C 库，C++ 也使用了这个库，本书将其称为 *标准 C 库 或 标准库*。另外，ANSI/ISO C++ 标准还提供了一个 *C++ 标准类库*。


## 起步

```cpp
#include <iostream>

int main()
{
  using namespace std;
  cout << "Hello World." << endl;
}
```

头文件名(预编译指令)

```cpp
#include <iostream> // C++ 标准库

#include <math.h>   // C 标准库
#include <cmath>    // 转换后到C 标准库
```

名称空间

```cpp
using namespace std;        // 暴露命名空间内的所有成员
using namespace std::cout;  // 仅暴露命名空间内的单个成员 cout

std::cout << "Hello\n" << "World" << std::endl;  // 不用 using namespace 的用法
```

函数内不允许嵌套函数，因为函数要声明后才能调用

```cpp
#include <iostream>

void print(char *);
int sum(int, int);

int main()
{
  int i = sum(1, 2);
  print("todo");
}

void print(char *str)
{
  std::cout << str << std::endl;
}

int sum(int a, int b)
{
  return a + b;
}
```


## 处理数据

内置的 C++ 类型分两组：基本类型和复合类型。

C++ 的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。

整型(有符号) `char` `short` `int` `long` `long long`  
整型(无符号) `unsigned short` `unsigned` `unsigned long` `unsigned long long`  
整型(其他) `bool` `char` `signed char` `unsigned char`  

C++ 使用运算符来提供对数字类型的算术运算：加、减、乘、除 和 求模。

### 变量名

* 只能使用字母字符、数字和下划线
* 第一个字符不能是数字
* 区分大小写
* 以 两个下划线 或 下划线加大写字母 打头的名称被保留给实现(编译器及其使用的资源)使用
* 以一个下划线开头的名称被保留给实现，用作全局标识符
* 对名称长度没有限制(而 ANSI C 中只保证前 63 个字符有意义)

名称要使用多个单词时，`lowercase_with_underscores` `lowCamelCase` 这两种形式都是可以的，选一种就好。

### 整型

`chart` `short` `int` `long` `long long`  
`unsigned short` `unsigned` `unsigned long` `unsigned long long`

类型的宽度()随实现而异，_climits_ / _limits.h_ 包含了关于整型限制的信息。

_climits_ 文件中包含类似 `#define INT_MAX 32767` 这样的语句行。在 C++ 编译过程中，首先将源代码传递给预处理器。`#define` 和 `#include` 一样也是一个预处理编译指令，该编译指令告诉预处理器，在程序中查找 `INT_MAX` 并将所有的 `INT_MAX` 都替换为 `32767`，这跟编辑器中的全局搜索替换命令相似。

```cpp
#include <iostream>
#include <climits>  // 包含了关于整型限制的信息
int main()
{
  using namespace std;

  // sizeof operator yields size of type or of variable
  cout << "int   is " << sizeof(INT_MAX) << "bytes.\n";
  cout << "short is " << sizeof(SHRT_MAX) << "bytes.\n";
  cout << "long  is " << sizeof(LONG_MAX) << "bytes.\n";
  cout << "long long is " << sizeof(LLONG_MAX) << "bytes." << endl;

  cout << "Maximum values:\n";
  cout << "int:   " << INT_MAX << endl;
  cout << "short: " << SHRT_MAX << endl;
  cout << "long:  " << LONG_MAX << endl;
}
/*
int   is 4bytes.
short is 4bytes.
long  is 8bytes.
long long is 8bytes.
Maximum values:
int:   2147483647
short: 32767
long:  9223372036854775807
*/
```

初始化

```cpp
int num = 5;
// C++11 新增加的列表初始化 list-initialization，统一了初始化常规变量和初始化类变量的方式
int num{5};
int num = {5};
```

整型字面量

```cpp
int i = 42;    // decimal integer literal
int i = 0x42;  // hexadecimal integer literal
int i = 042;   // octal integer literal
```

定义常量

```cpp
const int Months = 12;
```

早期 C 使用 `#define` 来定义符号常量，但现在 C++ 和 ANSI C 都使用 `const` 限定符。  
建议将常量名称的首字母大写，或所有字母都大写，这样便于区分常量和普通变量。


`char`

编程语言通过使用字母的数值编码来存储字母，因此 `char` 类型是另一种整型。

### 浮点数

和 ANSI C 一样，C++ 也有 3 种浮点类型：`float` `double` `long double`。

```cpp
1.234f       // a float constant
2.45E20F     // a float constant
2.345324E28  // a double constant
2.2L         // a long long constant
```

### 算术运算符

C++ 是如何处理不同类型之间的隐式和显式转换的。

C++ 自动执行很多类型转换
* 将一种算术类型的值赋给另一种算术类型的变量时
* 表达式中包含不同的类型时
* 将参数传递给函数时

```cpp
// 强制类型转换
(typeName) value  // C 语言
typeName(value)   // C++ 新格式，让强制类型转换像函数调用
```

```cpp
// 类型推断 auto
auto x = 1.5;  // x is double
```


## 复合类型

C++ 让程序员能够使用基本的内置类型来创建更复杂的类型。最高级的形式是类，但本章先讨论其他形式：数组(存储多个同类型的值)、结构(存储多个不同类型的值)、指针(标示内存位置)。如何创建和存储文本字符串及如何使用。最后还将学习 C++ 处理内存分配的一些方法。

### 数组

数组 array 能够存储多个同类型的值。

创建数组可使用声明语句 `typeName arrayName[arraySize];`。这里的 `arraySize` 是在编译时就已知的整型常数、const 值 或常量表达式，也就是说，`arraySize` 不能是变量，变量的值是在程序运行时设置的。

数组之所以被称为 *复合类型*，是因为它是使用其他类型来创建的(C 语言使用术语 *派生类型*，但由于 C++ 对类关系使用术语 *派生*，所以创建了新术语)。

*编译器不会检查使用的下标是否有效*。但开发人员必须确保程序只使用有效的下标值，否则可能破坏数据或代码，导致运行异常。

```cpp
// 先声明数组再对数组元素赋值
int arr[2];  // 未经初始化的数组元素的值是不确定的，其值为以前驻留在该内存单元中的值
arr[0] = 7;
arr[1] = 8;

// 声明并初始化数组
int arr[2] = {7, 8};
short arr[2] = {0};  // 如果只对一部分进行初始化，则编译器将把其他元素设置为 0
short arr[] = {1, 5, 3, 8};  // 此时可以省略数组的大小值，但这样做比较危险，对字符串倒是挺合适

//C++11 新增
double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};  // 初始化数组时可省略等号
float balances[100] {};  // 可不在大括号内包含任何东西，这将把所有元素都设置为 0
```

C++ 标准模版库(STL) 提供了一种数组替代品——模版类 `vector`，而 C++11 新增了模版类 `array`。这些替代品比内置复合类型更复杂更灵活。

### 字符串



### string 类


### 结构


### 共用体


### 枚举


### 指针和自由存储空间

指针、数组和指针算术

指针是一种将数据所处位置告诉计算机的变量。

类型组合

数组的替代品



## 循环和分支


## 函数

函数是 C++ 的编程模块，是基本的编程部件。

最后将介绍函数指针，它使程序员能够通过函数参数来命令函数使用另一个函数。


## 内存模型和名称空间

如何创建多文件程序，分配和管理内存的各种方式

作用域、链接、名称空间，这些内容决定了变量在程序的哪些部分是可见的。


### 存储连续性、作用域和链接性

### 名称空间


## 对象和类

类是用户定义的类型，对象是类的实例。

对象声明描述的是存储在对象中的信息以及可对对象执行的操作(类方法)。

对象的某些组成部分对于外界可见(公有部分)，而某些部分是隐藏的(私有部分)。

特殊的类方法(构造函数和析构函数)在对象创建和释放时发挥作用。

### 类的使用

运算符重载使程序员能够定义与类对象一起使用的运算符。

友元函数可以访问外部世界不可访问的类数据。

### 动态内存分配

一般来说，让类成员指向动态分配的内存很有用。如果程序员在类构造函数中使用 new 来分配动态内存，就有责任提供适当的析构函数，定义显式拷贝构造函数和显式赋值运算符。

介绍了在程序员没有提供显式定义时，将如何隐式地生成成员函数以及这些成员函数的行为。

### 继承

通过继承，派生类可以继承基类的特性，可重用基类代码。


## 代码重用

公有继承只是代码重用的方式之一。本章将介绍其他几种方式。


## 友元和异常

友元类和友元成员函数。

异常为处理程序异常提供了一种机制，如函数参数值不正确或内存耗尽等。


## 类库



## IO和文件

学习如何打开文件，进行输入和输出，如何在文件中追加数据。


## C++11 特性

自动类型推断、新的智能指针以及作用域内枚举。

右值引用类型以及如何使用它来实现移动语义。

新增的类功能、lambda表达式和可变参数模版。


