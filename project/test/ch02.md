# 复杂度

复杂性是每个软件项目的克星，虽然有些是不可避免的，但多数情况下是可以避免的。

JSLint、圈复杂度、代码行数、扇入和扇出 等都是衡量软件复杂度的重要标准。然而没有什么衡量方法比让合作者或同事查看代码更准确了。

可维护的代码是明确的、一致的、基于标准的；  
可测试的代码是松耦合的、短小的、可隔离的。

## 2.1 代码大小

随着代码规模的增大，代码的复杂度也在增加，能够理解整个系统的人却在减少。随着模块数量的增加，集成测试变得越来越困难，模块交互的次数也在增加。

程序所需的代码总量可能不会改变，但每个方法里的语句数量却是可以改变的，每个文件里的代码数量同样也是可变的。

让函数保持最小代码量的一个方法是让 command / setter 和 query / getter 保持分离。命令函数表示做什么；而查询函数表示返回什么。设置函数使用模拟 mock 进行测试；而查询函数使用桩 stub 进行测试。让这些概念保持分离，并提高可测试性，通过确保读写分离，可以实现良好的可伸缩性。

> **伪对象(fake) 桩对象(stub) 模拟对象(mock)**  
伪对象是一个通用术语，它即可指桩对象，也可指模拟对象。  
桩对象是指对系统中现有依赖项的一个替代品，可人为控制。sub 是供 getter 读取的  
模拟对象是用来决定一个单元测试是通过还是失败的伪对象。mock 会调用 setter

## 2.2 JSLint

JSLint 用于对糟糕的代码风格、语法和语义进行分析，检测代码的不良部分。

## 2.3 圈复杂度

圈复杂度是一种代码复杂度的衡量标准。在软件测试的概念里，圈复杂度“用来衡量一个模块判定结构的复杂程度，数量上表现为独立线性路径条数，即合理的预防错误所需测试的最少路径条数，圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系”。

圈复杂度决定着需编写的单元测试的最小数量。  
圈复杂度最好控制在 10 以内，绝不要操作 25，在圈复杂度高的函数里修改代码，产生新的 bug 的几率将大大增加。

圈复杂度已经被证明是一个有效衡量代码复杂性的方法，所以要深刻理解它的含义。

## 2.4 重用

减少代码大小的最好办法是减少编写的代码量。使用第三方代码库可以减少一大笔代码维护成本。   
使用前辈留下来的精华、避免重复造轮子是我们的责任，我们只需要专注于让程序显得独特的 15% 的代码。  
与重用别人的代码相比，同样重要的是重用自己的代码。一般的经验法则是，如果发现代码被编写了两遍，那就是时候将其提取到函数中了，不管为了共享代码要花费多少“额外”时间，都是为了要在将来获得回报。

## 2.5 扇出与扇入

在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。  
按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。  
扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程度高。  
扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块。  
（通俗化理解：扇入即有多少个人会开门进来拿东西，扇出是我要开门出去拿东西的次数）

- - -

高扇出会带来问题：代码更复杂、更难以理解，所以更难以测试；而且测试过程中，每个直接依赖必须要被模拟，所以会增加创建测试的复杂性；并且扇出象征着紧耦合，会使函数和模块过于脆弱。

- - - 

深度表示软件结构中控制的层数，它往往能粗略地标志一个系统的大小和复杂程度。深度和程序长度之间应该有粗略的对应关系，当然这个对应关系是在一定范围内变化的。如果层数过多则应该考虑是否有许多管理模块过分简单了，能否适当合并。

宽度是软件结构内同一个层次的模块总数的最大值。一般说来，宽度越大系统越复杂。对宽度影响最大的因素是模块的扇出。

模块的扇出是指一个模块直接控制(调用)的模块数目。扇出过大意味着模块过分复杂，需要控制和协调过多的下级模块；扇出过小也不好。一般认为，设计得好的系统平均扇出是3或4个。模块的扇出数过大或过小都不理想，过大比过小更严重。一般认为扇出的上限不超过7。扇出过大意味着管理模块过于复杂，需要控制和协调过多的下级。解决的办法是适当增加中间层次。

一个模块的扇入是指有多少个上级模块调用它，扇入越大则共享该模块的上级模块数目越多。但是不能为了获得高扇入而不惜代价，例如，把彼此无关的功能凑在一起构成一个模块，虽然扇入数高了，但这样的模块内聚程度必然低。这是应该避免的。观察大量软件系统后发现。设计得好的系统，上层模块有较高的扇出，下层模块有较高的扇入。

## 2.7 耦合

扇入和扇出只是一个数量指标，而耦合则关注这些依赖的模块是如何组合在一起的，即，耦合关注的是相互之间的具体依赖关系。

一些指标试图尝试用一个数字计算耦合度，这些指标基于《Software Metrics: A Rigorous & Practical Approach, 2nd Edition》中定义的六级耦合。

类型     | 耦合分数 | 解析
--------:|:--------:|:--------------------------------------------------------------------------
内容耦合 |    5     | 包括在外部对象上调用方法或函数，或通过修改外部对象的属性直接改变对象状态
公共耦合 |    4     | 如果两个对象都共享另外一个全局变量，则这两个对象就有公共耦合
控制耦合 |    3     | 该耦合基于标记或参数设置来控制外部对象
标记耦合 |    2     | 标记耦合指两个模块之间传递的是数据结构
数据耦合 |    1     | 这种耦合发生在一个对象传递给另一个对象消息数据，而没有传递控制对象的参数时
  无耦合 |    0     | 无耦合才是完美的耦合

> 耦合是一个宽泛的概念。两个程序模块有关联就叫做耦合。
> 
> 某些模块必然要关联起来才能工作，这是由业务逻辑决定的，不能否认。所以解耦并不是字面意义上的把关联拆掉，而是把模块之间的关联放松到必要的程度。一些建议：
> 
> * 模块只对外暴露最小限度的接口，形成最低的依赖关系。
> * 只要对外接口不变，模块内部的修改，就不得影响其他模块；
> * 删除一个模块，应当只影响有依赖关系的其他模块，而不应该影响其他无关部分；
> 
> 件工程有一条铁律“高内聚、低耦合”就是这个道理：必要的耦合不可否认，没有耦合程序就做不成事；但是不必要的紧耦合，就会让程序“牵一发而动全身”，最终让程序员的编写和维护都无从下手。

### 测试耦合代码

内容耦合很难测试，是因为单元测试要在隔离环境中进行测试，通常必须使用 mock 和 stub 来模拟代码所需要的运行环境。由于存在紧密耦合，集成测试也是必要的。

公共耦合代码更易于进行单元测试，因为其共享的全局变量可以很容易地模拟（mock 或 stub）并进行检查。

控制耦合需要模拟出外部控制对象，并验证其可以正常控制，这种测试使用 mock 对象很容易完成。

标记耦合也可以通过外部 mock 对象，很容易地进行单元测试，并验证传入的参数是否正确。

数据耦合或无耦合代码很容易利用单元测试进行测试，很少或不需要模拟对象（mock 或 stub），该方法可以直接进行测试。

将耦合最小化，测试将会变得更容易。

## 2.10 依赖注入

```js
// 修改前，工厂函数亲自创建所需的每样东西，Car类过于脆弱、缺乏弹性并且难以测试
var Car = function() {
  this.engine = new Engine();
  this.tire   = new Tire();
}
// 改造工厂函数，将依赖转移到参数，使其变成可注入的状态，测试期间，只要传入不同的 mock 就可以完全控制其依赖
var Car = function(engineInstance, tireInstance) {
  this.engine = engineInstance;
  this.tire   = tireInstance;
}
// 通过依赖注入器实现依赖注入
var injector = ReflectiveInjector.resolveAndCreate([Car, Engine, Tire]);  // 向依赖注入器注册依赖
var car = injector.get(Car);  // 使用 injector.get() 创建实例

// 关于如何编辑依赖注入器，这里有详细介绍 http://www.ituring.com.cn/article/68377
// 或者访问 AngularJS 的介绍 https://angular.cn/docs/ts/latest/guide/dependency-injection.html
```

依赖注入是不在类中实例化其他依赖的类，而是先把依赖的类实例化了，然后以参数的方式传入构造函数中。  
依赖注入是一种编程模式，该模式可以让一个类从外部源中获得它的依赖，而不必亲自创建它们。

依赖会让代码变得复杂，也会让构建、测试、调试变得更加困难。通过依赖注入可使代码松耦合, 易维护，易测试。

测试中，注入和模拟是松散的关系。注入负责构造对象，并将对象注入到代码中；而模拟是在调用时替换对象或方法以便于测试。在测试的时候，可以（也应该）使用注入工具向代码中插入 mock 版本的对象。

## 2.11 注释

借助注释理解代码是一个更直接的方法，而不是依赖（或阅读）测试。方法的注释是最重要的，对难以理解的代码所做的任何注释，对于程序员来说都是无价的。重要的是，注释解释了为什么要有该方法、如何构建该方法，利用结构化的注释，也可以很容易地将其转换成 HTML 文档供大家浏览。

注释强迫我们要理解代码，它们可以作为一种迷你的代码自我审核。

注意：如果在函数上编写注释，保证这些注释实时更新是非常重要的，没有注释远远好于错误的注释。

## 2.12 人工测试


## 2.13 小结
