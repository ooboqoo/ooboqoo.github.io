<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="../w3c.css" />
<script src="../notes.js"></script>
<title>4 变量、作用域、内存问题</title>
</head>
<body>
<div id="article">

<h1>4 变量、作用域、内存问题</h1>

<div>
<h2>4.1 基本类型和引用类型的值</h2>
<p>JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p>
<p>基本数据类型有5种：Undefined、Null、Boolean、Number、String。在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型，但 ES 放弃了这一传统。</p>
<p>基本类型值和引用类型值具有以下特点：</p>
<ul>
<li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li>
<li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li>
<li>引用类型的值是对象，保存在堆内存中；</li>
<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li>
<li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；</li>
<li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。</li>
</ul>

<h3>4.1.1 动态的属性</h3>
<p>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。</p>

<h3>4.1.2 复制变量值</h3>
<p>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p>
<p>当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象，因此改变一个变量，就会影响另一个变量。</p>

<h3>4.1.3 传递参数</h3>
<p>ES 中所有函数的参数都是按值传递的，也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p>
<p>虽然 ES 不像其他语言一样分按值和按引用两种方式，但在向参数传递引用类型的值时，复制给局部变量的是指向对象的指针，因此这个局部变量的变化会反映在函数的外部，换句话说，即使引用类型是按值传递的，局部变量还是会按引用来访问同一个对象。有很多开发人员错误地认为，在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。其实也正是因为对象传递的特性，所以 ES 中没有按引用传递这种用法。</p>

<h3>4.1.4 检测类型</h3>
<p>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。</p>
<pre>result = variable instanceof constructor  // instanceof 只能根据提供的类型判断真假，相对比较不方便</pre>

</div>

<div>
<h2>4.2 执行环境及作用域</h2>
<p>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：</p>
<ul>
<li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</li>
<li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</li>
<li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；</li>
<li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li>
<li>变量的执行环境有助于确定何时释放内存。</li>
</ul>

<h3>4.2.0 执行环境</h3>
<p>执行环境（execution context 也可简称为“环境”）定义了变量或函数有权访问的其他数据，决定了他们各自的行为。</p>
<p>每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p>
<p>全局执行环境是最外围的一个执行环境。在Web浏览器中，全局环境被认为是window对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。</p>
<p>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出（如关闭网页或浏览器）时才会被销毁）</p>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象，全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止（如果找不到，通常会导致错误发生）。</p>

<h3>4.2.1 延长作用域链</h3>
<p>虽然执行环境的类型总共只有两种——全局和局部，但还有两种特殊的情况下作用域会加长：</p>
<ul><li>try-catch语句的catch块</li><li>with语句</li></ul>
<p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>

<h3>4.2.2 没有块级作用域</h3>
<p>JavaScript 没有块级作用域，因而代码块中的变量在代码块执行完毕后并不会消失。</p>
<p>在使用for语句时尤其要牢记这一差异。对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境中。而对于JavaScript来说，由for语句创建的变量 i 即使在for循环结束后，也会存在于循环外部的执行环境中。</p>

<h4>声明变量</h4>
<p>使用 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。在 ES5 严格模式下，使用未声明的变量会导致错误。</p>

<h4>查询标识符</h4>
<p>当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。</p>
<p>如果局部环境中存在同名标识符，就不会使用位于父环境中的标识符。</p>
<p>变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。</p>
</div>

<div>
<h2>4.3 垃圾收集</h2>
<p>JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。</p>
<ul>
<li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除；</li>
<li>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存；</li>
<li>另一种不常用的垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数；</li>
<li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题；</li>
<li>为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li>
</ul>

<h3>4.3.1 标记清除</h3>
<p>当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”，等待被垃圾回收机制收回。</p>

<h3>4.3.2 引用计数</h3>
<p>引用计数的含义是跟踪记录每个值被引用的次数，当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这种方式存在一个严重的问题：循环引用。</p>
<p>在IE8以之前版本中，虽然 JavaScript引擎是使用标记清除策略来实现的，但JavaScript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。IE9把BOM和DOM对象都转成了真正的JavaScript对象，从而解决了循环引用问题。</p>
<p>为了避免循环引用问题，最好是在不使用它们的时候手工断开原生JavaScript对象与DOM元素之间的连接。将变量设置为null意味着切断变量与它此前引用的值之间的连接。</p>
<pre>
var element = document.getElementById("some_element");
var myObject = new Object();
muObject.element = element;
element.someObject = myObject;  // 产生循环引用，引用计数永远无法归0
myObject.element = null;  // 断开循环引用
</pre>

<h3>4.3.3 性能问题</h3>
<p>确定垃圾收集的时间间隔是一个非常重要的问题，IE6及之前版本的垃圾收集机制曾引发严重的性能问题。</p>

<h3>4.3.4 管理内存</h3>
<p>处于安全方面的考虑，分配个web浏览器的可用内存数量通常要少于分配给桌面应用程序的内存。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。</p>
<p>因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。</p>
<p>不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
</div>

</div>
</body>
</html>