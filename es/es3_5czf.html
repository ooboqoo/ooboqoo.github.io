<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="../w3c.css" />
<script src="../notes.js"></script>
<title>ECMAScript 操作符</title>
</head>
<body>
<div id="article">

<h1>3.5 操作符</h1>

<div>
<h2>3.5.1 一元运算符</h2>
<p>只能操作一个值的操作符叫做<b>一元操作符</b></p>
<p>一元运算符只有一个参数，即要操作的对象或值。它们是 ECMAScript 中最简单的运算符。</p>

<h3>delete -- 删除开发者<b>自定义</b>的对象属性或方法</h3>

<h3>void -- 对任何值返回 undefined</h3>
<p>该运算符通常用于避免输出不应该输出的值，例如，从 HTML 的 &lt;a&gt; 元素调用 JavaScript 函数时。要正确做到这一点，函数不能返回有效值，否则浏览器将清空页面，只显示函数的结果。例如：</p>
<pre>&lt;a href="javascript:void(window.open('about:blank'))"&gt;Click me&lt;/a&gt;</pre>

<h3>3.5.1.1 递增/递减操作符</h3>
<p>递增和递减操作符直接借鉴自C，而且各有两个版本：前置型和后置型</p>
<p>前置型操作符是先增/减再计算表达式；后置型是先计算表达式再对自身进行增/减</p>
<p>所有这4个操作符对任何值都适用，不仅可用于操作整数，还可用于字符串、布尔值、浮点数值和对象。</p>

<h3>3.5.1.2 一元加/减</h3>
<p>一元加/减操作符主要用于基本的算术运算，也可以用于转换数据类型。</p>
<p>一元加对数字不会有任何影响，但对非数值应用一元加操作符时，该操作符会像 Number() 转型函数一样对这个值执行转换。</p>
<p>一元减操作符比一元加操作符多一次求负的过程。</p>
</div>

<div>
<h2>3.5.2 位操作符</h2>
<p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。</p>
<p>由于是在数值表示的最底层执行操作，因此速度更快。</p>

<h3>重温整数</h3>
<p>默认情况下，ECMAScript 中所有整数都是有符号整数，当然，也存在无符号整数。</p>
<p>有符号整数使用低 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。正数以纯二进制格式存储，负数使用二进制补码格式存储。</p>
<p>计算数字二进制补码的步骤有三步：</p>
<ol>
<li>确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）</li>
<li>求得二进制反码，即要把 0 替换为 1，把 1 替换为 0 （反码）</li>
<li>在二进制反码上加 1（补码）</li>
</ol>
<pre>
0000 0000 0000 0000 0000 0000 0000 0000   //  0 的二进制编码
                                     -1
---------------------------------------
1111 1111 1111 1111 1111 1111 1111 1111   // -1 的二进制编码
</pre>

<h3>注意事项</h3>
<p>ECMAScript 中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。</p>
<p>所有整数字面量都默认存储为有符号整数。只有位运算符才能创建无符号整数。</p>
<p>在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。</p>
<p>如果对非数值应用位操作符，会先进行强制类型转换，然后再应用位操作，得到的结果将是一个数值。</p>
<p>ES 在把数值转换成二进制字符串时，会以更合乎逻辑的形式展示出来，如 -18 只会显示为 -10010 </p>

<h3>按位非 NOT（~）</h3>
<p>按位非由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。</p>
<pre>var iNum1 = 25      <span> // 25 等于 00000000000000000000000000011001</span>
<code>var iNum2 = ~iNum1;</code> <span> // 转换为 11111111111111111111111111100110 即-26</span>
</pre>
<p>按位非的结果就是返回数值的反码，即操作数的负值减 1</p>

<h3>按位与 AND（&amp;）</h3>
<p>按位与由和号（&amp;）表示，它把每个数字中的数位对齐，然后对同一位置上的两个数位进行 AND 运算。</p>
<pre>
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
</pre>

<h3>按位或 OR（|）</h3>
<p>按位或由符号（|）表示，对同一位置上的两个数位进行 OR 运算。</p>
<pre>25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
</pre>

<h3>按位异或 XOR（^）</h3>
<p>按位异或由符号（^）表示，对同一位置上的两个数位进行 XOR 运算。</p>
<pre>
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
</pre>

<h3>左移（&lt;&lt;）</h3>
<p>左移操作符由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的位数。右边的空位用  0 填充。</p>
<p class="important"><span>注意：</span>左移不会影响操作数的符号位。ES 中开发者不能直接访问第 32 个数位。</p>

<h3>有符号的右移（&gt;&gt;）</h3>
<p>有符号右移操作符由两个大于号表示（&gt;&gt;）。它会将数值向右移动，但保留符号位。右移产生的空位用<b>符号位的值</b>填充。</p>

<h3>无符号右移（&gt;&gt;&gt;）</h3>
<p>无符号右移操作符由三个大于号（&gt;&gt;&gt;）表示，它将 32 位数的所有数位整体右移。右移产生的空位用<b> 0 </b>填充。</p>
<p>对于正数，无符号右移运算的结果与有符号右移运算一样。</p>
<p>对于负数，因为右移运算用 0 填充所有空位，负数变成了正数，无符号右移总是得到一个非常大的数字。</p>
</div>

<div>
<h2>3.5.3 布尔操作符</h2>
<p>Boolean 操作符有三种：NOT、AND 和 OR。在一门语言中，布尔操作符的重要性堪比相等操作符。</p>

<h3>3.5.3.1 逻辑非 NOT（!）</h3>
<p>逻辑非操作符由感叹号（!）表示。</p>
<p>与逻辑 OR 和逻辑 AND 操作符不同的是，<strong>逻辑 NOT 操作符返回的一定是 Boolean 值</strong>。</p>
<p>逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。同时使用两个逻辑非操作符，实际上就会模拟 Boolean() 函数的行为。</p>

<h3>3.5.3.2 逻辑与（&amp;&amp;）</h3>
<p>逻辑与操作符由两个和号（&amp;&amp;）表示。</p>
<p>逻辑与操作可以引用于任何类型的操作数，而不仅仅是布尔值。<strong>如果某个操作数不是布尔值的话，逻辑与操作不一定返回布尔值，</strong>此时遵循下列规则：</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数；</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true时才会返回该对象（如果两个操作数都是对象，返回第二个对象）；</li>
<li>如果有一个操作数是 null，返回 null；</li>
<li>如果有一个操作数是 NaN，返回 NaN；</li>
<li>如果有一个操作数是 undefined，返回 undefined。</li>
</ul>
<p><strong>逻辑与属于短路操作</strong>，即如果第一个操作数能够决定结果，那就不再对第二个操作数进行求值。即，如果第一个操作数是 false，那么直接返回 false 而不会对第二个操作数求值。</p>

<h3>3.5.3.3 逻辑或（||）</h3>
<p>逻辑或操作符由双竖线（||）表示。</p>
<p>与逻辑与相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值：</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数；</li>
<li>如果第一个操作数的求值结果为false，则返回第二个操作数；</li>
<li>如果两个操作数都是 null，返回 null；</li>
<li>如果两个操作数都是 NaN，返回 NaN；</li>
<li>如果两个操作数是 undefined，返回 undefined。</li>
</ul>
<p>与逻辑与操作相似，逻辑或也属于短路操作。即，如果第一个操作符求值为 true，就不再计算第二个操作数。</p>
</div>

<div>
<h2>3.5.4 乘性操作符</h2>
<p>ECMAScript 定义了3个乘性操作符：乘、除、求余。需要注意的是，在操作数是非数值的情况下会自动执行强制类型转换。</p>

<h3>乘法（*）</h3>
<p>乘法运算符由星号（*）表示，用于两数相乘。</p>
<p>在处理特殊值时，乘法操作遵循下列规则：</p>
<ul>
<li>如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。</li>
<li>如果有一个操作数是 NaN，结果为 NaN。</li>
<li>Infinity 乘以 0，结果为 NaN。</li>
<li>Infinity 乘以 非0 数值，结果为 Infinity 或 -Infinity。</li>
<li>Infinity 乘以 Infinity，结果为 Infinity。</li>
</ul>

<h3>除法（/）</h3>
<p>除法运算符由斜杠（/）表示。</p>
<p>与乘法运算符相似，在处理特殊值时，除法运算符也有一些特殊行为：</p>
<ul>
<li>如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。</li>
<li>如果有一个操作数是 NaN，结果为 NaN。</li>
<li>Infinity 被 Infinity 除，结果为 NaN。</li>
<li>Infinity 被 0以外的任何数字除，结果为 Infinity 或 -Infinity。</li>
<li>0 除 0，结果为 NaN。</li>
<li>0 除 非0的有限数字，结果为 Infinity 或 -Infinity。</li>
</ul>

<h3>求余（%）</h3>
<p>求模（余数）操作符由一个百分号（%）表示。</p>
<p>与其他乘性运算符相似，对于特殊值，取模运算符也有特殊的行为：</p>
<ul>
<li>如果被除数是 Infinity，或除数是 0，结果为 NaN。</li>
<li>如果除数是 Infinity，结果为被除数。</li>
</ul>
</div>

<div>
<h2>3.5.5 加性操作符</h2>
<p>在多数程序设计语言中，加性运算符（即加号或减号）通常是最简单的数学运算符。但在 ECMAScript 中，加性运算符有一系列的特殊行为。</p>

<h3>加法（+）</h3>
<p>加法运算符由加号（+）表示。</p>
<p>与乘性运算符一样，在处理特殊值时，ECMAScript 中的加法也有一些特殊行为：</p>
<ul>
<li>某个运算数是 NaN，那么结果为 NaN。</li>
<li>Infinity 加 Infinity，结果为 Infinity。</li>
<li>-Infinity 加 -Infinity，结果为 -Infinity。</li>
<li>Infinity 加 -Infinity，结果为 NaN。</li>
<li>+0 加 +0，结果为 +0。</li>
<li>-0 加 +0，结果为 +0。</li>
<li>-0 加 -0，结果为 -0。</li>
</ul>
<p>不过，如果某个运算数是字符串，那么采用下列规则：</p>
<ul>
<li>如果两个运算数都是字符串，把第二个字符串连接到第一个上。</li>
<li>如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。</li>
</ul>
<p class="important"><span>注意：</span>为了避免 JavaScript 中的一种常见错误，在使用加法运算符时，一定要仔细检查运算数的数据类型。</p>

<h3>减法（-）</h3>
<p>减法运算符（-），也是一个常用的运算符。在处理特殊值时，减法运算符也有一些特殊行为：</p>
<ul>
<li>某个运算数是 NaN，那么结果为 NaN。</li>
<li>Infinity 减 Infinity，结果为 NaN。</li>
<li>-Infinity 减 -Infinity，结果为 NaN。</li>
<li>Infinity 减 -Infinity，结果为 Infinity。</li>
<li>-Infinity 减 Infinity，结果为 -Infinity。</li>
<li>+0 减 +0，结果为 +0。</li>
<li>-0 减 -0，结果为 -0。</li>
<li>+0 减 -0，结果为 +0。</li>
<li>某个运算符不是数字，那么会先强制类型转换再计算。</li>
</ul>
</div>

<div>
<h2>3.5.6 关系操作符</h2>
<p><strong>关系运算符执行的是比较运算。每个关系运算符都返回一个布尔值。</strong></p>

<h3>常规比较（数值与数值比较）</h3>
<p>关系运算符小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）执行的是两个数的比较运算，比较方式与算术比较运算相同。</p>

<h3>字符串与字符串比较</h3>
<p>许多人认为小于表示“在字母顺序上靠前”，大于表示“在字母顺序上靠后”，但事实并非如此。对于字符串，第一个字符串中每个字符的代码都与会第二个字符串中对应位置的字符的代码进行数值比较。完成这种比较操作后，返回一个 Boolean 值。问题在于大写字母的代码都小于小写字母的代码，这意味这着可能会遇到下列情况：</p>
<pre>
"Blue" &lt; "alpha";  <span>// true</span>
<code>"25" &lt; "3";  // true</code> 因为两个操作值都是字符串，"2" 的字符代码是 50，"3" 的字符代码是 51
</pre>

<h3>数字和字符串比较</h3>
<p>无论何时比较一个数字和一个字符串，ECMAScript 都会把字符串转换成数字，然后按照数字顺序比较它们。</p>
<pre>var bResult = "25" &lt; 3;    // false</pre>
<p>不过，如果字符串不能转换成数字，也就是强制类型转换成 NaN，根据规则，任何操作数与NaN比较，结果都是false</p>
<pre>
var bResult = "a" &lt; 3;   // false
var bResult = "a" &gt;= 3;  // false
</pre>
</div>

<div>
<h2>3.5.7 相等操作符</h2>
<p>判断两个变量是否相等是程序设计中非常重要的运算。在处理原始值时，这种运算相当简单，但涉及对象，任务就稍有点复杂。</p>
<p><strong>ECMAScript 提供了两套等性运算符：等号和非等号用于处理原始值，全等号和非全等号用于处理对象。</strong></p>

<h3>3.5.7.1 等号和非等号（==）（!=）</h3>
<p>在 ECMAScript 中，等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。</p>
<p>非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。</p>
<p>为确定两个运算数是否相等，这两个运算符都会进行类型转换。执行类型转换的规则如下：</p>
<ul>
<li>如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。</li>
<li>如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。</li>
<li>如果一个运算数是对象，另一个不是对象，会先调用对象的 valueOf() 方法。</li>
</ul>
<p>在比较时，该运算符还遵守下列规则：</p>
<ul>
<li>值 null 和 undefined 相等。</li>
<li>要比较相等性之前，不能把 null 和 undefined 转换成任何其他值。</li>
<li>只要有一个操作数是 NaN，等号将返回 false，非等号将返回 true。</li>
<li>如果两个操作数都是对象，则确定他们是不是同一个对象。如果指向同一对象则返回 true。</li>
</ul>
<p class="tip"><span>重要提示：</span>即使两个数都是 NaN，等号仍然返回 false，因为根据规则，NaN 不等于 NaN。</p>
<table>
<tr><th>表达式</th><th>值</th><th>表达式</th><th>值</th></tr>
<tr><td>false == 0</td><td>true</td><td>null == undefined</td><td>true</td></tr>
<tr><td>true == 1</td><td>true</td><td>NaN == NaN</td><td>false</td></tr>
<tr><td>true == 2</td><td>false</td><td>undefined == 0</td><td>false</td></tr>
<tr><td>"5" == 5</td><td>true</td><td>null == 0</td><td>false</td></tr>
</table>

<h3>3.5.7.2 全等号和非全等号（===）（!==）</h3>
<p>这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。</p>
<p>全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。</p>
<p>不全等操作符由一个感叹号后跟两个等号表示（!==），它在两个操作数未经转换就不相等的情况下返回 true。</p>
</div>

<div>
<h2>3.5.8 条件操作符</h2>
<h3>条件操作符（ ? : ）</h3>
<p>条件运算符是 ECMAScript 中唯一的三元操作符，也是最灵活的一种操作符。</p>
<pre><i>variable = boolean_expression ? true_value : false_value</i>;</pre>
<p>该表达式主要是根据 <i>boolean_expression</i> 的计算结果有条件地为变量赋值。</p>
<pre>var iMax = (iNum1 &gt; iNum2) ? iNum1 : iNum2;</pre>
</div>

<div>
<h2>3.5.9 赋值操作符</h2>
<h3>赋值操作符（=）</h3>
<p>简单的赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。</p>
<p>复合赋值运算是由乘性运算符、加性运算符或位移运算符（实测无效）加等号实现的。</p>
<table>
<tr><td>乘法/赋值（*=）<br />除法/赋值（/=）<br />取模/赋值（%=）</td>
    <td>加法/赋值（+=）<br />减法/赋值（-=）</td></tr>
</table>
<p>设计这些操作符的主要目的就是简化赋值操作，他们不会带来任何性能的提升。</p>
</div>

<div>
<h2>3.5.10 逗号操作符</h2>
<h3>逗号操作符（,）</h3>
<p>使用逗号操作符可以在一条语句中执行多个操作，逗号运算符常用变量声明中。</p>
<pre>var iNum1 = 1, iNum = 2, iNum3 = 3;</pre>
</div>

</div>
</body>
</html>