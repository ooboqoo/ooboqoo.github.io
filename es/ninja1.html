<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="../w3c.css" />
<style>#this li{color:blue;}</style>
<script src="../notes.js"></script>
<script src="../highlight.js"></script>
<title>忍者秘籍1</title>
</head>
<body>
<div id="article">
<p>https://www.manning.com/books/secrets-of-the-javascript-ninja</p>

<h1>第1章 进入忍者的世界</h1>

<div>
<h2>1.1 即将探索的 JavaScript 库</h2>
<p>创建现代 JS 库所用到的技术和实践是我们在本书中所关注的焦点。</p>
<p>库的基本目标：简单易用，产生最少的开销，并能兼容所有浏览器。</p>
<p>本书将关注以下库所利用的技术：</p>
<ul>
<li>jQuery：已经主导了 JS 库的市场；</li>
<li>Prototype：现代 JS 库之父于2005年创建；</li>
<li>Yahoo!UI：雅虎内部JS框架发展的结果；</li>
<li>base2：它的闻名之处在于它尝试以通用且跨浏览器的方式实现各种W3C规范</li>
</ul>
<p>一个 JS 库的组成可以分为如下三个方面：</p>
<ul>
<li>JavaScript 语言的高级使用</li>
<li>跨浏览器代码的精心构建</li>
<li>当前能够聚众合一的最佳实践应用</li>
</ul>

<h3>1.2 理解 JavaScript 语言</h3>
<h3>1.3 跨浏览器注意事项</h3>
<p>指定解决这些浏览器问题的综合性策略并熟悉不同浏览器之间的区别和缺陷，和精通 JavaScript 本身同等重要。</p>
<p>不同浏览器的市场份额和支持成本的变化是很迅速的，须密切关注 http://gs.statcounter.com 这样的网站。</p>

<h3>1.4 当前最佳实践</h3>
<p>除了掌握 JS 语言和跨浏览器编码问题，还应该掌握编写高质量代码的技能。</p>
<h4>1.4.1 测试</h4>
<h4>1.4.2 性能分析</h4>
<pre>&lt;script&gt;  // 本书将使用这些代码收集并比较代码性能信息
start = new Date().getTime();
for (var n = 0; n &lt; maxCount; N++) {
  /* perform the operation to be measured */
}
elapsed = new Date().getTime() - start;
assert(true,"Measure time: " + elapsed);
&lt;/script&gt;
</pre>
</div>

<h1>第2章 利用测试和调试武装自己</h1>

<div>
<h2>2.1 调试代码</h2>
<h3>2.1.1 日志记录</h3>
<p>在现代浏览器中都支持 console.log() 方法在控制台中输出记录日志。相对于古老的 alert() 函数，这些浏览器控制台极大地改进了日志记录过程。</p>
<h3>2.1.2 断点</h3>
<p>断点（breakpoint）是一个比日志记录更复杂的概念，但它比日志有一个更显著的优势：它能在特定的代码上暂停脚本的执行。这使得我们可以在该断点处，随意查看任意代码的状态，其中包括可访问的变量、上下文以及作用域链。</p>

<h2>2.2 测试用例生成</h2>
<p>良好测试的特性：可重复性、简单性、独立性。</p>
<p>两个主要测试类型：解构型测试 和 构建型测试。</p>

<h2>2.3 测试框架</h2>
<p>QUnit：最初是用于测试 jQuery 的单元测试框架，目前是一个独立的单元测试框架。主要是为单元测试提供一个简单的解决方案，提供最小但却易于使用的 API。</p>

<h2>2.4 测试套件基础知识</h2>
<h3>2.4.1 断言 （assert: 坚称;断言;坚决表明）</h3>
<p>单元测试框架的核心是断言方法，通常叫assert()。该方法通常接受一个值——需要断言的值，以及一个表示该断言目的的描述。</p>
<pre>
&lt;html&gt;
&lt;head&gt;  &lt;!-- 搭建自己的测试套件 --&gt;
&lt;style&gt;  /* 定义结果样式 */
  ul#results { border:1px solid gray;padding:0.25em 1.5em; }
  li.pass { color: #006400; }
  li.fail { color: #dc143c; text-decoration: line-through; }
&lt;/style&gt;
&lt;script&gt;   /* 定义assert() 方法，本书将使用该函数测试代码 */
function assert(value, desc) {
  var resultsList = document.getElementById("results");
  if (!resultsList) {
    resultsList = document.createElement('ul');
    document.getElementsByTagName('body')[0].appendChild(resultsList);
    resultsList.setAttribute('id','results');
  }
  var li = document.createElement("li");
  li.className = value ? "pass" : "fail";
  li.appendChild(document.createTextNode(desc));
  resultsList.appendChild(li);
}
assert(a==1, "Disaster! a is not 1!");   /* 使用断言执行测试 */
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;  &lt;!-- 将在body开头显示结果 --&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>以上就是一个简单的测试套件。其中 assert() 函数很简单，但对于未来开发，它将会作为良好的构建块，在本书中，我们将使用这个 assert() 方法测试不同的代码片段，验证代码的完整性。</p>
<h3>2.4.2 测试组</h3>
<p>简单的断言是很有用的，但真正发力，却是在测试上下文中将它们组合在一起形成测试组的时候。</p>
<h3>2.4.3 异步测试</h3>
<p>为了应付 Ajax 和动画等场景，要求每个测试组能够异步运行。代码清单见2.6</p>
</div>

<h1>第3章 函数是根基</h1>
<div>
<p>编写平均水平的代码，还是编写忍者级别的代码，取决于大家是否真正了解 JavaScript 是一门函数式语言（functional language）编写代码的水平就取决于对这一点的认知。</p>
<p>最重要的是，在 JavaScript 中，函数是 first-class object，也就是说，可以将其视为其他任意类型的对象。就像普通的 JavaScript 数据类型，函数可以被任意变量进行引用，或声明成对象字面量，甚至可以将其作为函数的参数进行传递。</p>

<h2>3.1 函数的独特之处</h2>
<p>JavaScript 和 Java 是两门完全不同的语言，多数程序员是从 Java 转过来的，诸多差别造成对 JS 的各种抱怨，但这不是 JS 的错。</p>
<h3>3.1.1 JavaScript 的函数式特性为何如此重要</h3>
<p>函数和函数式概念在JavaScript 中如此重要的原因之一是，函数是代码执行的主要模块化单元。除了标签解析时所运行的内联脚本以外，本书为页面编写的所有代码都将在单独的函数内。</p>
<h4>函数是第一型对象</h4>
<p>函数是第一型对象，除了可以像其他对象一样使用外，函数还有一个特殊的功能，它们可以被调用（invoked），这些调用通常是以异步方式（asynchronous）进行。</p>
<h4>浏览器的事件轮询</h4>
<p>事件轮询和事件派发由浏览器帮我们处理，我们的职责是为浏览器中发生的各种事件建立事件的处理程序（handler）</p>
<p>浏览器的事件轮询是单线程的，每个事件都在自己的生命周期内进行处理，所有其他事件必须等到这个事件处理结束以后才能继续处理。</p>
<p>浏览器把事件放到队列上的机制在事件轮询模型之外。事件处理不会影响到事件队列的更新。</p>
<h4>回调</h4>
<p>我们定义一个函数，以便其他一些代码在适当的时机回头再调用它，这就是所谓的回调（callback）。</p>
<pre>
var values = [213,16,2058,54,10,1965,57,9];  // 回调例子：使用比较器进行排序
values.sort(function(value1,value2){ return value2-value1; });
</pre>
<p>函数的第一型对象特性带来的便利不是像 Java 这样的非函数式语言所能比的。</p>
<p>JavaScript 语言最重要的功能之一是可以在代码的任何地方创建函数，只要能用表达式，就能创建函数。除了使代码更加紧凑和易于理解（将函数声明放在使用的地方）外，在一个函数不用多个地方引用的时候，该特性还可以消除使用不必要的名称所带来的全局命名空间污染。</p>

<h2>3.2 函数声明</h2>
<p>JavaScript 函数是使用函数字面量（function literal）进行声明从而创建函数值的。函数字面量由4个部分组成：</p>
<ul>
<li>function 关键字</li>
<li>可选名称，如果指定，必须是一个有效的JS标识符</li>
<li>括号内部，一个以逗号分隔的参数列表</li>
<li>函数体</li>
</ul>
<p>函数名是可选的，有人可能会非常惊讶。如果一个函数不需要用名称引用，就不需要对它命名。（如果叫猫的名字它不过来，那为什么给它取名字呢？）</p>
<p>声明一个函数时，函数名称在其所在作用域范围内都是有效的，即便在声明前调用。</p>
<p class="note"><span>提醒：</span>注意区分函数声明与函数表达式，给函数表达式命名就是内联命名函数，函数名只能在内联函数内部使用。如果将一个函数表达式赋值给一个变量，那么，只能在变量声明后才能通过变量引用到函数。</p>
<p>所有的函数都有一个 name 属性，保存的是函数名称的字符串，匿名函数也有name属性，只不过是空字符串罢了。</p>
<pre>
&lt;script&gt; 
var canFly = function(){ return true; };
// 该例子中，函数的name 是 "" 而不是 "canFly"
// 因为 canFly 是一个变量名，所以在声明前无法调用，要与函数声明作区别
// 该表达式的实质是：1，声明一个匿名函数 2，声明一个变量 3，将函数的引用赋值给变量
&lt;/script&gt; 
</pre>
<blockquote>
<h3>何为声明，何为函数表达式？</h3> 
<p>在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者的区别是有点晕，因为ECMA规范只明确了一点：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符：</p> 
<pre>
函数声明：　function 函数名称 (参数:可选){ 函数体 } 
函数表达式：function 函数名称 (可选)(参数:可选){ 函数体 }
</pre>
<p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。 </p>
<p>还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号()是一个分组操作符，它的内部只能包含表达式。 </p>
<p>你可能会想到，在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval('(' + json + ')')，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
</blockquote>

<h4>作用域和函数</h4>
<p>在JavaScript中，作用域是由 function 进行声明的，而不是代码块。</p>
<ul>
<li>变量声明的作用域开始于声明的地方，结束于所在函数的结尾，与代码嵌套无关。</li>
<li>命名函数的作用域是指声明该函数的整个函数范围（有些人称之为机制提升）。</li>
<li>对于作用域声明，全局上下文就像一个包含页面所有代码的超大型函数。</li>
</ul>
<pre>
&lt;script&gt;
function test(){ console.log(a); }  // 报错，a 没有定义
function outer() {
  var a = 1;
  test(); // 这里调用test，初看起来应该能看到 a，但事实不是这样的
}         // 调用函数，函数还是“<b>在定义它的地方执行</b>”,
outer();  // 作用域取决于函数定义的位置，与调用的位置无关，这也正是“闭包”能够存在的基础
          // （后面在视频中看到，专业的说法是 JavaScript 不具备动态作用域）
&lt;/script&gt; 
</pre>

<h2>3.3 函数调用</h2>
<p>函数调用的方式对其函数内部的代码是如何执行的，有着巨大的影响，尤其是在 this 参数的创建中。</p>
<h3>3.3.1 从参数到函数形参</h3>
<p>如果实参与形参数量不等，JavaScript 不会抛出错误，而是会进行如下处理：</p>
<ul>
<li>如果实参多于形参，超出的参数将无法分配形参名，但在函数内部可以通过 arguments 调取</li>
<li>如果实参少于形参，没有对应实参的形参会赋值为 undefined</li>
</ul>
<p>除了实参，所有的函数调用都还会传递两个隐式参数：arguments 和 this</p>
<ul>
<li>arguments 是传递给函数的所有参数的一个集合，该集合有一个length属性，它是一个类数组结构。</li>
<li>Java 中的this 依赖于函数的声明，而JavaScript 中的this 则依赖于函数的调用方式。</li>
</ul>

<h3>3.3.2 作为函数进行调用</h3>
<p>“函数作为函数”进行调用，其实是“函数作为方法”进行调用的一个特例，因为 window 是所有未成为对象方法的函数的所有者。</p>
<ul>
<li>函数作为第一型对象，除了具有普通对象的属性外，还承担了作用域管理职责。在作用域空间里定义的函数并不会自动成为哪个对象的方法，在没有找到合适投靠对象前它们由 window 对象兜底管理。</li>
<li>函数 = 对象（有属性，对外可见） + 闭包环境（无法作为属性读取，仅用于控制作用域）。</li>
</ul>
<div class="w3-responsive">
<svg width="600" height="150">
  <rect width="560" height="150" style="fill:rgb(221,221,255);"></rect>
  <text x="8" y="18">window</text>
  <rect x="30" y="25" width="525" height="90" style="stroke:black;stroke-width:1;fill-opacity:0;stroke-opacity:0.9;"></rect>
  <rect x="31" y="25" width="49" height="89" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="55" y="45" writing-mode="tb-rl" style="font-size:1.25em;font-weight:bold;">函数</text>
  <rect x="80" y="25" width="474" height="35" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="90" y="45">函数的普通属性（函数是属性的所有者）</text>
  <text x="110" y="82">函数给内部代码提供了活动空间，只是管理者而非所有者</text>
  <text x="110" y="105">作用域系统独立于对象系统</text>
  <text x="80" y="100" style="font-size:42px;opacity:0.5">{</text>
  <text x="520" y="100" style="font-size:42px;opacity:0.5">}</text>
  <rect x="50" y="120" width="60" height="26" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="57" y="138">变量1</text>
  <rect x="130" y="120" width="60" height="26" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="137" y="138">变量2</text>
  <rect x="210" y="120" width="60" height="26" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="217" y="138">变量n</text>
  <rect x="290" y="120" width="60" height="26" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="297" y="138">函数1</text>
  <rect x="370" y="120" width="60" height="26" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="377" y="138">函数2</text>
  <rect x="450" y="120" width="60" height="26" style="fill:rgb(0,255,0);opacity:0.5;fill-opacity:1;"></rect>
  <text x="457" y="138">函数n</text>
</svg>
</div>
<p>用“澳门赌场”来比喻函数的这种“又作为对象有可见属性，又创建了私密活动空间” 的特性是比较适合的。赌场里活动的各色人等，如果没有明确声明为某个机构洗钱的话，他在为“地球/window”洗钱。</p>
<p style="color:blue">在设定“函数始终是作为方法调用的”的前提下，确定 this 值将变得异常简单：this 始终指向拥有该方法的对象，除非显式更换。</p>

<h3>3.3.3 作为方法进行调用</h3>
<p>当一个函数被赋值给对象的一个属性，并使用引用该函数的这个属性进行调用时，那么函数就是作为该对象的一个方法进行调用的。</p>
<pre>
&lt;script&gt;  // 该例充分说明了一个函数通过不同方式调用对this产生的影响
function creep(){ return this; }
console.log(creep());   // window
var sneak = creep;
console.log(sneak());   // window
var ninja1 = { skulk: creep };
console.log(ninja1.skulk());   // ninja1
&lt;/script&gt; 
</pre>

<h3>3.3.4 作为构造器进行调用</h3>
<p>当函数做为构造器调用时，将会如下特殊行为：</p>
<ul>
<li>创建一个新对象</li>
<li>传递给构造器的对象是this参数，从而成为构造器的函数上下文</li>
<li>如果没有显式的返回值，返回新创建的对象</li>
</ul>

<h3>3.3.5 使用 apply() 和 call() 方法进行调用</h3>
<p>跟正常调用函数比，apply 和 call 其实就是将原本隐式传递的this改为显式传递了。</p>

<h2>3.4 总结</h2>
<p>可以用不同的方法进行函数调用，不同的调用机制决定了函数上下文的不同。</p>
<p>(这里对 <code>this</code> 的总结是最简洁明了的）</p>
<ul id="this">
<li>作为普通函数进行调用时，其上下文是全局对象（window）</li>
<li>作为方法进行调用时，其上下文是拥有该方法的对象</li>
<li>作为构造器进行调用时，其上下文是一个新分配的对象</li>
<li>通过函数的 apply()、call() 或 bind()方法进行调用时，上下文可以设置成任意值</li>
</ul>
<p>(函数的this正常都指向window，当函数与对象结合，但又不作为对象的方法调用的时候具有很强的欺骗性！)</p>
<pre>
&lt;script&gt;  // 下面这个例子有些参考意义，一时写不出更好的
window.onload=function () {
  var btn = document.getElementById("button");
  btn.onclick=fn(this,function(){  // 这里的 this 就指向 window
    console.log("button",this);   // 而这一行的this，最终将指向 btn
  });
  function fn(arg1,callback){
    console.log(arg1);
    return callback;
  }
};
&lt;/script&gt;
</pre>
</div>

<h1>第4章 挥舞函数</h1>

<div>
<p>在前一章，我们重点介绍了 JavaScript 如何将函数作为第一型对象以及如何进行函数式编程。在本章，我们将详述如何使用这些函数来解决在编写 web 应用程序时可能面临的各种问题。</p>

<h2>4.1 匿名函数</h2>
<p>有强类型和面向对象语言开发背景的开发人员可能会认为，函数和方法在使用之前必须要事先进行定义并命名，然后才能使用。然而在函数式语言中，函数经常在需要的时候才定义，然后用完就抛弃。</p>
<p>函数式编程专注于：少，通常无副作用、将函数作为程序代码的基础构建块。在web程序开发中，函数式编程风格是我们所要做事情的重要核心。</p>
<p>匿名函数让我们可以创建更小的执行单元。</p>

<h2>4.2 递归</h2>
<h3>4.2.1 普通命名函数中的递归</h3>
<p>函数递归的两个条件：引用自身，并且有终止条件。</p>
<h3>4.2.2 方法中的递归 及 引用的丢失问题</h3>
<pre>
&lt;script&gt;
var ninja = {
  chirp: function(n){ return n>1 ? ninja.chirp(n-1)+"-chirp" : "chirp"; }
};
var samurai = { chirp: ninja.chirp };
ninja = {};
samurai.chirp(3);  // 出错，引用丢失，可以通过修改 ninja.chirp 为 this.chirp 规避
&lt;/script&gt;
</pre>
<h3>4.2.4 内联命名函数</h3>
<p>声明一个函数字面量时，函数名称是可选的，我们除了在声明全局函数时用过，其他形式都没用。但事实证明，不管是作为callback声明的还是作为方法声明，给任何函数字面量取名都没有什么错。</p>
<p>这些函数加了名字就不再是匿名函数了，我们可以称它们为内联函数（inline function）</p>
<p>内联函数最重要的一点：尽管可以给内联函数进行命名，但这些名称只能在自身函数内部才是可见的。内联函数的名称和变量名称有点像，它们的作用域仅限于声明它们的函数。</p>
<p>给内联函数取名，可以解决这些函数在递归引用方面的问题（可以说，这种方式比使用this更清晰）。</p>
<h3>4.2.5 callee 属性</h3>
<p>arguments 有一个callee 属性引用的是当前所执行的函数，该属性可以作为一个可靠的方法引用函数自身。</p>
<p>ES5 严格模式下会报错，并且已经不推荐使用，所以尽量不要用。</p>

<h2>4.3 将函数视为对象</h2>
<p>和其他对象一样，我们可以给函数添加属性，从而实现特定的目的。</p>

<h3>4.3.1 函数存储</h3>
<p>在函数属性中保存其他函数，以便稍后进行引用或调用。事件回调管理是最明显的例子（具体见13章）。</p>

<h3>4.3.2 自记忆函数</h3>
<p>通过函数的属性保存前面的执行结果，可以显著提高性能。</p>
<h4>缓存记忆昂贵的计算结果</h4>
<h4>缓存记忆 DOM 元素</h4>

<h3>4.3.3 伪造数组方法（类数组就是这么来的吧）</h3>
<p>函数调用时，通过控制传递函数上下文，我们可以在当前对象上执行该对象没有的方法。利用这种技术，可以利用像 Array 和 Math 上已有的方法，在自定义数据上进行操作。</p>

<h2>4.4 可变长度的参数列表</h2>
<p>本节我们将了解以下内容：</p>
<ul>
<li>如何给能接受任意参数的函数提供多个参数</li>
<li>如何使用变长的参数列表实现函数重载</li>
<li>如何理解并使用参数列表的length属性</li>
</ul>

<h3>4.4.1 使用 apply() 支持可变参数</h3>
<pre>
function smallest(array){
  return Math.min.apply(Math, array);  // 任何this都可以，用Math 是让代码看起来更整洁
} // Math.min 不支持传入数组，通过 apply 巧妙地解决了这个缺陷
</pre>

<h3>4.4.2 函数重载</h3>
<p>通过检查 arguments 对象，可以轻松实现函数重载功能。jQuery UI 广泛使用了函数重载。</p>
<h4>对 arguments 列表进行切片 slice</h4>
<pre>
Array.prototype.slice.call(arguments,1)  // arguments不是真正的数组，所以没有数组方法，
// 这里巧妙地使用slice完成切片并生成了真正的数组，可以使用该方法将类数组对象转成数组
</pre>
<h4>函数的 length 属性</h4>
<p>对于一个函数，在参数方面，我们可以确定两件事情：</p>
<ul>
<li>通过其 length 属性，可以知道声明了多少命名参数。（形参：parameter）</li>
<li>通过 arguments.length，可以知道在调用时传入了多少参数。（实参：argument）</li>
</ul>
<h4>利用参数个数进行函数重载</h4>
<p>当然，我们可以简单地使用 if-else 或 switch 语句实现函数重载，但这里我们有更好的方法。</p>
<pre>
&lt;script&gt;
function addMethod(object, name, fn) {
  var old = object[name];  // 保存原有的函数，如果调用的参数不匹配就调用原函数
  object[name] = function(){
    if (fn.length == arguments.length) return fn.apply(this, arguments);
    else if (typeof old == 'function') return old.apply(this, arguments);
  };
} // 这里的核心是采用了闭包的技术，每个匿名函数都配有 fn 和 old值，从而可以一层层查找匹配函数
addMethod(ninja,'laugh',function(){ /* do something */ });
addMethod(ninja,'laugh',function(a,b){ /* do something */ });
&lt;/script&gt;
</pre>

<h2>4.5 函数判断</h2>
<p>typeof 是判定是否是函数的一个典型方式，但有跨浏览器问题，这里我们给出了一个相当不错的解决方案，当然，这只是跨浏览器脚本编程的一个很小挑战。</p>
<pre>
function isFunction(fn){
  return Object.prototype.toString.call(fn) === "[object Function]";
} 
</pre>
<p>我们不直接调用 fn.toString() 获取结果，原因是：不同的对象可能有自己的toString() 方法实现</p>
</div>

<h1>第5章 闭包</h1>

<div>
<h2>5.1 闭包是如何工作的</h2>
<p>闭包不仅包含函数声明，还包含了函数声明的那一刻该作用域中所用到的变量和函数。闭包创建了一个“安全气泡”，保留了函数执行所需要的所有资源。</p>
<pre>
&lt;script&gt;  // 出了国，披上了洋皮，即便国不在了，但人还在，国语还在，另外洋文也是照耍不误
var outerValue = '洋文';
var later;    // 洋装
function outerFunction() {  // 外包函数，牛逼老爸，各种保护伞
  var innerValue = '国语';
  function innerFunction() { // 闭包内的函数就是各种官/富二代，各种特权，各种高端上档次
    var ownValue = '嘴巴';
  }
  later = innerFunction;  // 申请出国
}
outerFunction();  // 拿了绿卡
later();  // 装洋人行骗世界，即便老子进了秦城归了西，崽子依然逍遥
&lt;/script&gt;
</pre>

<h2>5.2 使用闭包</h2>
<h3>5.2.1 私有变量</h3>
<p>闭包的一种常见用法是封装一些信息作为“私有变量”，也就是说限制这些变量的作用域。</p>

<h3>5.2.2 回调 callback 与计时器 timer</h3>
<p>在回调函数的作用域内，提前保存需要的变量，然后将回调函数绑定到外部，等到回调函数执行时，就可以访问这些私有变量。</p>

<h2>5.3 绑定函数上下文</h2>
<p>函数的 bind() 方法的潜在目的是通过函数和闭包控制后续执行的上下文。</p>
<pre>
&lt;script&gt;
var button = {
  clicked: false,
  click: function(){
    this.clicked = true;  // 如果没有绑定，这里的this将在点击时指向 btn
    console.log(clicked,this); // 不绑定输出 false &lt;button id="button"&gt;
  }
};
var btn = document.getElementById("button");
btn.addEventListener("click",button.click.bind(button),false);
&lt;/script&gt;
</pre>

<h2>5.4 偏应用函数</h2>
<p>可以通过预先传入一些参数生成一个偏应用函数。这种在一个函数中首先填充几个参数（然后再返回一个新函数）的技术称为柯里化（currying）</p>

<h2>5.5 函数重写</h2>
<p>通过重写，我们可以在用户毫无感知的情况下，重新修改一个函数的内部行为。</p>
<h3>5.5.1 缓存记忆</h3>
<h3>5.5.2 函数包装</h3>
<p>道理都一样，原函数有缺陷或者需要增强功能的地方在新函数处理，其他的在新函数内调用老函数处理。这里的包装方法，在重写的同时保持了原函数在被包装后仍然能够被有效使用。</p>
<pre>
&lt;script&gt;
function wrap(object, method, wrapper) {
  var fn = object[method];  //记住原方法，用以在回调函数中调用
  return object[method] = function(){ //没有return效果一样，方便赋值或是符合某种规范吧
    <b>return</b> wrapper.apply(this, //下行中.bind(this)不可少的，不然callback中执行时将指向window
    [<b>fn.bind(this)</b>].concat( Array.prototype.slice.call(arguments)));
  };  //闭包里面的return 是不可少的，用于将返回值层层往外传递
}  //定义wrap是为了规范或者实现代码重用，如果单个函数修改的话，完全不用这么麻烦
var Gavin ={laugh: function(level){console.log(this);return ("hahaha! " + level)}};
wrap(Gavin, "laugh", function(fn,level) { //比原函数多一个参数：绑定好this的原函数
    return level == "loudly" ? "I cann't!" : fn(level);
});
console.log(Gavin.laugh("loudly"));
console.log(Gavin.laugh("quietly")); // Object {laugh: function}; hahaha! quietly
&lt;/script&gt;
</pre>
<pre>&lt;script&gt;  // 这是单独修改的版本，不过用到了下一节讲的即时函数
(function(){
   fn = Gavin.laugh;
   Gavin.laugh = function(level){
       return level == "loudly" ? "I cann't!" : fn.call(this,level);
   };
})();
&lt;/script&gt;
</pre>

<h2>5.6 即时函数</h2>
<pre>(function(){ /* statements */ })();</pre>
<p>这段代码的最终结果是一个执行如下操作的单条语句表达式。</p>
<ul>
<li>创建一个函数实例</li>
<li>执行该函数</li>
<li>销毁该函数（因为语句结束以后，没有任何引用了）</li>
</ul>
<p>这种构造充分地利用了闭包，它给 JavaScript 语言带来了出乎意料的能力。</p>
<h3>5.6.1 临时作用域和私有变量</h3>
<h4>创建一个独立作用域</h4>
<pre>
(function(){
  var numClicks = 0;
  document.addEventListener('click',function(){ alert(++numClicks); },false);
})();
</pre>
<p>这是一种最常见的即时函数使用方式：简单，自包装。各功能所需的变量都保存在闭包内，但对其他地方却都不可见。</p>
<h4>通过参数限制作用域内的名称</h4>
<pre>
(function($){
  ......
})(jQuery);  // 通过传递jQuery给形参$，解决在让出$的情况下，继续使用$ 代替 jQuery
</pre>
<p>这种技术被很多jQuery插件开发人员所使用，由于假设用$ 引用jQuery是不安全的，他们的页面中的代码从来不直接使用$。</p>
<h4>使用简洁名称让代码保持可读性</h4>
<pre>
(function(v){
  ......
})(Element.attributeTranslations.read.values);
</pre>
<p>这种在作用域内创建临时变量的技巧，对没有延迟调用的循环遍历来说尤其有用。</p>
<h3>5.6.2 循环</h3>
<pre>
&lt;script&gt;
var divs = document.getElementsByTagName("div");
for (var i = 0; i &lt; divs.length; i++) {
  divs[i].addEventListener("click", function() {
    alert("divs #" + i + " was clicked.");
  }, false);
}  // 本例中我们的本意是让点击时显示相应的序号，但结果是总是显示总数
&lt;/script&gt;
</pre>
<p>闭包记住的是对变量的引用，而不是闭包创建时刻该变量的值。这是一个重要的区别，让很多人都走了弯路。</p>
<pre>
&lt;script&gt;   // 修改后的代码，将正常工作
var divs = document.getElementsByTagName("div");
for (var i = 0; i &lt; divs.length; i++) function(n){
  divs[i].addEventListener("click", function() {
    alert("divs #" + n + " was clicked.");
  }, false);
})(i);  // 在原代码外套了一层 function(n){  }(i);
&lt;/script&gt;
</pre>
<h3>5.6.3 类库包装</h3>
<pre>
&lt;script&gt;  // jQuery 库的包装形式
(function(){
  var jQuery = window.jQuery = function(){
    // Initialize
  };
  // ...
})();
&lt;/script&gt;
</pre>
<p>注意，这里有两次赋值，这是有意这样做的，为了避免全局变量 window.jQuery 被意外删除，我们将其赋值给了一个局部变量jQuery，强制将其保持在即时函数的作用域内。</p>
<pre>
&lt;script&gt;  // 另外一种实现方式
var jQuery = (function(){
  function jQuery(){
    // Initialize
  }
  // ...
  return jQuery;
})();
&lt;/script&gt;
</pre>
<p>通常在只输出一个变量的时候，优先使用这种技巧，这样看起来更能体现出赋值的意义。</p>
</div>

<h1>第6章 原型与面向对象</h1>

<div>
<h2>6.1 实例化和原型</h2>

<h3>6.1.1 对象实例化</h3>
<h3>6.1.2 通过构造器判断对象类型</h3>
<p>constructor 属性指向构造函数，但是删除 constructor 属性不影响 instanceof 操作符的正常工作。instanceof 应该是通过判断原型链上 fn.prototype 中的 fn 来识别的。</p>
<h3>6.1.3 继承与原型链</h3>
<p>创建一个原型链最好的方式是，使用一个对象的实例作为另外一个对象的原型。</p>
<p>下面的清单展示了一种可能的 forEach() 实现，使用该实现，可以弥补旧版本浏览器的不足。</p>
<pre>
&lt;script&gt;
if (!Array.prototype.forEach) { //判断是否已经存在 forEach
  Array.prototype.forEach = function(callback, context) {
    for (var i = 0; i &lt; this.length; i++) {
      callback.call(context || null, this[i], i, this);
    }
  };
}
["a", "b", "c"].forEach(function(value, index, array) {  //测试代码
  assert(value, "Is in position " + index + " out of " + (array.length-1));
});
&lt;/script&gt;
</pre>
<p>所有的内置对象，比如Array，包括其原型，我们都可以按照自己的意愿来扩展它。但需要记住的重点是，在原始对象上引入新的属性或方法，与在全局作用域内声明一个变量一样危险，因为原生对象的原型只有一个实例，所以有发生命名冲突的重大可能性。</p>
<h3>6.1.4 HTML DOM 原型</h3>
<p>在现代浏览器中，所有 DOM 元素都继承于 HTMLElement 构造器，通过访问 HTMLElement 的原型，浏览器可以为我们提供扩展任意 HTML 节点的能力。</p>
<pre>
&lt;script&gt;
  HTMLElement.prototype.remove = function() {  //添加新方法
    if (this.parentNode) this.parentNode.removeChild(this);
  };
  var a = document.getElementById("a");  //用原来的方式删除一个节点
  a.parentNode.removeChild(a);
  document.getElementById("b").remove();  //用新方法删除节点
&lt;/script&gt;
</pre>
<p>一个大量使用这种特性的JS库是 Prototype，该库在现有 DOM 元素上增加了大量的功能，包括 HTML 的注入和 CSS 的操作。</p>
<p>最重要的是要意识到，在处理这些 HTMLElement 原型时，不能在IE8 之前版本上使用，如果老版本的IE不是目标平台，那么这些特性可能对我们很有用。</p>
<p>另外一个需要注意的问题是，尽管浏览器暴露了其构造器和原型，但不可以直接通过其构造器实例化新 HTML 元素。</p>

<h2>6.2 疑难陷阱</h2>
<h3>6.2.1 扩展对象</h3>
<p>我们也许会犯的极其严重的错误就是去扩展原生 Object.prototype。其原因是，在扩展该原型时，所有的对象都会接收这些额外的属性。</p>
<pre>
&lt;script&gt;
Object.prototype.keys = function() {
  var keys = [];
  for (var p in this) keys.push(p);
  return keys;
};
var obj = { a: 1, b: 2, c: 3 };
console.log(obj.keys().length)  // 输出的是4 而不是3
&lt;/script&gt;
</pre>

<h3>6.2.2 扩展数字</h3>
<p>除了我们在上一节研究的Object，对其他原生对象的原型进行扩展相对来说比较安全，但是另外一个有问题的原生对象是Number。</p>
<pre>
&lt;script&gt;  // 个人倒不怎么认同作者的观点，出现本例的问题不是扩展 Number 的错
Number.prototype.add = function(num){ return this + num; };
console.log((5).add(3))
console.log(5.add(3))    // 这个无法通过语法解释，因为点号被看成小数点了
&lt;/script&gt;
</pre>
<p>这是一个令人沮丧的问题，因为其背后的逻辑相当含糊。有些库无视这些问题继续在 Number 原型上做扩展，只是简单规定它们的使用（Prototype就是其中之一）。</p>

<h3>6.2.3 子类化原生对象</h3>
<p>对Array进行子类化的时候，一切似乎都能像我们期望的那样工作，但也有特殊情况。</p>
<pre>
&lt;script&gt;
function MyArray() {}
  MyArray.prototype = new Array();
  var mine = new MyArray();
  mine.push(1, 2, 3);
assert(mine.length == 3, "All the items are in our sub-classed array.");
&lt;/script&gt;
</pre>
<p>（作者说IE的实现不能很好地反应length的值，但现在测试都好的了，这个应该算是IE的bug吧。）</p>

<h3>6.2.4 实例化问题</h3>
<p>我们知道，函数有两种用途：作为“普通”的函数和作为构造器。调用构造器时新手用户很容易忘记new操作符，这将导致意想不到的结果。</p>
<pre>
&lt;script&gt;
function User(first, last){
  this.name = first + " " + last;
}
var name = "Rukia";
var user = User("Ichigo", "Kurosaki");  // 遗漏 new 操作符，不仅不会创建新对象，
assert(name == "Rukia", "Name was set to Rukia.");  // 而且还会改写全局变量 name
&lt;/script&gt;
</pre>
<p>我们可以很容易地在构造函数内规避这种失误（见下例），但同时我们也应该考虑是否应该这样做。记住，只是因为我们可以想出一个巧妙的解决方法，并不总是意味着我们就应该用这种方式。</p>
<pre>
&lt;script&gt;
function User(first, last) {
  if (!(this instanceof arguments.callee)) {
    return new User(first,last);
  }
  this.name = first + " " + last;
}
&lt;/script&gt;
</pre>

<h2>6.3 编写类风格的代码</h2>
<p>暂时跳过，不觉得非要搞成类风格。</p>
<h3>6.3.1 检测函数是否可序列化</h3>
<p>函数序列化（function serialization）就是简单接受一个函数，然后返回该函数的源码文本。</p>
</div>

<h1>第7章 正则表达式</h1>

<div>
<p>有两种方法可以创建正则表达式：通过正则表达式字面量，或者通过构造 RegExp 对象的实例。</p>
<pre>
var pattern1 = /test/i  // 正则字面量是用正斜杠进行界定的
var pattern2 = new RegExp("test","i")  // 传入的是字符串
</pre>
<p>在开发过程中，如果正则是已知的，则优先选择字面量语法，而构造器方式则是用于运行时，通过动态构建字符串来构建正则表达式。</p>
<h2>7.1 为什么正则表达式很牛</h2>
<h2>7.2 正则表达式进阶</h2>
<p>反向引用（后向引用）：<code>/^([dtn])a\1/</code>  它和 <code>/^[dtn]a[dtn]/</code> 不一样</p>
<h2>7.3 编译正则表达式</h2>
<p>正则表达式是一个多阶段处理过程，其中两个重要阶段是编译和执行。通过对稍后要用的正则表达式进行预定义（因此也预编译），我们可以获得一些明显的速度提升。</p>
<pre>
&lt;script&gt;
function findClassInElements(className, type) {
  var elems = document.getElementsByTagName(type || "*");
  var regex = new RegExp("(^|\\s)" + className + "(\\s|$)");
  var results = [];
  for (var i = 0, length = elems.length; i &lt; length; i++)
    if (regex.test(elems[i].className)) results.push(elems[i]);
  return results;
}
assert(findClassInElements("ninja", "div").length == 2,
             "The right amount fo div ninjas was found.");
&lt;/script&gt;
</pre>
<h2>7.4 捕获匹配的片段</h2>
<pre>
var html = "&lt;div class='test'&gt;&lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;";
var results = html.match(/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/); // 简单捕获，返回单个匹配的相关数组
var all = html.match(/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g);    // 全局匹配，返回的包含全部匹配的数组

var pattern = /((?:ninja-)+)sword/;  // 通过在开始括号后添加 ?: 取消捕获
</pre>

<h2>7.5 利用函数进行替换</h2>
<p>String 对象的 replace() 方法是一个强大且灵活的方法，其最强大的特性是可以接受一个函数作为替换值。</p>
<pre>
&lt;script&gt;  // 将中横线字符串转换成驼峰拼写法
function upper(all,letter) { return letter.toUpperCase(); }  //letter 中保存的是捕获组内容
assert("border-bottom-width".replace(/-(\w)/g,upper) == "borderBottomWidth",
    "Camel cased a hyphenated string.");
&lt;/script&gt;
</pre>
<pre>
//代码清单7.10 压缩查询字符串的技术，另一种巧妙地使用函数操作，而非实际地替换
</pre>

<h2>7.6 利用正则表达式解决常见问题</h2>
<h3>7.6.1 修剪字符串</h3>
<pre>
function trim(str) {
  return (str||"").replace(/^\s+|\s+$/g, "");
}  // 最常用的一种方式，另外还有2种方案 P165
</pre>

<h3>7.6.2 匹配换行符</h3>
<pre>方案1(最佳方案)：/[\S\s]*/  方案2： /(?:.|\s)*/</pre>

<h3>7.6.3 Unicode</h3>
<pre>/[\u0080-\uFFFF]+/  // 匹配代码在128（十六进制为0x80）以上的字符，中文编码范围\u4E00-\u9FA5</pre>

<h3>7.6.4 转义字符</h3>
</div>

<h1>第8章 驯服线程和定时器</h1>

<div>
<p>定时器并不是 JavaScript 的一项内置功能，而是由浏览器提供的。</p>
<p>如果能在复杂应用程序中正确应用定时器的话，就会给开发人员带来非常多的好处。</p>
<p>定时器提供了一种让一段代码在一定毫秒之后，再异步执行的能力。</p>
<p>JavaScript 是单线程执行的，定时器提供了一种跳出这种限制的方法。</p>
<p class="note"><span>提示：</span>HTML5 Web worker 将会对定时器作出很多改变，但目前浏览器支持还不好。</p>

<h2>8.1 定时器和线程是如何工作的</h2>
<h3>8.1.1 设置和清除定时器</h3>
<table>
<tr><th>方法</th><th>格式</th></tr>
<tr><td>setTimeout</td><td>id=setTimeout(fn,delay)</td></tr>
<tr><td>clearTimeout</td><td>clearTimeout(id)</td></tr>
<tr><td>setInterval</td><td>id=setInterval(fn,delay)</td></tr>
<tr><td>clearInterval</td><td>clearInterval(id)</td></tr>
</table>
<h3>8.1.2 执行线程中的定时器执行</h3>
<p>JavaScript 引擎是单线程执行，异步事件必须要排队等待才能执行。</p>
<p>同一个 interval 处理程序的多个实例不能同时进行排队，如果已经有一个 interval 回调的实例在排队了，那么后续的调用将被废弃。</p>
<h3>8.1.3 timeout 与 interval 之间的区别</h3>
<p>interval 定时器会按指定时间间隔触发一次，而 timeout 需在执行之后重新设定定时器。</p>
<pre>
&lt;script&gt;
setTimeout(function repeatMe() { /* Some long block of code... */ setTimeout(repeatMe, 10); }, 10);
setInterval(function() { /* Some long block of code... */ }, 10);
&lt;/script&gt;
</pre>

<h2>8.2 定时器延迟的最小化及其可靠性</h2>

<h2>8.3 处理昂贵的计算过程</h2>
<p>JavaScript 的单线程本质可能是 JavaScript 复杂应用程序开发中的最大“陷阱”。在 JavaScript 执行繁忙的时候，浏览器中的用户交互会减缓，甚至反应迟钝，最坏的情况是直接挂掉。因此，如果要保持界面有良好的响应能力，减少运行时间超过几百毫秒的复杂操作，将其控制在可管理状态是非常必要的。</p>
<p>通过将运算分成多个小操作，并设定定时器依次调用，从而使浏览器在执行间隙有机会处理用户响应。</p>
<p>该技术显示了，使用定时器解决浏览器环境的单线程限制是多么容易的事情，而且还提供了很好的用户体验。</p>

<h2>8.4 中央定时器控制</h2>
<p>同时创建大量的定时器，将会给管理和执行效率带来很大的干扰，减少同时使用定时器的数量，将大大有助于解决这种问题，这就是为什么所有现代动画引擎都使用一种称为中央定时器控制的技术（central timer control）。</p>
<p>在多个定时器中使用中央定时器控制，可以带来很大的威力和灵活性。</p>
<ul>
<li>每个页面在同一时间只需要运行一个定时器</li>
<li>可以根据需要暂停和恢复定时器</li>
<li>删除回调函数的过程变得简单</li>
</ul>
<pre>
&lt;script&gt; //在原例子上有改动，调试正常
var timers = {
  timerID: 0,
  timers: [],
  add: function(fn) { this.timers.push(fn); },
  start: function() {
    if (this.timerID) return; //保证只有一个中央定时器在执行
    (function runNext() {
      if (timers.timers.length = 0) return;
      for (var i = 0; i &lt; timers.timers.length; i++) {
        if (timers.timers[i]() === false){ timers.timers.splice(i,1); i--;}
      }
      timers.timerID = setTimeout(runNext, 0);
    })();
  },
  stop: function(){ clearTimeout(this.timerID); this.timerID = 0; }
};
&lt;/script&gt;
</pre>

<h2>8.5 异步测试</h2>
<pre>
&lt;script&gt;
(function() {  // 向 window 添加了 test pause resume 三个方法
  var queue = [], paused = false;
  this.test = function(fn) { queue.push(fn); runTest(); };
  this.pause = function() { paused = true; };
  this.resume = function() { paused = false; setTimeout(runTest, 1); };
  function runTest() {
    if (!paused && queue.length) { queue.shift()(); if (!paused) resume(); }
  }
})();
test(function() {
  pause();  // 这里按了暂停后，如果没有下行的resume()，那么后续测试将无法继续
  setTimeout(function(){assert(true, "First test completed"); resume(); }, 100);
});
test(function() {
  pause();  // 暂停测试队列，进入异步任务
  /* 异步任务开始 */
  /* 异步任务结束 */
  resume();  // 异步任务完成后重启测试队列
});
&lt;/script&gt;
</pre>
</div>

</div>
</body>
</html>