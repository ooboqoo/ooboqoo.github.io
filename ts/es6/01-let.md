# let const var 的联系和区别

## ES5 中的 var 和 function

### 没有块级作用域

ES5 中只有全局作用域 和 用函数分隔的局部作用域，没有块级作用域。

### 全局变量

所有在函数外面声明的变量都处于全局作用域中。每一个在函数外部声明或者定义的变量都是一个全局对象，所以这个变量可以在任何地方被使用。

如果一个变量第一次初始化/声明的时候没有使用var关键字，那么他自动加入到全局作用域中。

### 变量提升

```js
var name = "Gavin";
showName ();  // function 定义的函数会提升到头部，所以这里可以正常使用
function showName () {
  console.log ("First Name: " + name);  // 输出 First Name: undefined，因为存在变量提升，所以值为 undefined
  var name = "Ford";
  console.log ("Last Name: " + name);   // 输出 Last Name: Ford
}
```

上面 showName() 实际执行时相当于：

```js
function showName () {
  var name;
  console.log ("First Name: " + name);
  name = "Ford";
  console.log ("Last Name: " + name);
}
```

## ES5 中的严格模式  [##](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)

严格模式主要有以下限制。

- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用`with`语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀0表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量`delete prop`，会报错，只能删除属性`delete global[prop]`
- `eval`不会在它的外层作用域引入变量
- `eval`和`arguments`不能被重新赋值
- `arguments`不会自动反映函数参数的变化
- 不能使用`arguments.callee`
- 不能使用`arguments.caller`
- 禁止`this`指向全局对象
- 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈
- 增加了保留字（比如`protected`、`static`和`interface`）

## let 命令

`let` 声明的变量只在代码块内有效。

有了 let 命令，for 循环的计数器就可以和其他语言一样随时用随时定义了。

### 不存在变量提升

let 不像 var 那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。

### 暂时性死区

只要块级作用域内存在 let 命令，它所声明的变量就绑定到其所在作用域，不再受外部的影响。在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

“暂时性死区”也意味着 typeof 不再是一个百分之百安全的操作。如果变量不存在，typeof 还是和以前一样返回 undefined，但是在暂时性死区内引用变量，就会报错。

ES6规定暂时性死区和不存在变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的。

总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

### 不允许重复声明

let不允许在相同作用域内，重复声明同一个变量。

### 块级作用域

ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。let 实际上为 JavaScript 新增了块级作用域。

### 块级作用域与函数声明

ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，不过，“严格模式”下还是会报错。

ES6引入了块级作用域，明确允许在块级作用域之中声明函数，该函数的作用域仅限于块级作用域之内。

考虑到不同浏览器实现差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

## const 命令

const 命令与 let 命令的唯一区别就是，const 定义的是常量，声明常量时必须同时初始化，后续无法更改。

ES5只有 `var` `function` 这两种声明变量的方法，ES6 添加了 `let` `const` `import` `class` 命令，所以，ES6一共有6种声明变量的方法。

## 全局对象的属性

ES5之中，全局对象的属性与全局变量是等价的，未声明的全局变量，自动成为全局对象window的属性，这被认为是JavaScript语言最大的设计败笔之一。

ES6为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是全局对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。

## 总结

正常情况下，应始终使用 `let` 和 `const` 来替代 `var`

