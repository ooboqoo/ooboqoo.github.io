# PCRE 正则表达式

PCRE 库是一个实现了与 perl5 在语法和语义上略有差异的正则表达式模式匹配功能的函数集。

在 php5.3.0 以前，PHP 可使用两套正则表达式规则，一是 IEEE 制定的 POSIX，另一套是 PCRE。现 POSIX 已被弃用。

### 与 POSIX 正则表达式的不同

下面列出了在转向 PCRE 时最显著的需要知道的不同点：

1. PCRE 函数需要模式以分隔符闭合。
2. PCRE 扩展没有专门用于大小写不敏感匹配的函数，取而代之的是使用i模式修饰符完成同样的工作。
3. POSIX 函数从最左面开始寻找最长的匹配，但是 PCRE 在第一个合法匹配后停止。如果字符串不匹配这没有什么区别，但是如果匹配，两者在结果和速度上都会有差别。如：使用模式
`one(self)?(selfsufficient)?` 在字符串 `"oneselfsufficient"` 上匹配，PCRE 会匹配到 `oneself`，而 POSIX
将匹配整个字符串。

### Perl-Compatible Regular Expressions

The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl5. PCRE has its own native API, as well as a set of wrapper functions that correspond to the
POSIX regular expression API. PCRE was originally written for the Exim MTA, but is now used by many high-profile open source projects, including Apache, PHP, KDE, Postfix, Analog, and Nmap.


## 模式语法

### 分隔符

PCRE 正则表达式需要以分隔符闭合：

1. 分隔符可以使用任意的非字母数字，非反斜线，非空白 ascii 字符，如常用的 `/` `#` `~`
2. 甚至其首尾可以使用括号闭合 `() [] {} <>`
3. 但若使用元字符( 如 `+` `*` `^`)作为分隔符，则该正则表达式中不能再使用该分隔符(转义的除外)。

```php
/foo bar/
#^[^0-9]$#
+php+
%[a-zA-Z0-9_-]%
/foo bar/i
```

如果分隔符需要在模式内进行匹配，就必须进行转义。如果分隔符经常在模式内出现，更好的选择就是用其他分隔符来提高可读性。

需要将一个字符串放入模式中使用时，可以用 `preg_quote()` 函数对其进行转义，它的第二个参数(可选)可以用于指定需要被转义的分隔符。

可以在结束分隔符后增加模式修饰符。

### 元字符

正则表达式的威力源于它可以在模式中拥有选择和重复的能力。一些字符被赋予特殊的涵义，使其不再单纯的代表自己，模式中的这种有特殊涵义的编码字符称为 "元字符"。

共有两种不同的元字符：一种是可以在模式中方括号外任何地方使用的，另外一种是需要在方括号内使用的。

在方括号外使用的元字符如下：

|||
|-----|-------------------------------------------------------
| `\` | 一般用于转义字符
| `^` | 断言目标的开始位置(或在多行模式下是行首)
| `$` | 断言目标的结束位置(或在多行模式下是行尾)
| `.` | 匹配除换行符\n外的任何字符(默认)
| `[` | 开始字符类定义
| `]` | 结束字符类定义
| <code>&#x7C;</code> | 开始一个可选分支
| `?` | 作为量词，等价于 {0,1}。紧跟量词后面改变量词的贪婪特性
| `*` | 量词，等价于 {0,}，表示0次或多次
| `+` | 量词，等价于 {1,}。紧跟量词后面代表"占有"性
| `{` | 自定义量词开始标记
| `}` | 自定义量词结束标记

模式中方括号内的部分称为 "字符类"。在一个字符类中仅有以下可用元字符：

|||
|-----|-------------------------------------------------------
| `\` | 转义字符
| `^` | 仅在作为第一个字符(方括号内)时，表明字符类取反
| `-` | 标记字符范围

### 转义序列(反斜线)

#### 首先，特殊字符前加反斜线将表示特殊字符本身而取消该字符所代表的特殊涵义

Note: 反斜线在单引号字符串和双引号字符串中都有特殊含义，因此要匹配一个反斜线，模式中必须写为"\\\\\\\"。译注：首先它作为字符串，反斜线会进行转义，正则表达式引擎拿到就变成了"\\\"。

#### 第二种用途提供了一种对非打印字符进行可见编码的控制手段

|||
|--------|-------------------------------------------------------
| `\n`   | 换行 (十六进制 0A)
| `\r`   | 回车 (十六进制 0D)
| `\t`   | 水平制表符 (十六进制 09)
| `\xhh` | hh十六进制编码的字符，详细查看unicode properties 属性
| `\ddd` | ddd八进制编码的字符，或者后向引用(1-99)

#### 第三种用法是用来描述特定的字符类

|||
|------|---------------------
| `\d` | 任意十进制数字
| `\D` | 任意非十进制数字
| `\s` | 任意空白字符
| `\S` | 任意非空白字符
| `\w` | 任意单词字符
| `\W` | 任意非单词字符

单词字符指的是任意字母、数字、下划线。具体定义通过 PCRE 字符表控制，可以通过指定地域设置修改。

#### 第四种用法是一些简单的断言

一个断言指定一个必须在特定位置匹配的条件，它们不会从目标字符串中消耗任何字符。后续我们会讨论使用子组的更加复杂的断言。

### 内部选项设置

模式修饰符设置可以在模式内部通过一个 perl 选项字符序列来设置，语法为 `(?修饰符)`。如 `(?im)`表明多行大小写不敏感匹配。还可以用它来取消设置，如 `(?im-sx)` 设置了 PCRE_CASELESS 和 PCRE_MULTILINE，同时取消了 PCRE_DOTALL 和 PCRE_EXTENDED。

### 子组(子模式)

子组通过圆括号分隔，并且可以嵌套。子组(子模式)主要是来做两件事情：

1. 将可选分支局部化。比如 `cat(arcat|erpillar|)`
2. 将子组设定为捕获子组。目标字符串中匹配子组的部分将会通过 pcre_exec()() 的 ovector 参数回传给调用者。

比如，如果字符串 "the red king" 使用模式 `((red|white)(king|queen))` 进行匹配，模式匹配到的结果是 `array("red king", "red king", "red", "king")` 的形式，其中第 0 个元素是整个模式匹配的结果，后面的三个元素依次为三个子组匹配的结果。它们的下标分别为 1, 2, 3

在子组定义的左括号后面紧跟字符串 `?:` 会使得该子组不被单独捕获。比如, 如果字符串 "the white queen" 匹配模式 `((?:red|white)(king|queen))`，匹配到的结果会是 `array("white queen"、"white queen"、"white queen")`。

为了方便简写，如果需要在非捕获子组开始位置设置选项，选项字母可以位于 `?` 和 `:` 之间，比如：`(?i:saturday|sunday)`

在 PHP4.3.3 中，可以对子组使用 `(?Ppattern)` 的语法进行命名。这个子模式将会在匹配结果中同时以其名称和顺序(数字下标)出现，PHP5.2.2 中又增加了两种味子组命名的语法：`(?pattern)` 和 `(?'name'pattern)`。

### 重复/量词

一般的重复量词由花括号包裹，两个数字之间用逗号隔开，如 `a{2,4}`。第一个数字必须小于等于第二个，如果第二个数字被省略，但是逗号仍然存在，就代表没有上限；如果第二个数字和逗号都被省略，那么这个量词就限定的是一个确定次数的匹配。

默认情况下量词都是"贪婪"的，它们会尽可能多的匹配字符。如果在量词后紧跟一个 `?` 标记，它就会变成懒惰模式并尽可能少地匹配。

量词后面紧跟一个 `+` 代表"占有"性，它会吃掉尽可能多的字符，并且不关注后面的其他模式，比如 `.*abc` 匹配 "aabc"，但 `.*+abc` 不会匹配。可以使用占有符 `+` 修饰量词来达到提升速度的目的。

### Back references

在一个字符类外面，反斜线紧跟一个 1-99 之间的数字就是一个到模式中之前出现的某个捕获组的后向引用。当数字是两位数时，也可能有其他含义，如 `\11` 可能是后向引用，也可能是制表符，"反斜线"部分有具体的数字处理方式介绍。

一个后向引用会直接匹配被引用捕获组在目标字符串中实际捕获到的内容，而不是匹配子组模式的内容。因此，模式 `(sa|ra)d\1d` 将会匹配 "sadsad" 和 "radrad"，而不会匹配 "sadrad"。

### 断言

一个断言就是一个对当前匹配位置之前或之后的字符的测试，它不会实际消耗任何字符。简单的断言代码有 `\b \B \A \Z \z ^ $`等等。更加复杂的断言以子组的方式编码。它有两种类型：前瞻断言(从当前位置向前测试)和后瞻断言(从当前位置向后测试)。一个断言子组的匹配还是通过普通方式进行的，不同在于它不会导致当前的匹配点发生改变。

前瞻断言中的正面断言(断言此匹配为真)以 `(?=` 开始，消极断言以 `(?!` 开头。比如 `\w+(?=;)`匹配一个单词紧跟着一个分号但是匹配结果不会包含分号，`foo(?!bar)` 匹配所有后面没有紧跟 "bar" 的 "foo" 字符串。

后瞻断言中的正面断言以 `(?<=` 开始, 消极断言以 `(?<!` 开始。比如，`(?<!foo)bar` 用于查找任何前面不是 "foo"
的 "bar"。后瞻断言的内容被严格限制为只能用于匹配定长字符串，如 `(?<!dogs?|cats?)` 会引发一个编译期的错误。

### 一次性子组

使用一次性子组是避免一些失败匹配消耗大量时间的唯一途径。考虑一个例子，模式 `\d+foo` 应用到目标字符串 "123456bar" 时：在匹配了6个数字后匹配 "foo" 时失败，通常的行为是匹配器尝试使 `\d+` 只匹配5个数字，只匹配4个数字，在最终失败之前依次进行尝试。一次性子组提供了一种特殊的意义，当模式的一部分得到匹配后，不再对其进行重新评估，因此匹配器在第一次匹配 "foo"
失败后就能立刻失败。语法符号是另外一种特殊的括号，以 `(?<` 开始，比如 `(?<\d+)bar`。

### 条件子组

条件子组语法 `(?(condition)yes-pattern|no-pattern)` 如果条件满足，使用 yes-pattern，其他情况使用 no-pattern(如果指定了)。

### 注释

注释以 `(?#` 开始直到遇到一个右括号，不允许嵌套括号。注释中的字符不会作为模式的一部分参与匹配。


## 模式修饰符

|||
|--------------------|------------------------------------------------------------------
| i (PCRE_CASELESS)  | 大小写不敏感匹配
| m (PCRE_MULTILINE) | `^` 不仅匹配字符串首还匹配任意换行符之后; `$` 不仅匹配字符串尾还匹配任意换行符之前位置
| s (PCRE_DOTALL)    | 模式中的点号匹配所有字符，包含换行符
| x (PCRE_EXTENDED)  | 没有经过转义的或不在字符类中的空白数据字符总会被忽略
|                    | 其他暂略

#### 理解正则的多行匹配

```php
"1\n2\n3".replace(/^/mg, "s")  // "s1\ns2\ns3"
"1\n2\n3".replace(/^/g, "s")   // "s1\n2\n3"
```

设置多行匹配后，`^` 会与 "\n" 或 "\r" 之后的位置匹配。

