# 基于事件的构架

> 书上内容实在是无法看懂，根据标题和半懂不懂的理解自己杜撰的笔记，可能存在错误。

## 3.1 基于事件编程的好处

依赖性问题的出现，是因为我们需要与应用程序内部或外部的其他代码进行交互。

使用全局对象或变量进行信息沟通很简单，但却是件危险的事情，全局对象很容易受到干扰，使用全局对象将使得 bug 很难跟踪。

如果我们既不想局部实例化对象，又不想把其放在全局命名空间内，剩下的只能是使用注入了。然而注入并非灵丹妙药，我们必须处理与工厂函数或依赖注入框架方面的问题。

基于事件的编程方法提供了另外一种传递信息的方式。浏览器中 DOM 提供的事件模型，提供了基于事件的 JavaScript 编程核心，紧接着的是 Node.js 利用回调方法实现的异步编程方式。

## 3.2 事件集线器

事件背后的思想很简单：将方法注册到事件中心，指定其能够处理的事件，然后就等着事件发生并作出响应了。

通过创建单一的全局对象 eventHub 作为事件集线器，作为信息传输中心，传递信息时在 eventHub 上触发一个事件，而监听信息则是在 eventHub 上注册事件监听器。

```js
eventHub.fire("LOG", { level: "DEBUG", message: "just test!" });
eventHub.listen("LOG", function(event) { console.log(event.level + event.message); });
```

尽管所有的通信都是通过 eventHub 对象进行的，但在 eventHub 对象了，通信各方没有共享状态，也就是说，这种方式不存在公共耦合，这是 eventHub 与其他形式全局对象的一个重要区别。

### 3.2.1 使用事件集线器

事件集线器的使用就是将各部分加入到集线器中、触发、监听并响应事件。与方法调用（需要对象的局部实例化、耦合、扇出、局部的 mock 与 stub）不同，事件集线器是抛出一个事件并（如果需要、可能）等待响应。

```js
eventHub.fire("ajax-fecth", {
  src: "path/to/filename",
  callback: function(file) { handle(file); }
});
```

通常，基于浏览器的客户端触发事件，而服务器端响应事件，当然，任何一端都可以触发和响应事件。

使用事件而不是方法调用，可以极大地提高可测试性和可维护性。所有外部模块作为服务进行提供，而不是将其作为依赖进行封装。仅有的函数调用应该是对事件集线器的调用，或对对象或模块 **内部** 方法的调用。

> 更给力介绍，查看 《 JavaScript 忍者秘籍 》P302 不老事件

### 3.2.2 事件的响应

通常事件都是“单向”通信的，但通过回调函数处理通用和特定响应，可以实现双向异步通信。

### 3.2.3 基于事件的架构和  MVC 架构

基于事件的架构帮助执行了 MVC 所倡导的关注点分离以及模块化。采用事件进行通信时，控制器就是事件集线器。

### 3.2.4 基于事件的架构与面向对象编程

将数据和操作数据的方法存在一起是面向对象编程的基本原则。而基于事件架构的数据并不是存储在对象中。

### 3.2.5 基于事件的架构与软件服务

基于事件的架构促进了软件即服务 SaaS。每个独立的部分都可以加入事件集线器，独立于其他服务而单独提供服务。

## 3.3 Web 应用程序

基于事件的架构中事件集线器成为了应用程序的中心，而不是 Web 服务器。

### 3.4 测试基于事件的架构

测试可以使用一个模拟事件集线器，来验证事件触发端是否能正常触发特定的事件（事件 + 参数）；而对于事件监听端，通过在模拟事件集线器上触发事件，再检测能否得到正确响应即可。

## 3.5 基于事件架构的说明

* 可伸缩性：事件集线器创建了超级单一故障点，如果集线器出现了故障，应用程序就宕机了。解决该问题，要么将一组事件集线器放置到负载均衡器之后，要么在故障发生时，将另外一个事件集线器构建到应用程序中。因为 socket.io 没有同源限制，添加服务器很简单。
* 广播：使用广播将很多事件广播给所有的客户端可能会带来很多的通信流量。解决方法是，能客户端本地处理的本地处理，集线器中心本身也可以像交换机一样，有特定受众的，自己发给特定客户端而不需要广播。
* 运行时检测：编译器没有办法去检查字符串形式的事件名称，因此，**强烈建议大家对事件名称使用枚举或散列**，而不是在输入的时候一遍一遍检查。
* 安全性：socket.io 支持加密连接。
* 状态：Web 服务器采用 cookie，而 socket.io 本身支持 session

## 3.6 更智能的集线器： 事件交换机

通过分类将事件分成两组——广播和单播，使用事件交换机代替事件集线器，可以获得一些很巧妙的特性。除了节省网络带宽外。最大的特性就是自动防故障安全部署。

基于事件架构的一个最大承诺就是模块化。典型的整体程序被替换成多个独立的模块，这非常有利于可测试性。使用事件交换机代替集线器也非常有利于可部署性。

### 3.6.1 部署

通常单一应用程序的所有服务器端逻辑都与 HTTP 服务器交织在一起，部署一个新版本，通常需要一次性部署整个应用程序逻辑，然后重启 Web 服务器，即便是升级一小部分，也要全部重新部署。

基于事件的应用程序逻辑则完全独立于 Web 服务器，应用程序的逻辑分布在许多不同的独立模块中，模块可以完全独立于 Web 服务器进行更新和部署。

#### 单播事件

监听器告诉事件交换机，该事件是一个单播事件，并且它是唯一的监听器。当准备系统升级时，需要启动新版本的模块，该新版本的模块告知事件交换机现在它是唯一的事件监听器。事件交换机将通知旧模块，其将会被取代，此时旧模块在处理完未完成的事件后，就可以卸载了。没有丢失事件，事件交换机将单播事件切换到了新的监听器上，通过这种方式，可以实现无中断服务。

#### 广播事件

旧的事件监听器会广播给指定事件的所有其他监听器，以告知它们自己要被关闭了。

### 3.6.2 一种实现

关于事件交换机，有一个基于 socket.io 的样例实现 http://github.com/zzo/EventHub

客户端的事件库，刚搜的，有时间研究下，代码不多
https://github.com/Olical/EventEmitter/blob/master/EventEmitter.js

