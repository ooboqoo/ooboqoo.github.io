# 依赖注入

Angular 的依赖注入系统能够 JIT( 刚好及时 ) 的创建和交付所依赖的服务。

依赖注入 是一个很重要的程序设计模式。Angular 有自己的依赖注入框架，离开了它，我们几乎没法构建 Angular 应用。它使用得非常广泛，以至于几乎每个人都会把它简称为 **DI**。

## 为什么需要依赖注入

我们从下列代码开始：

```ts
export class Car {
  public engine: Engine;
  public tires: Tires;
  public description = 'No DI';
  constructor() {
    this.engine = new Engine();
    this.tires = new Tires();
  }
  // Method using the engine and tires
  drive() {
    return `${this.description} car with ` +
      `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;
  }
}
```

我们的 Car 类会在它的构造函数中亲自创建所需的每样东西。问题何在？
问题在于，我们这个 Car 类过于脆弱、缺乏弹性并且难以测试。

我们的 Car 类需要一个 Engine 和 Tires ，它没有去请求一个现成的实例， 而是在构造函数中用具体的 Engine 和 Tires 类新创建了一份只供自己用的副本。

如果 Engine 类升级了，并且它的构造函数要求传入一个参数了，该怎么办？ 我们这个 Car 类就被破坏了，这就会让 Car 类过于脆弱。

如果我们想在我们的 Car 上用一个不同品牌的轮胎会怎样？太糟了。 我们被锁死在 Tires 类创建时使用的那个品牌上。这让我们的 Car 类缺乏弹性。

现在，每辆车都有它自己的车载无线（代码中为 引擎）。我们的车缺乏必要的弹性，无法与其他消费者共享车载无线。

当我们给 Car 类写测试的时候，我们被它那些隐藏的依赖所摆布。 你以为能在测试环境中成功创建一个新的 Engine 吗？ Engine 自己又依赖什么？那些依赖本身又依赖什么？ Engine 的新实例会发起一个到服务器的异步调用吗？我们当然不想在测试期间这么一层层追下去。

如果我们的 Car 应该在轮胎气压低的时候闪动一个警示灯该怎么办？ 如果我们没法在测试期间换上一个低气压的轮胎，我们该如何确认它能正确的闪警示灯？

我们没法控制这辆车背后隐藏的依赖。 当我们不能控制依赖时，类就会变得难以测试。

我们该如何让 Car 更强壮、有弹性以及可测试？

答案超级简单。我们把 Car 的构造函数改造成使用 DI 的版本：

```ts
// 改造前
public engine: Engine;
public tires: Tires;
public description = 'No DI';

constructor() {
  this.engine = new Engine();
  this.tires = new Tires();
}

// 改造后
public description = 'DI';
constructor(public engine: Engine, public tires: Tires) { }
```

发生了什么？我们把依赖的定义移到了构造函数中。 我们的 Car 类不再创建引擎或者轮胎。 它仅仅“消费”它们。

### 依赖注入框架    我们刚刚学到了什么是依赖注入 

它是一种编程模式，该模式可以让一个类从外部源中获得它的依赖，而不必亲自创建它们。

酷！但是，可怜的消费者怎么办？ 那些希望得到一个 Car 的人们现在必须创建所有这三部分了： Car 、 Engine 和 Tires 。 Car 类把它的快乐建立在了消费者的痛苦之上。 我们需要某种机制把这三个部分装配好。

## Angular 依赖注入


