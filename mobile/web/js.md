# JavaScript

## 理解 JS

JavaScript 是浏览器所支持的一种脚本语言，是 ECMAScript 语言的一种实现，基于原型、多范式的动态脚本语言，并支持面向对象、命令式和声明式(如函数式编程)编程风格。JavaScript 包括 DOM 和 BOM。


## 事件

### 事件概述

事件 Event 是一种异步编程的实现方式，是程序各个组成部分间的通信。例如，当用户单击页面上的一个元素时，浏览器就会把该动作通过 Click 事件告诉应用程序。

浏览器为开发者提供了诸多事件类型，通过这些事件类型，使 Web 应用程序能够感知用户的行为和浏览器操作的变化。

事件的一些基本概念：
  * 事件类型
  * 事件目标
  * 事件处理程序
  * 事件对象
  * 事件传播

### 事件委托

事件模型中有两种机制：
  * 事件捕获 Capture Phase
  * 事件冒泡 Bubbling Phase

将事件交给父元素或祖先元素处理的方式，就叫事件委托 Event Delegation。事件委托主要有以下两个优点：
  * 提高性能 - 每个函数都会占用内存空间，只添加一个事件处理程序，所占用的内存空间更少
  * 动态监听 - 使用委托可以监听"未来"的元素，也即不存在的元素

在实际开发中，可能需要移除事件监听，在 DOM0 中只需要将 onclick 设置成 `null` 即可，而 DOM2 中移除事件监听是通过 `removeEventListener` 完成的。

### 移动端事件

伴随智能手机的普及，专门为移动端设备设计的事件也随之而来。这些事件主要包含三类：触摸事件、手势事件和传感器事件。

#### 触摸事件

触摸事件 Touch Event 是最常见、也是使用范围最广的移动端事件，包含以下四类： `touchstart` `touchmove` `touchend` `touchcancel`(当系统停止跟踪触摸时触发)。

触摸事件跟 PC 端的鼠标事件非常类似，如同 mousedown mousemove mouseup。

#### 手势事件

手势事件 Gesture Event 是在开发中使用较少的一类移动端事件，是对触摸事件的高级封装，包含以下三种类型：
  * gesturestart - 当手势开始(有2根或多根手指触摸屏幕)时触发
  * gesturechange - 当手势改变(有2根或多根手指触摸屏幕，且发生移动)时触发
  * gestureend - 当手势结束(倒数第2根手指离开)时触发

手势事件的 Event 对象是 GuestureEvent 类型，除了包含基础的 screenX screenY clientX clientY 等信息外，还包括如下信息：
  * scale - 缩放比例
  * rotation - 旋转角度

#### 传感器事件

传感器事件 Sensor Event 一般用于判断设备在三维空间的位置，常用的传感器事件有如下三种：
  * deviceorientation - 提供设备的物理方向信息，表示为一系列本地坐标系的旋角
  * devicemotion - 提供设备的加速信息，表示为定义在设备上的坐标系中的笛卡尔坐标
  * orientationchange - 提供设备的旋转方向信息，标明设备当前处于垂直或水平状态


## 作用域、闭包、this

### 块级作用域

ES5 只有全局作用域和函数作用域，ES6 新增了块级作用域。

### 闭包

JavaScript 查找变量即变量解析的过程，首先在当前定义的局部作用域中查找，如果未发现，就会查找上一层作用域。由于 JS 是基于词法(静态)作用域的语言，词法作用域的含义是在函数定义时就确定了作用域，而不是函数执行时再确定。

来自维基的定义，在计算机科学中，闭包 Closure 是词法闭包 Lexical Closure 的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。

将函数作为其他函数的返回值和作为参数传递时，常常就会不经意间创建闭包。

闭包导致内存未释放的情况，这让闭包可以用来保存中间计算结果，类似于实现了计算结果的缓存。闭包另一个使用场景是实现内部变量的封装，即使用匿名函数封装私有成员的单例模式。

滥用闭包也会导致一些诸如内存泄露的性能问题，这点在低版本的 IE 中表现地尤为明显，合理使用好闭包是成为一个优秀的前端工程师的必备要求。

### this

和变量的搜索过程不同，this 的值从执行上下文中获取，而不会在作用域链中搜寻。在面向对象的程序设计语言中，this 关键字指代当前对象，通常在编译期确定，称为编译期绑定，而在 JS 中，this 是动态绑定的，称为运行期绑定。this 可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式，不同的调用方式会产生不同的执行上下文。

在 JS 中，函数的调用方式有以下几种，作为函数调用、作为对象方法调用、作为构造函数调用，以及使用 call 和 apply 调用。

## 面向对象

面向对象是程序设计语言中一种常见的思想，是一种认知自然世界的哲学。JavaScript 是一种基于对象，但书写上又不同于传统面向对象编程的一门语言。

### 原型和原型链

```js
Object.create(prototype, descriptors);
o.__proto__ === o.constructor.prototype;
```

### Mixin 模式

Mixin 模式是开发者引入解决多重继承的方案。因为 JavaScript 继承来自原型链，所以需要做的就是将多个继承对象上的属性拷贝到一个原型上。

Mixin 模式的实现从类的角度来看并不优雅，在 ES7 中提供了装饰器语法，装饰器可以对类进行修改，下面提供一个使用装饰器实现 Mixin 模式的实例：

```js
function mixin(mixins) {
    return target => handleClass(target, mixins);  // handleClass 具体实现略
}
@mixin(config) class A {
    // ...
}
```

装饰器可以理解为对 class A 的一层函数包装，等同于 `mixin(config)(A)`。

### class

尽管原型链已经可以很好地实现继承，但是对于传统面向对象语言的开发者，原型链是很容易让人产生困惑的，`class` 和 `extends` 作为语法糖解决了开发者对于 JavaScript 继承的困惑。


## 异步编程

### 回调函数

### Promise 承诺

回调函数一层嵌套一层，层级多了代码的阅读会存在较大障碍，Promise 有效地解决了这一问题。

通过 Promise 可以避免出现回调多次嵌套后的"复杂"代码。通过 `Promise.all()` 和 `Promise.race()` 方法，可以容易地控制多个 Promise 并行执行。

### Generator 生成器

ES7 中提供了 `async` `await` 关键字，是一个更加优秀的异步解决方案。

```js
async function es7() {
    const a = await Promise.resolve(1);
    const b = await Promise.resolve(a * 2);
    return b;
}
es7().then(data => console.log(data));  // 异步函数返回结果为 Promise 对象
```


## 模块化

以功能块为单位进行程序设计，实现其求解算法的方法称为模块化，原则是"高内聚，低耦合"。高内聚尽量减少不同文件中函数的交叉引用，低耦合是模块与模块之间要相互独立。模块化的目的是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。

### 为什么需要模块化

### AMD CMD CommonJS

### ES6 标准模块支持


## ES6 其他常用功能

### 基础数据类型的扩展

ES6 不但对基础数据类型进行了扩展，而且增加了一个全新的基础数据类型 Symbol。

#### 字符串的扩展

新增常用字符串函数 并 引入模板字符串来简化字符串拼接。

```js
var s = 'Hello';
s.startsWith('He');  // true
s.endsWidth('lo');   // true
s.includes('el');    // true 
s.repeat(3);         // 'HelloHelloHello'
```

#### 数值的扩展

ES6 规范了二进制和八进制的表示方法。

```js
0o2000 === 1024;          // 八进制
0b100000000000 === 1024;  // 二进制
```

ES6 还将全局函数 `parseInt` `parseFloat` 移植到了 Number 对象上，并且在 Number 对象上增加了 `isNaN` `isInteger` 方法。

Number 对象增加了一个极小常量 `EPSILON`。由于浮点数的计算是不精确的，会导致无法判断浮点数的运算结果是否等于某个值。

```js
(0.1 + 0.2) === 0.3;  // false
Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON;  // true
```

#### 函数的扩展

ES6 可以给函数参数指定默认值  
ES6 引入了 Rest 语法来获取函数剩余参数  
ES6 使用箭头函数来简化函数的定义

```js
function minus(x, y = 2) { return x - y; }
function add(...values) { return values.reduce((acc, val) => acc + val, 0); }
```

#### 对象的扩展

ES6 支持对象定义时属性和函数的简写，并且属性名支持表达式。

```js
const p = 1;
const o = {
    p,
    ['a' + p]: 2,
    foo() {  }
};
```

#### Symbol 类型

Symbol 代表独一无二的值，可以用来避免冲突。

### 使用解构赋值来简化代码

ES6 对常用的数据结构提供了解构赋值的支持，以达到简化代码的目的。支持解构赋值的类型包括对象、数组、字符串、函数参数等。

### 使用 Babel 提前使用新特性

Babel 默认不对任何语法转换，需要事先通过配置文件来指定转码 ES6 语法特性。

通常在开发时，大部分的 ES6 语法都会用到，手动配置所有需要的插件是一件非常麻烦而且容易出错的工作。Babel 在插件机制上，提供了插件集，每个插件集包含相关联的一系列插件。

开发者需要注意的是，Babel 只对 ES6 的新语法进行转码，不会转换新的 API，比如不支持转码 Object.assign 函数。如果开发中用到新的 API，可以使用 babel-polyfill 添加垫片。

如果在 Node.js 环境里运行 JS 文件，除了可以使用命令在运行前进行转码外，也可以使用钩子在运行时进行转码。
