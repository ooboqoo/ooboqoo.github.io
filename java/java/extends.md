# 继承与接口

## 继承

在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以让新创建的类继承该类。利用继承的方法，可以重用已存在类的方法和属性，而不用覆写这些代码。被继承的类称为超类 super class，派生类称为子类 subclass。

```java
class 子类 extends 父类 { }   // 子类又被称为派生类；父类又被称为超类 Super Class
```

### 继承的特性

* 子类拥有父类非 private 的属性，方法。
* 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
* 子类可以用自己的方式实现父类的方法。
* Java 的继承是单继承，但是可以多层继承。
* 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。

### 构造器

子类不能继承父类的构造器(构造方法或者构造函数)，但必须在子类构造方法中首先(首行)调用父类的构造方法。

如果父类有无参构造器，`super` 调用可省略，系统会自动调用父类的无参构造器。

```java
class B extends A {
  public B() {
    super();  // 父类中有无参构造时此句可省略，但如果编写，此句必须是构造函数首行
    System.out.println("B 类构造方法");
  }

  public B(int num) {
    this();   // 出现 this() 时，无法再使用 super()，但出口构造方法肯定会显式或隐式调用 super()
  }
}
```

### 对象多态性

多态性在开发中可以体现在以下两个方面：
  * 方法的多态性：重载与覆写
      * 重载：同一个类中，同一个方法名称，根据不同的参数类型及个数可以完成不同的功能
      * 覆写：有继承关系的父子类中，同一个方法名称，根据实例化的子类对象不同，所完成的功能不同
  * 对象的多态性：父子类对象的转换
      * 向上转型：子类对象变为父类对象，格式 `父类 父类对象 = 子类实例;`，自动转换
      * 向下转型：父类对象变为子类对象，格式 `子类 子类对象 = (子类) 父类实例;`，强制转换

对象多态性和方法覆写是紧密联系在一起的。

对象向上转型，对象的声明类型决定了能够调用哪些方法，而实例化新对象时所调用的子类的构造方法决定了调用方法时的具体行为。

向下转型是强制转换操作，操作本身是有前提条件的，即必须发生向上转型后才可以发生向下转型。如果是两个没有关系的类对象发生强制转换，就会出现 ClassCastException 异常。所以向下转型是会存在安全隐患的，开发中应该尽量避免此类操作。`instanceof` 关键字可以准确地判断出实例化对象与类的关系，可以用来在强制转换前进行判断，以保证安全可靠的向下转型操作。

这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。

和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。


在实际开发中，对象向上转型的主要意义在于参数的统一，也是最为主要的用法，而对象的向下转型指的是调用子类的(特有)方法。

```java
class A {
  void print() {
    System.out.println("A.print()");
  }
}
class B extends A {
  void print() {
    System.out.println("B.print()");
  }
}
public class TestDemo {
  public static void main(String[] args) {
    A a = new B();
    foo(a);
  }
  public static foo(A a) {
    a.print();                // "B.print()"
    if (a instanceof B) {
      B b = (B) a;
      b.print();              // "B.print()"
    }
  }
}
```

#### 多态

Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。

这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。

多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。

所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？

可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

#### final

final
继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override：

如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承：

对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。

```java
class Person {
    public final String name;
    public Person(String name) {
        this.name = name;
    }
}
```


## 覆写与重载

### 覆写 override

#### 方法的覆写

一个类可能会产生多个子类，每个子类都可能会覆写父类中的方法，以定义特定于子类的行为。

当子类定义了和父类的方法名称、返回值类型、参数类型及个数完全相同的方法时，就称为方法的覆写。

覆写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。

注：当子类中存在被覆写过的方法，子类中直接使用方法名访问的是子类覆写的方法，如需调用父类方法可以使用 `super.method()`。

**方法的覆写规则**

* 参数列表必须完全与被覆写方法的相同(如果参数列表不一致，那就是新加方法了)。
* 返回类型必须完全与被覆写方法的返回类型相同(如果参数列表一致，返回类型不一样，编译报错)。
* 访问权限不能比父类中被覆写的方法的访问权限更低。
* 父类的成员方法只能被它的子类覆写。
* 声明为 final 的方法不能被覆写。
* 声明为 static 的方法不能被覆写，但是能够被再次声明。
* 声明为 private 的方法不能被覆写，但是能够被再次声明。
* 子类和父类在同一个包中，那么子类可以覆写父类所有方法，除了声明为 private 和 final 的方法。
* 子类和父类不在同一个包中，那么子类只能够覆写父类的声明为 public 和 protected 的非 final 方法。
* 覆写的方法不能抛出新的强制性异常，或者比被覆写方法声明的更广泛的强制性异常，反之则可以。
* 构造方法不能被覆写。
* 如果不能继承一个方法，则不能覆写这个方法。

加上 `@Override` 可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。但 `@Override` 不是必需的。


#### 属性的覆盖

如果子类定义了和父类完全相同的属性名称时，就称为属性的覆盖。

实际开发中，类中的属性必须使用 private 封装，那么一旦封装后属性覆盖是没有任何意义的。

### 重载 overload

重载 overloading 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。  
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。  
最常用的地方就是构造器的重载。  

**重载规则**

* 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；
* 被重载的方法可以改变返回类型；
* 被重载的方法可以改变访问修饰符；
* 被重载的方法可以声明新的或更广的检查异常；
* 方法能够在同一个类中或者在一个子类中被重载。
* 无法以返回值类型作为重载函数的区分标准。

#### 覆写与重载的区别

| 区别点   | 重载方法 | 覆写方法
|----------|----------|-----------------------------------------------
| 参数列表 | 必须修改 | 一定不能修改
| 返回类型 | 可以修改 | 一定不能修改
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）

### `final` 关键字

final 修饰的类不能被继承，修饰的方法不能被覆写，修饰的变量就成了常量。

常量必须在定义的时候设置好内容，并且不能修改，Java 命名规范要求常亮名称使用全大写的形式，开发中必须遵守。


## 抽象类

抽象类跟普通类的唯一不同之处在于，抽象类中含有抽象方法。

```java
abstract class A {
  public void foo() { /*方法体*/ }  // 普通方法定义
  public static void print();       // 抽象方法定义
}
```

这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

面向抽象编程的本质就是：

上层代码只定义规范（例如：abstract class Person）；

不需要子类就可以实现业务逻辑（正常编译）；

具体的业务逻辑由不同的子类实现，调用者并不关心。



### 抽象类的特性

1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
4. 构造方法，类方法(用 static 修饰的方法)不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

##### 开发中是继承一个普通类还是抽象类？

相比较开发的约定，开发者更愿意相信语法程度上给予的限定。很明显，强制子类去覆写父类的方法可以更好地进行操作的统一。
  * 抽象类继承子类里面会有明确的方法覆写要求，而普通类没有
  * 抽象类只比普通类多了一些抽象方法的定义，其他的组成部分与普通类无异
  * 普通类对象可以直接实例化，但抽象类必须经过向上转型后才可以得到实例化对象

### 抽象类应用

#### 模板设计模式

关键点：抽象类中的普通方法可以调用抽象类中的抽象方法。

短期内读者不会见到模板设计模式的应用，而如果学习到 Servlet 开发，就会接触到此知识的应用。所有的 Servlet 一定要继承 HttpServlet 类，而HttpServlet 类会根据用户发出的不同请求调用不同的方式进行处理，如，发出的请求是 get 请求，就调用 doGet() 方法，发出的是 post 请求，就调用 doPost() 方法。

#### 借助抽象类观察属性的赋值过程

```java
public class Test {
    public static void main(String[] args) {
        A a = new B(100);
    }
}

abstract class A {
    public A() { print(); }
    public abstract void print();
}

class B extends A {
    private int num = 10;
    public B() { print(); }
    public B(int num) {
        this();
        this.num = num;
        print();
    }
    public void print() {
        System.out.println(num);
    }
}
// 输出 0  10  100
```


## 接口

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

#### 接口的特性

* 接口是一个抽象类型，只能包含抽象方法和全局常量。
* 在 Java 中使用 `interface` 关键字来实现接口。
* 一个接口可以使用 `extends` 同时继承多个父接口。
* 类通过 `implements` 关键字来实现多个接口
* 除非实现接口的类是抽象类，否则该类必须实现接口中的全部抽象方法。
* 接口中只有抽象方法和全局常量，所以 `public` `abstract` `static final` 都可以省略，但建议不要省略。

```java
interface A {                                // 接口
  public static final String MSG = "HELLO";  // 全局常量
  public abstract void foo();                // 抽象方法
}
```

#### 接口与类的区别

* 接口不能用于实例化对象。
* 接口没有构造方法。
* 接口中所有的方法必须是抽象方法。
* 接口不能包含成员变量，除了 static 和 final 变量。
* 接口不是被类继承了，而是要被类实现。
* 接口支持多重继承。

#### 接口与抽象类的区别

Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。

抽象类和接口的对比如下：

abstract class            interface
继承  只能extends一个class  可以implements多个interface
字段  可以定义实例字段       不能定义实例字段
抽象方法  可以定义抽象方法   可以定义抽象方法
非抽象方法 可以定义非抽象方法 可以定义default方法

|    区别    |    抽象类                                     |  接口
|------------|-----------------------------------------------|--------------------------------------------
| 关键字     | `abstract` `class`                            | `interface`
| 组成       | 构造方法 普通方法 抽象方法 静态方法 常亮 变量 | 抽象方法 全局常量
| 子类使用   | `class 子类 extends 抽象类;`                  | `class 子类 implements 接口, 接口 ...`
| 关系       | 抽象类可以实现多个接口                        | 接口可以继承多个父接口
| 权限       | 可以使用各种权限                              | 只能使用 public 权限
| 限制       | 单继承局限                                    | 没有单继承局限
| 子类       | 抽象类和接口都必须有子类，子类必须覆写全部的抽象方法 ||
| 实例化对象 | 依靠子类对象的向上转型进行对象的实例化 |||

### 接口的继承

一个接口能继承另一个接口，和类之间的继承方式比较相似。

```java
public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}
 
class SuperClass {
    int i = 50;
}
 
class SubClass extends SuperClass implements A, B {
    int i = 100;
    public void showMessage() {
        System.out.printf("super.i = %d, this.i = %d\n", super.i, this.i);
    }
}
```


<pre style="font-size: 12px; line-height: 12px; border: none; white-space: pre; background-color: transparent;">
<code class="language-ascii" style="font-family: &quot;Courier New&quot;, Consolas, monospace;">┌───────────────┐
│   Iterable    │
└───────────────┘
        ▲                ┌───────────────────┐
        │                │      Object       │
┌───────────────┐        └───────────────────┘
│  Collection   │                  ▲
└───────────────┘                  │
        ▲     ▲          ┌───────────────────┐
        │     └──────────│AbstractCollection │
┌───────────────┐        └───────────────────┘
│     List      │                  ▲
└───────────────┘                  │
              ▲          ┌───────────────────┐
              └──────────│   AbstractList    │
                         └───────────────────┘
                                ▲     ▲
                                │     │
                                │     │
                     ┌────────────┐ ┌────────────┐
                     │ ArrayList  │ │ LinkedList │
                     └────────────┘ └────────────┘
</code>
</pre>

### 接口的应用

在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：

```java
List list = new ArrayList(); // 用List接口引用具体子类的实例
Collection coll = list; // 向上转型为Collection接口
Iterable it = coll; // 向上转型为Iterable接口
```

### default 方法

#### 工厂设计模式

#### 代理设计模式

