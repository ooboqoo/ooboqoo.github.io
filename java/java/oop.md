# 面向对象编程

Java 作为一种面向对象语言。支持以下基本概念：封装、抽象、继承、多态、类、对象、实例、方法、重载。

一个 Java 程序可以认为是一系列对象的集合，这些对象通过调用彼此的方法来协同工作。

在 Java 中，方法是不可以单独存在的，必须将其放在一个类中才可以。



## 面向对象概念

### 简介

面向对象的程序设计有封装性、继承性、多态性 3个主要特性。
  * 封装性  
    它包含两层含义：
    - 将对象的属性和行为看成一个密不可分的整体
    - 把不需要让外界知道的信息隐藏起来
  * 继承性  
    继承机制大大增强了代码的可复用性，提高了软件的开发效率，降低了错误产生的可能性，也为修改程序提供了便利。  
    被继承的类称为父类或超类，而经继承产生的类称为子类或派生类
  * 多态性  
    Java 中含有方法重载与对象多态两种形式的多态。
    - 方法重载，一个类中允许存在多个重名方法，但方法的参数不同，实现的功能也不同
    - 对象多态，子类对象可以与父类对象进行相互转换，而且根据其使用的子类不同完成的功能也不同

### 类与对象

面向对象是整个 Java 的核心，而类与对象又是支撑整个 Java 面向对象开发的基本概念单元。

#### 基本概念

类可以简单理解为生产对象的图纸。类定义了一个基本的模板，代表着一个共性的特征集合。

#### 类与对象

##### 类定义

类是 Java 中的基本组成元素，所有的 Java 程序一定要被类管理。

类的定义有两种形式：
  * `public class` 定义：类名称必须和文件名称保持一致，否则程序无法编译。一个 .java 文件只能有一个 public calss
  * `class` 定义：类名称可以和文件名不一致，但是生成的 class 文件的名称同类名。一个 .java 文件可以存在多个 calss 定义，编译后会生成多个 class 文件。

class 是一种对象模版，它定义了如何创建实例，因此，class 本身就是一种数据类型：

类中的属性在 Java 中称为 成员(Field)，而方法在 Java 中使用 Method 来描述。

一个class可以包含多个字段（field），字段用来描述一个类的特征。上面的Person类，我们定义了两个字段，一个是String类型的字段，命名为name，一个是int类型的字段，命名为age。因此，通过class，把一组数据汇集到一个对象上，实现了数据封装。


在OOP中，class和instance是“模版”和“实例”的关系；

定义class就是定义了一种数据类型，对应的instance是这种数据类型的实例；

class定义的field，在每个instance都会拥有各自的field，且互不干扰；

通过new操作符创建新的instance，然后用变量指向它，即可通过变量来引用这个instance；

访问实例字段的方法是变量名.字段名；

指向instance的变量都是引用变量。


```java
class 类名称 {
  数据类型 属性;  // 变量
  public 返回值的数据类型 方法名称(参数1, 参数2) {
    程序语句;
    return 表达式;
  }
}
```

实际开发中，一般都是一个 java 文件基本上只包含一个 public class，不会有其他 class 单独定义。

```java
public class Dog {
  String breed;
  int age;
  String color;
  void barking() { }
  void hungry() { }
  void sleeping() { }
}
```

##### 创建对象

```java
类名称 对象名称 = new 类名称();
```

使用关键字 `new` 来创建一个新的对象。创建对象需要以下三步：
  * 声明：声明一个对象，包括对象名称和对象类型。
  * 实例化：使用关键字 new 来创建一个对象。
  * 初始化：使用 new 创建对象时，会调用构造方法初始化对象。

关键字 `new` 的主要功能就是开辟内存空间(新的堆内存空间)。

每个对象在刚刚实例化后，里面所有属性的内容都是其对应数据类型的默认值，只是设置了属性内容之后，属性才可以保存内容。

对象使用前都必须实例化，如果只是声明了对象但并没有实例化，就会出现空指向异常 NullPointerException。

> **堆内存与栈内存**  
> * 堆内存 heap - 保存每一个对象的属性内容，堆内存用关键字 new 开辟  
> * 栈内存 stack - 保存的是一块堆内存的地址数值，可以把它想象成一个 int 型变量
> 
> 注：根据存储数据的不同，Java 内存通常被划分为5个区域：程序计数器 Program Count Register、本地方法栈 Native Stack、方法区 Methon Area、栈 Stack、堆 Heap。

##### 引用传递

引用传递是整个 Java 的精髓所在，其的核心概念只有一点：一块堆内存空间(保留对象的属性信息)可以同时被多个栈内存共同指向。

> **Java 的垃圾回收机制**

### 封装特性

但是，直接把field用public暴露给外部可能会破坏封装性。比如，代码可以这样写：

显然，直接操作field，容易造成逻辑混乱。为了避免外部代码直接去访问field，我们可以用private修饰field，拒绝外部访问：

所有在类中定义的属性都要求使用 `private` 声明，如果属性要被外部所使用，那么按照要求定义相应的 setter getter 方法。

```java
class Person {
  private String name;
  private int age;

  public String getName() {
    return this.name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public int getAge() {
    return this.age;
  }

  public void setAge(int age) {
    if (age < 0 || age > 100) {
      throw new IllegalArgumentException("invalid age value");
    }
    this.age = age;
  }
}
```

### 构造方法

每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。

在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

```java
public class Puppy {
    public Puppy() { }
    public Puppy(String name) { /* 这个构造器仅有一个参数：name */ }
}
```

构造方法的定义原则：
  * 方法名称与类名称相同
  * 没有返回值类型声明
  * 构造方法可以重载
  * 构造方法可以省略，如果省略，编译期会自动添加一个空的构造方法

构造方法与普通方法的差异：
  * 返回值声明：构造方法没有返回值，且没有 void 声明
  * 调用时间：构造方法只会在对象实例化时由系统调用，而普通方法是在对象实例化后通过 "对象.方法" 的形式手动调用
  * 调用次数：构造方法只会在创建对象时执行一次，而普通方法可以调用多次

类定义最佳实践：先编写属性，再写构造方法，最后是普通方法。

方法重载的编写顺序：所有重载的方法按照参数的个数由多到少，或由少到多排列。

对象实例化过程 `Person p = new Person();`：
  1. JVM 会去读取指定路径下的 Person.class 文件，并加载进内存，如有父类会先加载父类
  2. 通过 new 关键字开辟一块堆内存，(根据对象属性的数据类型)分配地址
  3. 调用构造方法对属性进行初始化，如有父类，构造函数中第一行会先调用父类中的构造函数。
  4. 初始化完毕后，将堆内存中的地址值赋给引用变量。

### 继承

在OOP的术语中，我们把Person称为超类（super class），父类（parent class），基类（base class），把Student称为子类（subclass），扩展类（extended class）。

继承树
注意到我们在定义Person的时候，没有写extends。在Java中，没有明确写extends的类，编译器会自动加上extends Object。所以，任何类，除了Object，都会继承自某个类。下图是Person、Student的继承树：

Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有Object特殊，它没有父类。

行上面的代码，会得到一个编译错误，大意是在Student的构造方法中，无法调用Person的构造方法。

这是因为在Java中，任何class的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句super();，所以，Student类的构造方法实际上是这样：

这里还顺带引出了另一个问题：即子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。



## Java 中类的实现细节

#### 匿名对象

如果没有栈内存指向堆内存空间，就是一个匿名对象。

由于匿名对象没有对应的栈内存指向，所有只能使用一次，一次之后就将成为垃圾，等待被 GC 回收释放。

```java
public static void main(String[] args) {
  new Book("Java 开发", 69.8).getInfo();  // 创建对象并立即调用方法，用完立即变垃圾
}
```

#### 简单 Java 类

简单 Java 类 是一种在实际开发中使用最多的类定义形式，其有如下基本开发要求：
  * 类名称必须存在意义
  * 类中所有的属性必须 `private` 封装，封装后的属性必须提供 setter getter
  * 类中可以提供任意多个构造方法，但是必须保留一个无参构造方法
  * 类中不允许出现任何输出语句，所有信息输出必须交给被调用处输出
  * 类中需要提供一个取得对象完整信息的方法，暂定为 getInfo()，而且返回 String 型数据。

### 对象比较

对象比较的操作有如下4个特点：
* 本类接收自己的引用，再与本类当前对象(this)进行比较
* 为了避免产生 NullPointerException，应该增加一个 null 的判断
* 为了防止浪费性能的情况出现(要判断的属性会多)，可以增加地址数值的判断
* 进行属性的依次比较，如果属性全部相同，这返回 true 否则 false

```java
class Book {
  private String title;
  private double price;
  public Book(String title, double price) {
    this.title = title;
    this.price = price;
  }
  public boolean compare(Book book) {
    if (book == null) { return false; }
    if (book == this) { return true; }
    if (this.title.equals(book.title) && this.price == book.price) { return true; }
    else { return false; }
  }
}
```

### 内部类

#### 基本概念

所谓内部类指的就是在一个类的内部继续定义其他内部结构类的情况。

内部类就是将类的定义放到另外一个类定义的内部，也就是说，类中除了属性和方法外，也可以定义属于自己内部的结构体。这样做的最大缺点在于：破坏了类的结构性。但这样做最大好处是可以轻松地访问外部类中的私有属性。

##### 在外部直接产生内部类实例

内部类编译生成的 class 文件名的形式为 `Outer$Inner.class`，内部类实例化语法如下：

```java
外部类.内部类 对象 = new 外部类().new 内部类();
```

由于内部类需要使用外部类中的属性，而所有属性只有在对象实例化之后才会分配空间，所以在实例化内部类对象时首先要实例化外部类对象。

```java
class Outer {
  private String msg = "Hello World!";
  class Inner {
    public void print() {
      System.out.println(Outer.this.msg);  // 可以直接通过 msg 访问外部类私有属性，但这样写更规范
    }
  }
}

public TestDemo {
  public static void main(String[] args) {
    Outer.Inner in = new Outer().new Inner();
    in.print();
  }
}
```

#### 使用 `static` 定义内部类

如果一个内部类使用 `static` 定义，那么它只能访问外部类中的 `static` 操作，相当于定义了一个外部类。

#### 在方法中定义内部类

内部类理论上可以在类的任意位置上进行定义，包括在代码块中，或在普通方法中。而在开发过程中，在普通方法里面定义内部类的情况是最多的。

在 JDK1.7 以及之前的版本中，方法中定义的内部类如果想要访问方法的参数或方法定义的变量，在参数或变量前一定要加上 `final` 标记，但从 JDK1.8 开始取消了这一限制，主要是为 Lambda 编写方便。

```java
class Outer {
  private String msg = "Hello World!";
  public void foo(final int num) {
    final double score = 99.9;
    class Inner {
      public void print() {
        System.out.println(Outer.this.msg);
        System.out.println(num);
        System.out.println(score);
      }
    }
    new Inner().print();
  }
}
```

#### 匿名内部类

匿名类因为没有名字，所以只能使用一次，它通常用来简化代码编写。

使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。

使用匿名内部类的目的，是在某个地方想对某个类有特殊的实现。

JDK1.8 开始匿名类的用法可以用 Lambda 写法替换。

```java
class Outer {
  private String msg = "Hello World!";
  public void foo(final int num) {
    final double score = 99.9;
    // 匿名内部类写法
    new Inner() {
      public void print() {
        System.out.println(Outer.this.msg);
        System.out.println(num);
        System.out.println(score);
      }
    }.print();
    // Lambda 写法
    ((Inner) () -> {
        System.out.println(Outer.this.msg);
        System.out.println(num);
        System.out.println(score);
    }).print();
  }
};

Interface Inner {
  public void print();
}
```

### `this` 关键字

在 Java 中 `this` 可以完成3件事情：调用本类属性、调用本类方法、表示当前对象。

#### 调用本类属性

在一个类的定义的方法中可以直接访问类中的属性，但是很多时候有可能会出现方法参数名称与属性名称重复的情况，所以此时就需要利用 `this.属性` 的形式明确指出要调用的是类中的属性而不是方法的参数。为了减少不必要的麻烦，在类中访问属性是不管是否有重名的变量，统一加上 `this`。

#### 调用本类方法

`this` 除了访问类中的属性，也可以进行类中方法的调用。除了调用普通方法，还可以利用 `this()` 的形式实现一个类中多个构造方法的互相调用。

通过 `this()` 语法，可以很好地解决构造方法中代码重复的问题，但使用中须注意两点限制：

* 使用 `this();` 时，必须是构造方法的首行。
* 构造方法互相调用时，一定要保留调用的出口，即，不允许出现循环调用的情况。

### `static` 关键字

在一个class中定义的字段，我们称之为实例字段。实例字段的特点是，每个实例都有独立的字段，各个实例的同名字段互不影响。

还有一种字段，是用static修饰的字段，称为静态字段：static field。

实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。


通过实例变量也可以调用静态方法，但这只是编译器自动帮我们把实例改写成类名而已。

通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告。

接口的静态字段
因为interface是一个纯抽象类，所以它不能定义实例字段。但是，interface是可以有静态字段的，并且静态字段必须为final类型：

public interface Person {
    public static final int MALE = 1;
    public static final int FEMALE = 2;
}
实际上，因为interface的字段只能是public static final类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：

public interface Person {
    // 编译器会自动加上public statc final:
    int MALE = 1;
    int FEMALE = 2;
}
编译器会自动把该字段变为public static final类型。

#### 定义属性

一个类的主要组成就是属性和方法，而每一个对象都分别拥有各自的属性内容，如果类中的某个属性希望定义为公共属性，则可以在声明属性前加上 `static` 关键字。

> **常用内存区域**  
> 在 Java 中主要存在4块内存空间，这些内存空间的名称及作用如下
>   * 栈内存空间，保存所有的对象名称(更准确的说是保存引用的堆内存空间的地址)
>   * 堆内存空间，保存每个对象的具体属性内容
>   * 全局数据区，保存 static 类型的属性
>   * 全局代码区，保存所有的方法定义

通过 `static` 属性定义的属性将成为公共属性，也就是说，任何一个对象修改了此属性的内容都将影响其他对象。

非 `static` 属性必须产生实例化对象才可以访问，但 `static` 属性不受实例化对象的控制，可以通过类名直接调用。

#### 定义方法

使用 `static` 定义的方法也可以在没有实例化对象产生的情况下通过类名进行调用。

`static` 方法不能直接访问非 `static` 属性或方法，只能调用 `static` 属性或方法。



## 继承

在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以让新创建的类继承该类。利用继承的方法，可以重用已存在类的方法和属性，而不用覆写这些代码。被继承的类称为超类 super class，派生类称为子类 subclass。

```java
class 子类 extends 父类 { }   // 子类又被称为派生类；父类又被称为超类 Super Class
```

### 继承的特性

* 子类拥有父类非 private 的属性，方法。
* 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
* 子类可以用自己的方式实现父类的方法。
* Java 的继承是单继承，但是可以多层继承。
* 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。

### 构造器

子类不能继承父类的构造器(构造方法或者构造函数)，但必须在子类构造方法中首先(首行)调用父类的构造方法。

如果父类有无参构造器，`super` 调用可省略，系统会自动调用父类的无参构造器。

```java
class B extends A {
  public B() {
    super();  // 父类中有无参构造时此句可省略，但如果编写，此句必须是构造函数首行
    System.out.println("B 类构造方法");
  }

  public B(int num) {
    this();   // 出现 this() 时，无法再使用 super()，但出口构造方法肯定会显式或隐式调用 super()
  }
}
```

### 对象多态性

多态性在开发中可以体现在以下两个方面：
  * 方法的多态性：重载与覆写
      * 重载：同一个类中，同一个方法名称，根据不同的参数类型及个数可以完成不同的功能
      * 覆写：有继承关系的父子类中，同一个方法名称，根据实例化的子类对象不同，所完成的功能不同
  * 对象的多态性：父子类对象的转换
      * 向上转型：子类对象变为父类对象，格式 `父类 父类对象 = 子类实例;`，自动转换
      * 向下转型：父类对象变为子类对象，格式 `子类 子类对象 = (子类) 父类实例;`，强制转换

对象多态性和方法覆写是紧密联系在一起的。

对象向上转型，对象的声明类型决定了能够调用哪些方法，而实例化新对象时所调用的子类的构造方法决定了调用方法时的具体行为。

向下转型是强制转换操作，操作本身是有前提条件的，即必须发生向上转型后才可以发生向下转型。如果是两个没有关系的类对象发生强制转换，就会出现 ClassCastException 异常。所以向下转型是会存在安全隐患的，开发中应该尽量避免此类操作。`instanceof` 关键字可以准确地判断出实例化对象与类的关系，可以用来在强制转换前进行判断，以保证安全可靠的向下转型操作。

这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。

和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。


在实际开发中，对象向上转型的主要意义在于参数的统一，也是最为主要的用法，而对象的向下转型指的是调用子类的(特有)方法。

```java
class A {
  void print() {
    System.out.println("A.print()");
  }
}
class B extends A {
  void print() {
    System.out.println("B.print()");
  }
}
public class TestDemo {
  public static void main(String[] args) {
    A a = new B();
    foo(a);
  }
  public static foo(A a) {
    a.print();                // "B.print()"
    if (a instanceof B) {
      B b = (B) a;
      b.print();              // "B.print()"
    }
  }
}
```

#### 多态

Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。

这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。

多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。

所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？

可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

#### final

final
继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override：

如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承：

对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化后不能被修改。

```java
class Person {
    public final String name;
    public Person(String name) {
        this.name = name;
    }
}
```


## 覆写与重载

### 覆写 override

#### 方法的覆写

一个类可能会产生多个子类，每个子类都可能会覆写父类中的方法，以定义特定于子类的行为。

当子类定义了和父类的方法名称、返回值类型、参数类型及个数完全相同的方法时，就称为方法的覆写。

覆写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。

注：当子类中存在被覆写过的方法，子类中直接使用方法名访问的是子类覆写的方法，如需调用父类方法可以使用 `super.method()`。

**方法的覆写规则**

* 参数列表必须完全与被覆写方法的相同(如果参数列表不一致，那就是新加方法了)。
* 返回类型必须完全与被覆写方法的返回类型相同(如果参数列表一致，返回类型不一样，编译报错)。
* 访问权限不能比父类中被覆写的方法的访问权限更低。
* 父类的成员方法只能被它的子类覆写。
* 声明为 final 的方法不能被覆写。
* 声明为 static 的方法不能被覆写，但是能够被再次声明。
* 声明为 private 的方法不能被覆写，但是能够被再次声明。
* 子类和父类在同一个包中，那么子类可以覆写父类所有方法，除了声明为 private 和 final 的方法。
* 子类和父类不在同一个包中，那么子类只能够覆写父类的声明为 public 和 protected 的非 final 方法。
* 覆写的方法不能抛出新的强制性异常，或者比被覆写方法声明的更广泛的强制性异常，反之则可以。
* 构造方法不能被覆写。
* 如果不能继承一个方法，则不能覆写这个方法。

加上 `@Override` 可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。但 `@Override` 不是必需的。


#### 属性的覆盖

如果子类定义了和父类完全相同的属性名称时，就称为属性的覆盖。

实际开发中，类中的属性必须使用 private 封装，那么一旦封装后属性覆盖是没有任何意义的。

### 重载 overload

重载 overloading 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。  
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。  
最常用的地方就是构造器的重载。  

**重载规则**

* 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；
* 被重载的方法可以改变返回类型；
* 被重载的方法可以改变访问修饰符；
* 被重载的方法可以声明新的或更广的检查异常；
* 方法能够在同一个类中或者在一个子类中被重载。
* 无法以返回值类型作为重载函数的区分标准。

#### 覆写与重载的区别

| 区别点   | 重载方法 | 覆写方法
|----------|----------|-----------------------------------------------
| 参数列表 | 必须修改 | 一定不能修改
| 返回类型 | 可以修改 | 一定不能修改
| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常
| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）

### `final` 关键字

final 修饰的类不能被继承，修饰的方法不能被覆写，修饰的变量就成了常量。

常量必须在定义的时候设置好内容，并且不能修改，Java 命名规范要求常亮名称使用全大写的形式，开发中必须遵守。


## 抽象类

抽象类跟普通类的唯一不同之处在于，抽象类中含有抽象方法。

```java
abstract class A {
  public void foo() { /*方法体*/ }  // 普通方法定义
  public static void print();       // 抽象方法定义
}
```

这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

面向抽象编程的本质就是：

上层代码只定义规范（例如：abstract class Person）；

不需要子类就可以实现业务逻辑（正常编译）；

具体的业务逻辑由不同的子类实现，调用者并不关心。



### 抽象类的特性

1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
4. 构造方法，类方法(用 static 修饰的方法)不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

##### 开发中是继承一个普通类还是抽象类？

相比较开发的约定，开发者更愿意相信语法程度上给予的限定。很明显，强制子类去覆写父类的方法可以更好地进行操作的统一。
  * 抽象类继承子类里面会有明确的方法覆写要求，而普通类没有
  * 抽象类只比普通类多了一些抽象方法的定义，其他的组成部分与普通类无异
  * 普通类对象可以直接实例化，但抽象类必须经过向上转型后才可以得到实例化对象

### 抽象类应用

#### 模板设计模式

关键点：抽象类中的普通方法可以调用抽象类中的抽象方法。

短期内读者不会见到模板设计模式的应用，而如果学习到 Servlet 开发，就会接触到此知识的应用。所有的 Servlet 一定要继承 HttpServlet 类，而HttpServlet 类会根据用户发出的不同请求调用不同的方式进行处理，如，发出的请求是 get 请求，就调用 doGet() 方法，发出的是 post 请求，就调用 doPost() 方法。

#### 借助抽象类观察属性的赋值过程

```java
public class Test {
    public static void main(String[] args) {
        A a = new B(100);
    }
}

abstract class A {
    public A() { print(); }
    public abstract void print();
}

class B extends A {
    private int num = 10;
    public B() { print(); }
    public B(int num) {
        this();
        this.num = num;
        print();
    }
    public void print() {
        System.out.println(num);
    }
}
// 输出 0  10  100
```


## 接口

接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。

#### 接口的特性

* 接口是一个抽象类型，只能包含抽象方法和全局常量。
* 在 Java 中使用 `interface` 关键字来实现接口。
* 一个接口可以使用 `extends` 同时继承多个父接口。
* 类通过 `implements` 关键字来实现多个接口
* 除非实现接口的类是抽象类，否则该类必须实现接口中的全部抽象方法。
* 接口中只有抽象方法和全局常量，所以 `public` `abstract` `static final` 都可以省略，但建议不要省略。

```java
interface A {                                // 接口
  public static final String MSG = "HELLO";  // 全局常量
  public abstract void foo();                // 抽象方法
}
```

#### 接口与类的区别

* 接口不能用于实例化对象。
* 接口没有构造方法。
* 接口中所有的方法必须是抽象方法。
* 接口不能包含成员变量，除了 static 和 final 变量。
* 接口不是被类继承了，而是要被类实现。
* 接口支持多重继承。

#### 接口与抽象类的区别

Java的接口特指interface的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。

抽象类和接口的对比如下：

abstract class            interface
继承  只能extends一个class  可以implements多个interface
字段  可以定义实例字段       不能定义实例字段
抽象方法  可以定义抽象方法   可以定义抽象方法
非抽象方法 可以定义非抽象方法 可以定义default方法

|    区别    |    抽象类                                     |  接口
|------------|-----------------------------------------------|--------------------------------------------
| 关键字     | `abstract` `class`                            | `interface`
| 组成       | 构造方法 普通方法 抽象方法 静态方法 常亮 变量 | 抽象方法 全局常量
| 子类使用   | `class 子类 extends 抽象类;`                  | `class 子类 implements 接口, 接口 ...`
| 关系       | 抽象类可以实现多个接口                        | 接口可以继承多个父接口
| 权限       | 可以使用各种权限                              | 只能使用 public 权限
| 限制       | 单继承局限                                    | 没有单继承局限
| 子类       | 抽象类和接口都必须有子类，子类必须覆写全部的抽象方法 ||
| 实例化对象 | 依靠子类对象的向上转型进行对象的实例化 |||

### 接口的继承

一个接口能继承另一个接口，和类之间的继承方式比较相似。

```java
public interface A {
    public void eat();
    public void sleep();
}
 
public interface B {
    public void show();
}
 
class SuperClass {
    int i = 50;
}
 
class SubClass extends SuperClass implements A, B {
    int i = 100;
    public void showMessage() {
        System.out.printf("super.i = %d, this.i = %d\n", super.i, this.i);
    }
}
```


<pre style="font-size: 12px; line-height: 12px; border: none; white-space: pre; background-color: transparent;">
<code class="language-ascii" style="font-family: &quot;Courier New&quot;, Consolas, monospace;">┌───────────────┐
│   Iterable    │
└───────────────┘
        ▲                ┌───────────────────┐
        │                │      Object       │
┌───────────────┐        └───────────────────┘
│  Collection   │                  ▲
└───────────────┘                  │
        ▲     ▲          ┌───────────────────┐
        │     └──────────│AbstractCollection │
┌───────────────┐        └───────────────────┘
│     List      │                  ▲
└───────────────┘                  │
              ▲          ┌───────────────────┐
              └──────────│   AbstractList    │
                         └───────────────────┘
                                ▲     ▲
                                │     │
                                │     │
                     ┌────────────┐ ┌────────────┐
                     │ ArrayList  │ │ LinkedList │
                     └────────────┘ └────────────┘
</code>
</pre>

### 接口的应用

在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：

```java
List list = new ArrayList(); // 用List接口引用具体子类的实例
Collection coll = list; // 向上转型为Collection接口
Iterable it = coll; // 向上转型为Iterable接口
```

### default 方法

#### 工厂设计模式

#### 代理设计模式





## 方法

在前面几个章节中我们经常使用到 `System.out.println()`，那么它是什么呢？`println()` 是一个方法，`System` 是系统类，`out` 是标准输出对象。这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。

### 方法的定义

```text
修饰符 返回值类型 方法名(参数类型 参数名) {
    方法体;
    return 返回值;
}
```

```java
static float interest(float principal, int year){ /* 方法体 */ }
```

### 方法调用 和 void

### 方法的重载

这种方法名相同，但各自的参数不同，称为方法重载（Overload）。

方法重载就是一个类的两个方法拥有相同的名字，但是有不同的参数列表。Java 编译器根据方法签名判断哪个方法应该被调用。

方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。

重载的方法必须拥有不同的参数列表(参数类型、参数个数)。你不能仅仅依据修饰符或者返回类型的不同来重载方法。

虽然重载方法可以返回不同的类型，但不建议这么做，所有重载后的方法应使用同一种返回值类型。

### 变量作用域

局部变量必须声明才可以使用。

方法的参数范围涵盖整个方法。参数实际上是一个局部变量。

for 循环的初始化部分声明的变量，其作用范围在整个循环。

### 命令行参数的使用

```java
public class CommandLine {
   public static void main(String args[]) { 
      for (int i = 0; i < args.length; i++) {
         System.out.println("args[" + i + "]: " + args[i]);
      }
   }
}
```

### 构造方法

当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。

### 可变参数

JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号(...) 。
一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。

可变参数用 `类型...` 定义，可变参数相当于数组类型，那为什么不直接写成数组形式呢？
* 写成数组形式，调用方需要自己先构造数组，比较麻烦。
* 而可变参数保证不传入 `null`，传入0个参数时，接收到的实际值是一个空数组而不是 `null`。

```java
public static void printMax(double... numbers) {
    if (numbers.length == 0) {
        System.out.println("No argument passed");
        return;
    }
    // ...
    System.out.println("The max value is " + result);
}
```

### finalize() 方法

Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 `finalize()`，它用来清除回收对象。





