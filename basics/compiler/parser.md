# 解析器


## 编译原理

编译原理是用来做什么的？从源语言提取需要的信息；把源语言翻译成目标语言；自动生成满足一定规范的文本。

隆重推荐 ["Parsing Techniques"](https://dickgrune.com/Books/PTAPG_1st_Edition/)，没有一行代码，没有一句公式，但什么都讲明白了。第一版免费下，第二版加的东西也用不上。

人们可能会说，现在做 parser 的工具这么多，学这些有用吗？当然有用。数据结构都被封装好了，你们不还是要学过一遍，才能把别人的库用得高效。做 parser 也一样，没有受过训练的人，很容易语法总结成屎，或者因为想象力不够而无法实现自己的需求。工作中要是真用到了，多半还是随便看点资料(如 Engineering a Compiler)，知道点优化的概念和架构的知识，然后直接用 LLVM 干了。

### 为什么学编译原理

编译技术是计算机科学皇冠上的明珠之一。历史上各门计算机语言的发明人，总是被当作英雄膜拜。很多国外厂商的软件，普遍都具备二次编程能力。目前来看，谷歌、苹果、微软这些技术巨头们的核心能力，都是拥有自己的语言和生态。可见编译技术有多么重要！

编译原理不是只能用于炫耀的屠龙技。作为程序员，*在实际工作中你经常会碰到需要编译技术的场景*。

Java 程序员想必很熟悉 Hibernate 和 Spring，前者用到了编译技术做 HQL 的解析，后者对注解的支持和字节码动态生成也属于编译技术。所以，如果你要深入理解和用好这类工具，甚至想写这种类型的工具，会需要编译技术。

而 PHP 程序员在写程序的时候，一般会用到模板引擎实现界面设计与代码的分离。模板引擎对模板进行编译，形成可执行的 PHP 代码。模板引擎可以很强大，支持条件分支、循环等语法。如果你了解编译技术，会更容易掌握这些模板引擎，甚至写出更符合领域需求的模板引擎。

如果你要参与编写一个基础设施类的软件，比如数据库软件、ETL 软件、大数据平台等，很多需要采用编译技术提供软件自带的语言功能，比如 SQL。这种功能无法由外部通用语言实现。

*除了丰富的应用场景，学习编译技术对于提升程序员的竞争力也很重要。* 现在一些大公司在招聘程序员时，有难度的面试题都是涉及底层机制的。只有理解了底层机制，才能更深入地思考问题，拥有深层次解决问题的能力，而不是盲目地搜索答案，从表面解决问题。学习编译原理能让你从前端的语法维度、代码优化的维度、与硬件结合的维度这几个方面，加深对计算机技术的理解，提升竞争力。

### 编译器的前端技术

这里的前端 *指的是编译器对程序代码的分析和理解过程*。它通常只跟语言的语法有关，跟目标机器无关。而与之对应的后端则是生成目标代码的过程，跟目标机器有关。大学讲的编译原理，也是侧重讲解前端技术。

前端技术分为词法分析、语法分析和语义分析三个部分。主要涉及自动机和形式语言方面的基础的计算理论。
* 词法分析 是把程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现。
* 语法分析 是把程序的结构识别出来，并形成一棵便于由计算机处理的抽象语法树。可以用递归下降的算法来实现。
* 语义分析 是消除语义模糊，生成一些属性信息，使得计算机能够依据这些信息生成目标代码。

<img src="images/compiler.jpg" width="685" style="clip-path: inset(20px 0 20px 0); margin: -20px 0;">

#### 词法分析 Lexical Analysis

文章是由一个个的单词组成的，程序处理也一样，只不过这里不叫单词，而是叫做 **词法记号 Token**。

我们可以通过制定一些规则来区分每个不同的 Token。这些规则可以通过手写程序来实现，或者用*词法分析器的生成工具*(如 Lex)来生成。这些生成工具是基于一些规则来工作的，这些规则用 **正则文法(Regular Grammar)** 表达，符合正则文法的表达式称为 **正则表达式**。生成工具读入正则表达式，并生成一种叫 **有限自动机(Finite-state Automaton，FSA，or Finite Automaton)** 的算法，来完成具体的词法分析工作。

有限自动机是有限个状态的自动机器。例如，词法分析程序在扫描 `age` 的时候，处于“标识符”状态，等它遇到一个 `>` 符号，就切换到“比较操作符”的状态。词法分析过程，就是这样一个个状态迁移的过程。

<div>
  <img src="./images/lexical-analysis.jpg" width="571">
  <div style="position: absolute; margin-top: -140px; padding: 0 5px; color: #faa; background: #eefefe;">age >= 45</div>
</div>

#### 语法分析 Syntactic Analysis / Parsing

程序有定义良好的语法结构，语法分析过程，就是构造一棵 **抽象语法树 Abstract Syntax Tree，AST**。树的每个节点(子树)是一个语法单元，这个单元的构成规则就叫 **语法**。每个节点还可以有下级节点。

形成 AST 以后计算机就很容易去处理。比如，针对表达式(2 + 3 * 5)形成的这棵树(图略)，从根节点遍历整棵树就可以获得表达式的值。如果再把循环语句、判断语句、赋值语句等节点加到 AST 上，并解释执行它，那么你实际上就实现了一个脚本语言。而执行脚本语言的过程，就是遍历 AST 的过程。

https://resources.jointjs.com/demos/javascript-ast 这个网址可以生成 JavaScript 语言的 AST。

<img src="./images/syntactic-analysis.jpg" width="495">
<img src="./images/syntactic-analysis2.png">

##### 构建 AST

一种非常直观的构造思路是自上而下进行分析。首先构造根节点，代表整个程序，之后向下扫描 Token 串，构建它的子节点。我们拿 `int age = 45;` 来分析。当它看到一个 int 类型的 Token 时，知道这儿遇到了一个变量声明语句，于是建立一个“变量声明”节点；接着遇到 age，建立一个子节点，这是第一个变量；之后遇到 =，意味着这个变量有初始化值，那么建立一个初始化的子节点；最后，遇到“字面量”，其值是 45。这样，一棵子树就扫描完毕了。程序退回到根节点，开始构建根节点的第二个子节点。这样递归地扫描，直到构建起一棵完整的树。这个算法就是非常常用的 **递归下降算法 Recursive Descent Parsing**。是不是很简单？你完全可以动手写出来。

递归下降算法是一种自顶向下的算法，与之对应的，还有自底向上的算法。这个算法会先将最下面的叶子节点识别出来，然后再组装上一级节点。有点儿像搭积木，我们总是先构造出小的单元，然后再组装成更大的单元。

原理就是这么简单。除了手写分析器，你可以去找找现成的工具，如 Yacc、Antlr、JavaCC 等。另外你还能找到很多开源的语法规则文件，改一改，就能用工具生成你的语法分析器。

很多同学其实已经做过语法解析的工作，比如编写一个自定义公式的功能，对公式的解析就是语法分析过程。分析日志文件时对每行日志的解析，解析 XML、JSON 等各种配置文件，其本质也是语法分析过程，甚至有部分还包含了语义分析工作。

#### 语义分析 Semantic Analysis

*语义分析的过程，就是基于上下文对 AST 节点的属性进行解析和标注。*

计算机语言的语义分析并不复杂，因为计算机语言的语义一般可以表达为一些规则，你只要检查是否符合这些规则就行了。比如：
* 某个表达式的计算结果是什么数据类型？如果有数据类型不匹配的情况，是否要做自动转换？
* 如果在一个代码块的内部和外部有同名的变量，在执行的时候到底用哪个？
* 在同一作用域内，不允许有两个同名的变量，这是唯一性检查。

语义分析工作的某些成果，会作为属性标注在抽象语法树上，比如在 age 这个标识符节点和 45 这个字面量节点上，都会标识它的数据类型是 int 型的。在这个树上还可以标记很多属性，有些属性是在之前的两个阶段就被标注上了，比如所处的源代码行号、列号。

做了这些属性标注以后，编译器在后面就可以依据这些信息生成目标代码了。


## 词法分析

正则文法和有限自动机：纯手工打造词法分析器

而且词法分析的工作是一边读取一边识别字符串的，不是把字符串都读到内存再识别。

Deterministic Finite Automata (DFA)

<img src="images/FSA.jpg" width="571">

### 正则表达式

正则表达式工具其实就可以看做一个通用的词法分析器。


## 语法分析

本节课将继续“手工打造”之旅，让你纯手工实现一个公式计算器，借此掌握语法分析的原理和递归下降算法（Recursive Descent Parsing），并初步了解上下文无关文法（Context-free Grammar，CFG）。

语法分析的结果是生成 AST。算法分为自顶向下和自底向上算法，其中，递归下降算法是一种常见的自顶向下算法。

### 上下文无关文法

这种文法已经没有办法改写成正则文法了，它比正则文法的表达能力更强，叫做“上下文无关文法”。正则文法是上下文无关文法的一个子集。它们的区别呢，就是上下文无关文法允许递归调用，而正则文法不允许。

那有没有上下文相关的情况需要处理呢？也是有的，但那不是语法分析阶段负责的，而是放在语义分析阶段来处理的。











