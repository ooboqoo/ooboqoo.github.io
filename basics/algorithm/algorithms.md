# 算法


## 递归

从我自己学习数据结构和算法的经历来看，我个人觉得，有两个最难理解的知识点，一个是动态规划，另一个就是递归。递归是一种应用非常广泛的算法(或叫编程技巧)。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。

### 递归需要满足的三个条件

究竟什么样的问题可以用递归来解决呢？只要同时满足以下三个条件，就可以用递归来解决。

1. 一个问题的解可以分解为几个子问题的解。子问题就是数据规模更小的问题。
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件。

### 编写递归代码

写递归代码最关键的是 *写出递推公式，找到终止条件*，剩下将递推公式转化为代码就很简单了。

假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以... 总之走法有很多，那如何用编程求得总共有多少种走法呢？

```c
// 递推公式   f(n) = f(n-1) + f(n-2)
// 终止条件1  f(1) = 1
// 终止条件2  f(2) = 2
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

我总结一下，*写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码*。虽然我讲了这么多方法，但是作为初学者的你，现在是不是还是有种想不太清楚的感觉呢？实际上，我刚学递归的时候，也有这种感觉，这也是文章开头我说递归代码比较难理解的地方。

走台阶这个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。但 *计算机擅长做重复的事情，所以递归正合它的胃口*。我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种 *试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区*。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。

那正确的思维方式应该是怎样的呢？如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，*不要试图用人脑去分解递归的每个步骤*。

### 警惕堆栈溢出与重复计算

递归代码虽然 *表达力强、简洁高效*，但也有很多弊端。比如，*堆栈溢出、重复计算、函数调用耗时多、空间复杂度高*等，所以，在编写递归代码的时候，一定要控制好这些副作用。

为避免堆栈溢出，如果最大深度比较小，如 10、50，可以在代码中限制递归调用的最大深度，如果调用超过一定深度，就直接报错。不方便跟踪深度时我们可以添加捕获系统异常的代码，或者改写为非递归的方式。

```c
// 简单演示如何跟踪调用深度
int depth = 0;
int f(int n) {
  if (++depth > 1000) exit(1);
  // ...
}
```

为了避免重复计算，我们可以通过一个数据结构(如散列表)来保存已经求解过的结果，计算时先检查散列表就可以避免重复计算了。

除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。

### 将递归代码改为迭代循环

在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。*所有的递归代码都可以改为迭代循环的非递归写法*。因为递归本身就是借助栈来实现的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归的样子。但是这种思路实际上是将递归改为了“手动”递归，本质并没有变。

```c
// 利用递归计算斐波那契数 (自上而下的思考方式)
int fib(int n) {
  if (n < 2) return n;
  return fib(n - 1) + fib(n - 2);
}

// 利用迭代计算斐波那契数 (自下而上的思考方式)
int fib(int n) {
  if (n < 2) return n;
  int ret, a = 0, b = 1;
  while (--n) {
    ret = a + b;
    a = b;
    b = ret;
  }
  return ret;
}
```


## 排序


## 二分查找






