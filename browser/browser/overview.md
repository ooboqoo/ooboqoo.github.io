# 宏观视角下的浏览器

## Chrome 架构

仅仅打开了1个页面，为什么会有4个进程？

### 进程和线程

多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。一个进程就是一个程序的运行实例。进程和线程之间的关系有以下 4 个特点。
1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。进程隔离是为保护系统中进程互不干扰的技术。进程之间进行数据通信要使用 IPC 机制。

把计算机看作一家公司。进程是独立的部门，每个部门有自己的资源。线程是部门里的员工，是最小的干活单位，共享部门资源。

### 单进程浏览器时代

顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。2007年之前市面上的浏览器都是单进程的。如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。
1. 不稳定
  * 早期浏览器需要借助 *插件* 来实现一些功能增强，但插件是最容易出问题的模块，一个插件的意外崩溃会导致整个浏览器崩溃
  * *渲染引擎模块* 也是不稳定的，通常一些复杂的 JS 代码就可能引起渲染引擎模块的崩溃，进而导致浏览器崩溃
2. 不流畅
  * 所有页面的渲染模块、JS执行环境以及插件都是运行在统一线程中的，这就意味着同一时刻只能有一个模块可以执行
  * 除了脚本或者插件会让单进程浏览器变卡顿外，*页面的内存泄露*也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。
3. 不安全
  * 插件可以使用 C/C++ 等代码编写，插件可以获取到操作系统的任意资源，当你在页面中运行插件时你的电脑信息将完全暴露
  * 页面脚本可以通过浏览器的漏洞来获取系统权限，获取系统权限之后也可以对你的电脑做一些恶意的事情

### 多进程浏览器时代

2008年 Chrome 刚发布时的进程架构，每个页面都运行在单独的渲染进程中，同时页面里的插件也运行在单独的插件进程中，而进程之间通过 IPC 机制进行通信。

<img src="images/browser-overview/browser-single-process.png" width="571">

1. 解决不稳定：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程
2. 解决不流程：即使 JS 阻塞了渲染进程，影响到的也只是当前页面；至于内存泄露问题就更简单了，当一个页面关闭时，整个渲染进程也会被关闭，其所占资源都会被系统回收
3. 解决不安全：采用多进程架构的额外好处是可以使用 *安全沙箱*，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置(如我的文档、桌面等)读取任何数据。恶意程序也无法突破沙箱去获取系统权限。

### 目前多进程架构

Chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。

<img src="images/browser-overview/chrome-multi-process.png" width="571">

最新的 Chrome 浏览器包括：1个浏览器主进程、1个 GPU 进程、1个网络进程、多个渲染进程和多个插件进程。

* 浏览器进程，主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* 渲染进程，核心任务是将 HTML、CSS 和 JS 转换为用户可以与之交互的网页，排版引擎 Blink 和 JS 引擎 V8 都运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑(代码来源于网络，可能包含攻击本机的恶意代码)，渲染进程都运行在沙箱模式下。
* GPU 进程，Chrome 刚开始发布的时候并没有 GPU 进程。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、浏览器界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求，于是有了独立的 GPU 进程。
* 网络进程，主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来。
* 插件进程，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

* 更高的资源占用，因为每个进程都会包含公共基础结构的副本(如 JS 运行环境)，这就意味着浏览器会消耗更多的内存资源。
* 更复杂的体系架构，浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。

### 未来面向服务的架构

<img src="images/browser-overview/chrome-soa-1.png" width="571">
<img src="images/browser-overview/chrome-soa-2.png" width="571">

为了解决多进程架构带来的问题，2016年 Chrome 团队使用 面向服务的架构(Services Oriented Architecture, SOA) 的思想设计了新的架构。原来的各种模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 来通信，从而 *构建一个更内聚、松耦合、易于维护和扩展的系统*，更好实现 Chrome 简单、稳定、高速、安全的目标。目前 Chrome 正处在老的架构向服务化架构过渡的阶段，这将是一个漫长的迭代过程。

同时 Chrome 还提供了灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，在资源受限的设备上会将很多服务整合到一个进程中从而节省内存占用。

### 总结

本文我主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。

最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务的架构形式，这也是 Chrome 团队现阶段的一个主要任务。

鉴于目前架构的复杂性，要完整过渡到面向服务的架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。

总体说来，Chrome 是以一个非常快的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利。


## HTTP vs TCP/IP

### TCP 协议

在衡量 Web 页面性能的时候有一个重要的指标叫 FP(First Paint)，是指从页面加载到首次开始绘制的时长，这个指标直接影响了用户的跳出率。那什么影响 FP 指标呢？其中一个重要的因素是 *网络加载速度*。

互联网，实际上是一套理念和协议组成的体系架构。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。

#### IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合 **网际协议(Internet Protocol，IP)标准**。互联网上不同的在线设备都有唯一的地址，地址只是一串数字。这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，物流系统会把物品送达目的地。计算机的地址就称为 **IP 地址**，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 **IP 头** 的数据结构里。IP 头是 IP 数据包开头的信息，*包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息*。

#### UDP：把数据包送达应用程序

<img src="images/browser-overview/udp.png" width="571">

IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是 **用户数据包协议(User Datagram Protocol，UDP)**。

UDP 中一个最重要的信息是 **端口号**，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 *IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序*。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。虽说 *UDP 不能保证数据可靠性，但是传输速度却非常快*，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

#### TCP：把数据完整地送达应用程序

<img src="images/browser-overview/tcp.png" width="571">

对于浏览器请求，或者邮件这类要求数据传输可靠性(reliability)的应用，如果使用 UDP 来传输会存在两个问题：
* 数据包在传输过程中容易丢失；
* 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包来还原成完整的文件。

基于这两个问题，引入 **传输控制协议(Transmission Control Protocol，TCP)**，*TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议*。相对于 UDP，TCP 有下面两个特点:
* 对于数据包丢失的情况，TCP 提供重传机制；
* TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

一个完整的 TCP 连接的生命周期包括了 建立连接、传输数据、断开连接 三个阶段。*TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度*，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

### HTTP 请求流程

![](images/browser-overview/http.png)

HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。

#### 浏览器端发起 HTTP 请求流程

1. 构建请求。浏览器构建 **请求行** 信息(如 `GET /index.html HTTP1.1`)，准备发起网络请求。
2. 查找缓存。在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。如果存有副本，就拦截请求。
3. 准备 IP 地址和端口。浏览器使用 *HTTP协议作为应用层协议*，用来封装请求的文本信息；并使用 *TCP/IP作为传输层协议*将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。由于 IP 地址是数字标识难以记忆，但使用域名就好记多了，所以基于这个需求又出现了一个服务 **域名系统(Domain Name System，DNS)**，负责把域名和 IP 地址做一一映射关系。这样一路推导下来，你会发现 *在第一步浏览器会请求 DNS 返回域名对应的 IP*。当然浏览器还提供了 **DNS 数据缓存服务**，如果某个域名已经解析过了，浏览器会缓存解析的结果，以供下次查询时直接使用。
4. 等待 TCP 队列。Chrome 下同一个域名同时最多只能建立 6 个 TCP 连接，其余请求会进入排队等待状态。
5. 建立 TCP 连接。在 HTTP 开始工作之前，浏览器通过 TCP 与服务器建立连接。
6. 发送 HTTP 请求。TCP 连接一旦建立，浏览器就可以和服务器进行通信了，HTTP 中的数据正是在这个通信过程中传输的。
  * 首先浏览器会向服务器发送**请求行**，它包括了请求方法、请求 URI(Uniform Resource Identifier)和 HTTP 版本协议。
  * 之后，还要以**请求头**的形式发送一些其他信息，比如 UA、当前请求的域名、Cookie 等等。
  * 最后发送**请求体**(如果有的话)。

#### 服务器端处理 HTTP 请求流程

```text
curl -v http://ngapps.cn

* Rebuilt URL to: http://ngapps.cn/
*   Trying 47.102.130.191...
* TCP_NODELAY set
* Connected to ngapps.cn (47.102.130.191) port 80 (#0)
> GET / HTTP/1.1
> Host: ngapps.cn
> User-Agent: curl/7.58.0
> Accept: */*
>
< HTTP/1.1 301 Moved Permanently
< Server: nginx/1.14.0 (Ubuntu)
< Date: Mon, 14 Oct 2019 10:09:54 GMT
< Content-Type: text/html
< Content-Length: 194
< Connection: keep-alive
< Location: https://ngapps.cn/
<
<html>
<head><title>301 Moved Permanently</title></head>
<body bgcolor="white">
<center><h1>301 Moved Permanently</h1></center>
<hr><center>nginx/1.14.0 (Ubuntu)</center>
</body>
</html>
* Connection #0 to host ngapps.cn left intact
```

#### 补充知识

##### 持久连接

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。如果浏览器或服务器在其头信息中加入了：`Connection: Keep-Alive`，那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。*保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度*。

##### 浏览器缓存

<img src="images/browser-overview/browser-cache.png" width="571">


## 导航流程

![](images/browser-overview/navigation.png)

用户发出 URL 请求到页面开始解析的这个过程，就叫做 **导航**，下面我们来详细分析下这些步骤。

### 1. 用户输入

用户从浏览器进程里输入请求信息
  * 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，合成新的带搜索关键字的 URL
  * 如果符合 URL 规则，地址栏会根据规则，加上协议合成完整的 URL
  * 当用户输入关键字并回车后，标签页上的图标便进入加载状态，但此时页面还停留在原先的页面

### 2. URL 请求

1. URL 请求 - 检查缓存
  * 浏览器进程通过进程间通信把 URL 请求发送给网络进程
  * 网络进程检查本地缓存，如果有就将该资源返回给浏览器进程，如果没有就进入网络请求流程
2. URL 请求 - HTTP 请求
  * 进行 DNS 解析，获取域名对应的服务器 IP 地址
  * 利用 IP 地址和服务器建立 TCP 连接
  * 如果是 HTTPS，还需要建立 TLS 连接
  * 构建 HTTP 请求行、请求头信息，然后发送请求信息
  * 网络进程接收到服务器响应的响应行和响应头信息后，开始解析响应头内容
3. 网络进程解析响应流程
  * 重定向，如果状态码是 301 302 等，则需要重定向，从 `Location` 字段中读取重定向地址，请求新资源
  * 检查响应类型 `Content-Type`，如果是字节流类型(如 `application/octet-stream`)则将该请求提交给下载管理器，导航流程结束，如果是 `text/html` 则通知浏览器进程准备渲染进程进行渲染

### 3. 准备渲染进程

服务器响应 URL 请求之后，浏览器进程开始准备渲染进程。

Chrome 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。*当根域名和协议都相同时即视为同站点*，这跟同源策略是有区别的。

### 4. 提交文档

首先要明确一点，这里的“文档”是指 URL 请求的响应体数据。

1. “提交文档”的消息是由浏览器进程发出的，渲染进程收到消息后，会和网络进程建立传输数据的“管道”
2. 文档数据(就是 html 文件)传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
3. 浏览器进程收到消息后，会 *更新浏览器界面状态*，包括更新安全状态、地址栏 URL、前进后退的历史状态，并刷新页面。这也就解释了为什么在浏览器输入地址后，之前的页面没有立马消失，而是要加载一会儿才更新页面

到这里，一个完整的导航流程就走完了，之后就要进入渲染阶段了。


## 渲染流程

这个阶段很重要，了解其流程能让你看透页面是如何工作的，有了这些知识，你可以解决一系列相关的问题，比如能熟练使用开发者工具，因为能够理解开发者工具里面大部分项目的含义，能优化页面卡顿问题，使用 JavaScript 优化动画流程，通过优化样式表来防止强制同步布局，等等。对于每个阶段，你都应该关注三点：输入内容、处理过程、输出内容，这有助于你更加清晰地理解每个子阶段。

* 渲染进程将 HTML 内容转换为能够读懂的 **DOM 树** 结构。
* 渲染引擎将 CSS 样式表转化为浏览器可以理解的 **styleSheets**，计算出 DOM 节点的样式。
* 创建 **布局树**，并计算元素的布局信息。
* 对布局树进行分层，并生成 **分层树**。
* 为每个图层生成 **绘制列表**，并将其提交到合成线程。
* 合成线程将图层分成 **图块**，并在 **光栅化线程池** 中将图块转换成位图。
* 合成线程发送绘制图块命令 **DrawQuad** 给浏览器进程。
* 浏览器进程根据 DrawQuad 消息 **生成页面**，并 **显示** 到显示器上。

![](images/browser-overview/render-workflow.png)

### 1. 构建 DOM 树

为什么要构建 DOM 树呢？因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

为了更直观的理解 DOM 树，你可以打开开发者工具的控制台并输入 `document` 来查看完整的 DOM 树结构。可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，*DOM 是保存在内存中树状结构，可以通过 JS 来查询或修改其内容*。

我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。

![DOM树构建过程](images/browser-overview/dom-tree.png)

### 2. 样式计算(Recalculate Style)

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

#### 把 CSS 转换为 CSSOM

CSS 样式的来源主要有三种：通过 `<link>` 引入的外部样式文件，`<style>` 标记内的样式，`style` 属性内嵌的样式。

和 HTML 文件一样，浏览器也无法直接理解这些纯文本的 CSS 样式，所以渲染引擎会将 CSS 文本转换为浏览器可以理解的结构—— CSSOM。可以在控制台中输入 `document.styleSheets` 查看具体的结构。

#### 属性值标准化

```css
body { font-size: 2em; }
p    { color: blue; }
span { font-weight: bold; }
/* 属性值标准化后为 */
body { font-size: 32px; }
p    { color: rgb(0, 0, 255); }
span { font-weight: 700; }
```

#### 计算 DOM 节点的具体样式

样式计算阶段的目的是为了计算出 DOM 树中每个节点的具体样式，*计算需要遵守继承规则和层叠规则*。
* 继承就是每个 DOM 节点都包含有父节点的样式。
* 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法，在 CSS 中处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。关于层叠的具体规则请自行搜索学习。

这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

你可以打开开发者工具中的 “Elements” 标签，再选择 “Styles” 和 "Computed" 子标签，查看继承关系和最终的计算样式。

### 3. 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要 *计算出 DOM 树中可见元素的几何位置*，我们把这个计算过程叫做布局。

#### 创建布局树

你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素的布局树。此步会遍历 DOM 树中的所有可见节点，并把这些节点加到布局中，而不可见的节点会被布局树忽略掉。

![](images/browser-overview/layout-tree.png)

#### 计算布局

现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂，我们这里先跳过不讲，等到后面章节中我再做详细的介绍。

在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

### 4. 分层

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，*渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的__图层树(LayerTree)__*。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。

可以打开开发者工具中的 “Layers” 标签查看页面的分层情况。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

第一点，*拥有层叠上下文属性的元素会被提升为单独的一层*。明确定位属性的元素、定义透明属性的元素、使用滤镜的元素等，都拥有层叠上下文属性。若你想要了解更多层叠上下文的知识，你可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context">参考这篇文章</a>。

第二点，*需要剪裁（clip）的地方也会被创建为图层*。如一个定宽高的 DIV 塞了很多内容，就会出现裁剪，渲染引擎会单独创建图层，如果有出滚动条，那么滚动条也会被提升为单独的层。

### 5. 生成绘制列表

在完成图层树的构建后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎会把一个图层的绘制拆分成很多小的 *绘制指令*，然后再把这些指令按照顺序组成一个待绘制列表，具体可以在 "Layers" 下在可视区选择一个层，并点击下方 "Details" 内的 "Paint Profiler" 链接查看。

<img src="images/browser-overview/layer-profiler.png" width="571">

### 6. 合成线程绘图

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表 *提交(commit)* 给合成线程进行实际绘图。

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做 **视口(viewport)**。

有的图层可能很大，但用户只能通过视口看到页面的很小一部分，所以在这种情况下，要绘制出整个图层内容的话开销太大，而且也没必要。基于这个原因，合成线程会将图层划分为 **图块(tile)**，这些图块的大小通常是 256x256 或者 512x512。

<img src="images/browser-overview/tiles.png" width="571">

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓 **栅格化**，*指将图块转换为位图*。*图块是栅格化执行的最小单位*。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫 **快速栅格化**，或叫 **GPU 栅格化**，生成的位图保存在 GPU 内存中。GPU 操作运行在 GPU 进程中，如果栅格化操作使用了 GPU 来完成，那么就涉及到了跨进程操作。

<img src="images/browser-overview/raster.png" width="571">

一旦所有图块都被栅格化，合成线程就会提交一个“DrawQuad”绘图命令给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收 DrawQuad 命令，并根据命令将页面内容绘制到内存中，最后再将内存显示在屏幕上。

