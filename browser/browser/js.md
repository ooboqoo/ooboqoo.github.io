# 浏览器的 JavaScript 执行机制

## 执行上下文

只有理解了 JavaScrip 的执行上下文，你才能更好地理解 JavaScript 语言本身，比如变量提升、作用域和闭包等。不仅如此，理解执行上下文和调用栈的概念还能助你成为一名更合格的前端开发者。

```js
showName()
console.log(myName)
var myName = 0
var myName = 'Gavin'
console.log(myAge)
function showName () {
  console.log('showName 被执行')
}

// 输出内容：
// showName 被执行
// undefined
// ReferenceError: myAge is not defined    // 不管是否严格模式都报错
```

从上面的试验可以得出一下结论：
* 若执行过程中使用了未声明的变量，那么 JS 执行报错
* 在一个变量定义之前使用它，不会报错，但变量的值为 undefined 而不是定义时的值
* 在一个函数定义之前使用它，不会出错，且函数能正确执行
* 重复声明相同变量不会报错，重复声明函数以最后声明的为准

### 变量提升

代码执行过程中，JS 引擎会把 *变量的声明部分和函数声明* 提升到代码开头。变量被提升后，会给变量设置默认值 `undefined`。

```js
// JS 中的声明与赋值
var myName = 'Gavin'  // 这段代码可以看成是下面两行代码组成的
var myName            // 声明部分
myName = 'Gavin'      // 赋值部分

// 这是一个完整的函数声明，不包含赋值部分
function foo () {
  console.log('foo')
}
// 这里则包含了声明和赋值两部分
var bar = function () {
  console.log('bar')
}
```

### 代码的执行流程

从字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移到代码的最前面，但这并不准确。*实际上变量和函数声明在代码里的位置是不会变的，而是在编译阶段被 JS 引擎放到了内存中*。一段 JS 代码在执行前需要先编译，然后才会进入执行阶段。

![](images/browser/js.png)

从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：**执行上下文(Execution context)** 和 **可执行代码**。*执行上下文是 JavaScript 执行一段代码时的运行环境*，比如调用一个函数，就会进入这个函数的执行上下文，以确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

#### 编译阶段

碰到 `var` 声明的变量，JS 引擎将在环境对象中创建一个属性，并使用 `undefined` 对其进行初始化。  
碰到 `function` 声明的函数，会将函数定义存储到 堆(HEAP) 中，然后在环境对象中创建一个属性，该属性值指向堆中函数的位置。  
生成 **变量环境对象** 后，JS 引擎会把声明以外的代码编译为 *字节码*。

#### 执行阶段

编译完成就有了执行上下文和可执行代码了，那么接下来就到了执行阶段了。JS 引擎会按照顺序一行一行地执行代码。在代码行过程中，JS 引擎会从变量环境中去查找自定义的变量和函数。


## 调用栈

哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：
* 执行全局代码时，会编译全局代码并创建全局执行上下文，整个页面的生存周期内，全局执行上下文只有一份。
* 调用函数时，函数体内的代码会被编译，并创建函数执行上下文，通常，函数执行结束后，创建的函数执行上下文即被销毁。
* 当使用 `eval` 函数的时候，eval 的代码也会被编译，并创建执行上下文。

理解了执行上下文，我们继续深入，一起聊聊调用栈。学习调用栈可以帮你理解 JS 引擎背后的工作原理，提高代码调试能力。

### 函数调用 & 调用栈

在执行上下文创建好后，JS 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为 **执行上下文栈**，又称 **调用栈**。

*调用栈就是用来管理函数调用关系的一种数据结构*。栈遵循先进先出的原则，有入栈、出栈等操作，还有空栈、栈满、栈溢出等状态。

调用栈是 JS 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

* 每调用一个函数，JS 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JS 引擎开始执行函数代码。
* 如果在一个函数 A 中调用了另外一个函数 B，那么 JS 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
* 当前函数执行完毕后，JS 引擎会将该函数的执行上下文弹出栈。
* 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

```js
// 以下代码执行过程中的调用栈变化如下图所示
var a = 2
function add (b, c) { return b + c }
function addAll (b, c) { var d = 10; var result = add(b, c) + d; return result }
addAll(3, 6)
```

![](images/browser/call-stack.png)

### 开发中利用好调用栈

#### 调试

如何利用浏览器查看调用栈的信息
* 通过打断点，在开发者工具中查看 Call Stack 信息(细节略)。在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。
* 在代码中使用 `console.trace()` 来输出当前的函数调用关系。

#### 栈溢出

请注意，调用栈有两个指标，**最大栈容量** 和 **最大调用深度**，满足其中任意一个就会 **栈溢出(Stack Overflow)**。当入栈的执行上下文超过一定数目，JS 引擎就会报错。特别是在你写递归代码的时候，就很容易出现栈溢出的情况。

理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。

```js
(function foo (n) { return foo(n + 1) })(1)  // 栈溢出示例
```


## 块级作用域

### 作用域

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：
* **全局作用域** 中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
* **函数作用域** 是在函数内部定义的变量或函数，定义的变量只能在函数内部访问，函数执行结束后函数内部定义的变量会被销毁。

在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持 **块级作用域**。*块级作用域就是使用一对大括号包裹的一段代码*，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

### 变量提升所带来的问题

*1. 变量容易在不被察觉的情况下被覆盖掉*

以下代码第一直觉应该输出内容，但通过 *分析调用栈* 就很容易发现原因，但对于一些其他语言转过来的开发者就很容易造成误解。

```js
var myname = "极客时间"
function showName () {
  console.log(myname)
  if (0) {
    var myname = "极客邦"
  }
  console.log(myname)
}
showName()
// undefined
// undefined
```

*2. 本应销毁的变量没有被销毁*

如果你使用 C 语言或者其他的大部分语言实现类似代码，在 for 循环结束之后，i 就已经被销毁了，但是在 JavaScript 代码中，i 的值并未被销毁，所以最后打印出来的是 7。

```js
;(function foo() {
  for (var i = 0; i < 7; i++) { }
  console.log(i)
})()
// 7
```

### ES6 如何解决变量提升的缺陷

由于 JS 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字 `let` `const` 来解决这些问题。

```js
// let 声明的变量存在暂时性死区
let myname= '极客时间'
{
  console.log(myname) 
  let myname= '极客邦'
}
// VM6277:3 Uncaught ReferenceError: Cannot access 'myname' before initialization
```

> 对于不同关键字声明的效果，可用下面这不是很精确的说法(同学分享)记忆
> * `var` 的创建和初始化被提升，赋值不会被提升。
> * `let` 的创建被提升，初始化和赋值不会被提升。
> * `function` 的创建、初始化和赋值均会被提升。

### ES6 如何支持块级作用域

我们将通过对 **变量环境** 和 **词法环境(Lexical Environment)** 的介绍，分析 JS 引擎是如何同时支持变量提升和块级作用域的。

我们知道执行代码前，JS 引擎会先对其进行编译并创建执行上下文。引入 `let` 关键字后，`let` 关键字会创建块级作用域，那么 `let` 关键字是如何影响执行上下文的呢？

函数内部通过 `var` 声明的变量，在编译阶段全都被存放到变量环境里面。通过 `let` 声明的变量，则会被存放到词法环境中。

当进入函数的作用域块时，作用域块中通过 `let` 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 `let` 或者 `const` 声明的变量。

再接下来，当执行到作用域块中的 console.log(a) 这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：*沿着词法环境的栈顶向下查找，如果在某个块中找到了，就直接返回，如果没找到，那么继续在变量环境中查找*。从下面的示意图，结合开发者工具，我们可以发现 *调用栈(Call Stack) 和 作用域链(Scope) 是两个不同的概念*。

<img src="images/browser/variable-scope.png" width="571">

通过上面的分析，想必你已经理解了词法环境的结构和工作机制，*块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现*，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。


## 作用域链和闭包

### 作用域链

<img src="images/browser/scope-chain.png" width="571">

### 词法作用域

**词法作用域**就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。
*词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系*。

<img src="images/browser/lexical-scope.png" width="571">

### 闭包

<img src="images/browser/closure-1.png" width="230">
<img src="images/browser/closure-2.png" width="230">
<img src="images/browser/closure-3.png" width="230">
<img src="images/browser/closure-4.png" width="230">

从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了(这部分内容在 V8 GC 中讲)，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName 方法背的一个 *专属背包*，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。

### 闭包的回收

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。


## this

1. 当函数作为对象的方法调用时，函数中的 this 就是该对象；
2. 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
3. 嵌套函数中的 this 不会继承外层函数的 this 值。

执行这段代码，你会发现它也输出了我们想要的结果，也就是箭头函数 bar 里面的 this 是指向 myObj 对象的。这是因为 ES6 中的 *箭头函数并不会创建其自身的执行上下文*，所以箭头函数中的 this 取决于它的外部函数。

