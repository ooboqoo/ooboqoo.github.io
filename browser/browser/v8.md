# V8 工作原理

https://www.dynatrace.com/news/blog/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/

JavaScript 的内存机制
* JS 中的数据是如何存储在内存中的（栈空间和堆空间）
* 垃圾数据是如何自动回收的（垃圾回收）
* V8 是如何执行一段 JS 代码的（编译器和解释器）


## 数据如何存储

### JS 是弱类型的动态语言

在使用之前就要确认其变量数据类型的为 **静态语言**，在运行过程中检查数据类型的语言为 **动态语言**。

下面代码中的 `b = a;`，C 编译器会把 int
型的变量悄悄转换为 bool 型的变量，我们把这种偷偷转换的操作称为 **隐式类型转换**。支持隐式类型转换的语言为 **弱类型语言**，不支持隐式类型转换的语言称为 **强类型语言**。

|    | 强类型       | 弱类型 
-----|-------------|-----------------------
静态 | Java、C#     | C、C++
动态 | Python、Ruby | JavaScript、PHP、Perl

```c
// C 是「静态语言」+「弱类型」
int main() {
  int a = 1;
  bool b = true;
  char* c = "字符串";

  b = a;  // 因为存在隐式类型转换，这句可以正常执行
}
```

### JS 存储空间的种类

在 JS 的执行过程中，主要有三种类型的内存空间：**代码空间**、**栈空间** 和 **堆空间**。

代码空间主要用于存储可执行代码。栈空间就是我们之前反复提及的 **调用栈**，是 *用来存储执行上下文* 的。

当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。

```js
function foo(){
    var a = "极客时间"
    var b = a
    var c = {name:"极客时间"}  // 下图展示了执行完此行时的内存状态
    var d = c
}
foo()
```
JavaScript 引擎判断右边的值是一个引用类型，引擎并不直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值。

*原始类型的数据值都是直接保存在「栈」中的，引用类型的值是存放在「堆」中的*。

<img src="images/browser/js-memory.png" width="761">

你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，*如果栈空间大了话*，所有的数据都存放在栈空间里面，那么 *会影响到上下文切换的效率*，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：

<img src="images/browser/js-memory-call-stack.webp" width="761">

所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

在 JavaScript 中，赋值操作和其他语言有很大的不同，*原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址*。

### 再谈闭包

产生闭包的核心有两步
* 第一步是需要预扫描内部函数
* 第二步是 *把内部函数引用的外部变量保存到堆中*

```js
function foo() {
  var myName = "极客时间"
  let test1 = 1
  const test2 = 2
  var innerBar = { 
    setName(newName) {
      myName = newName
    },
    getName() {
      console.log(test1)
      return myName
    }
  }
  return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

1. 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。
2. 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“Closure (foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。
3. 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到 “Closure (foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。
4. 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

<img src="images/browser/js-memory-closure.webp" width="571">

## 垃圾回收

通常情况下，垃圾数据回收分为**手动回收**和**自动回收**两种策略。

### 代际假说和分代收集

**代际假说**有以下两个特点：

  * 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
  * 第二个是不死的对象，会活得更久。

所以，在 V8 中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

  * **副垃圾回收器，主要负责新生代的垃圾回收。**
  * **主垃圾回收器，主要负责老生代的垃圾回收。**

<img src="images/browser/v8-heap.png" width="571">

今日总结
垃圾回收策略一般分为手动回收和自动回收，java python JavaScript等高级预言为了减轻程序员负担和出错概率采用了自动回收策略。JavaScript的原始类型数据和引用数据是分别存储在栈和椎中的，由于栈和堆分配空间大小差异，垃圾回收方式也不一样。栈中分配空间通过ESP的向下移动销毁保存在栈中数据；堆中垃圾回收主要通过副垃圾回收器（新生代）和主垃圾回收器（老生代）负责的，副垃圾回收器采用scavenge算法将区域分为对象区域和空闲区域，通过两个区域的反转让新生代区域无限使用下去。主垃圾回收器采用Mark-Sweep（Mark-Compact Incremental Marking解决不同场景下问题的算法改进）算法进行空间回收的。无论是主副垃圾回收器的策略都是标记-清除-整理三个大的步骤。另外还有新生代的晋升策略（两次未清除的），大对象直接分配在老生代。
作者回复: 总结很好，还可以通过Chrome开发者工具中的Performance来观察。

作者回复: 标记清除和标记整理可以看成是垃圾回收的两个阶段吧，v8在实现垃圾回收过程中，两种算法都用上了。


## 编译器和解释器

要深入理解 V8 的工作原理，你需要搞清楚一些概念和原理，比如接下来我们要详细讲解的**编译器（Compiler）、解释器（Interpreter）、抽象语
法树（AST）、字节码（Bytecode）、即时编译器（JIT）**等概念，都是你需要重点关注的。

<img src="images//browser/compiler-interpreter.png" width="571">

V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan
是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan
转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。

对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla
的 SpiderMonkey 也都使用了该技术。


