# 页面循环系统


## 消息队列和事件循环

基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制。

1.【第一版线程模型】如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务。  
2.【第二版线程模型】要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统。  
3.【第三版线程模型】如果要接收其他线程发送过来的任务，就需要引入消息队列。  
4.【跨进程任务】其他进程想要发送任务给渲染进程主线程，先通过 IPC 把任务发送给 IO 线程，IO 线程再把任务发送给主线程。  
5.【效率与实时性】消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。

具体到浏览器的实现，是这样的

1. 添加一个消息队列
2. IO 线程中产生的新任务添加进消息队列尾部
3. 渲染主线程会循环地从消息队列头部中读取任务，执行任务
4. IO 线程同时负责处理其他进程发过来的消息，组装成任务发送给渲染进程

<img src="images/browser/event-loop.webp" width="571">

你可以参考下 [Chromium 源码](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/public/platform/task_type.h)，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。

### 单线程的缺点及规避方法

页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。

第一个问题是如何处理高优先级的任务。

该如何 *权衡效率和实时性* 呢？针对这种情况，**微任务** 就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。通常我们把消息队列中的任务称为宏任务，*每个宏任务中都包含了一个微任务队列*，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

第二个是如何解决单个任务执行时长过久的问题。

JavaScript 可以通过 **回调** 功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。


## 定时器 setTimeout 的具体实现

通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。为了支持定时器的实现，浏览器在正常使用的消息队列之外，增加了 **延时队列**。这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。

浏览器内部实现 *取消定时器* 的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。

*如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒*，目的是为了优化后台页面的加载损耗以及降低耗电量。


## XMLHttpRequest 的具体实现

<img src="images/browser/xhr.webp" width="571">

想知道 延时任务是不是一种微任务啊
作者回复: 不是，宏任务，定时器产生的任务都会保存到延时队列中


## 宏任务与微任务

宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个 *微任务队列*。在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。也就是说 *每个宏任务都关联了一个微任务队列*。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。

### MutationObserver

2000 年的时候引入了 Mutation Event，其采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于 *同步回调*。Mutation Event 解决了实时性的问题，但也正是这种实时性造成了严重的性能问题。

MutationObserver 将响应函数改成 *异步回调*，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。

 MutationObserver 采用了「异步 + 微任务」的策略。通过异步操作解决了同步操作的性能问题；通过微任务解决了实时性的问题。


## Promise

要谈动机，我们一般都是先从问题切入，那么 Promise 到底解决了什么问题呢？在正式开始介绍之前，我想有必要明确下，*Promise 解决的是异步编码风格的问题*，而不是一些其他的问题，所以接下来我们聊的话题都是围绕编码风格展开的。

1. Promise 中为什么要引入微任务？
2. Promise 中是如何实现回调函数返回值穿透的？
3. Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => console.log(6));
  console.log(1);
  resolve();
  console.log(2);
})

promise.then(() => {
  console.log(3);
  throw new Error('error');
}).catch(err => {
  console.log(typeof err);
}).finally(() => {
  console.log(5);
})

console.log(4);

// 结果：1 2 4 3 object 5 undefined 6
// 关键点：resolve 了之后并不会立即执行 then，会放到微任务里执行
// 这里的 undefined 也算是个小知识点，没有返回值就会打印 undefined
```


## async/await

本文我们首先介绍生成器（Generator）是如何工作的，接着讲解 Generator 的底层实现机制——协程（Coroutine）；又因为 async/await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async/await 到底是如何以同步的方式来编写异步代码的。

正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

![协程执行流程图]()

* 首先执行的是`let gen = foo()`，创建了 gen 协程。
* 然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。
* gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。
* 父协程恢复执行后，调用 response1.then 方法等待请求结果。
* 等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。

以上就是协程和 Promise
相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为**执行器**（可参考著名的 co
框架），如下面这种方式：

虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在 ES7 中引入了
async/await，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实 async/await 技术背后的秘密就是 Promise
和生成器应用，*往低层说就是微任务和协程应用*。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。

















