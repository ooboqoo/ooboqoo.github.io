# ANSI C

<script>ooboqoo.contentsRegExp = /H[123]/;</script>

## 起步

### 简介

汇编语言依赖于计算机的内部机器语言，针对特定计算机处理器开发的程序无法移植到另一种计算机上。Ritchie 希望有一种语言能将低级语言的效率、硬件访问能力和高级语言的通用性、可移植性融合在一起，于是开发了 C 语言。C 语言通过 **编译器** 将高级语言翻译成特定计算机的内部语言。

### 编译链接

`cc` 原是 标准 UNIX C 编译器，在 Linux 下指向 `gcc`，在 macOS 下指向 `clang`，他们都支持对 `.c` 文件进行编译。

```bash
$ cc hello.c world.c  # 生成一个名为 a.out 的可执行文件和两个目标代码文件 hello.o 和 world.o
$ cc hello.c world.o  # 如果只更改了 hello.cpp，就不需要再编译 world.c 可以直接用 world.o
```

从源代码到可执行文件，大概要经历这么几个过程
* 用编辑器 *编写* 程序并保存到文件中，这个就是程序的 **源代码**
* *编译* 源代码，将源代码翻译为主机使用的内部语言——机器语言，称为 **目标代码 object code**
* 将目标代码与其他代码(启动代码、库代码等) *链接* 起来生成 **可执行代码**

常见编译器介绍
* `cc` UNIX C Cimpiler
* `CC` UNIX C++ compiler
* `gcc` GNU C Compiler from the GCC (GNU Compiler Collection)
* `g++` GNU C++ Compiler from the GCC
* `clang` C, C++, and Objective-C Compiler

```bash
# Pretty printing from the AST
$ clang -cc1 ~/t.c -ast-print

# C++
$ clang++ -Wall -std=c++11 test.cc -o test
```

IDE 中相关菜单项介绍
* Compile 编译 -- 对当前打开的文件进行编译
* Build 建立 / Make 生成 -- (递增)编译项目中的所有源代码文件，未作更改的不会重新编译
* Build All 全部建立 -- 重新编译所有的源代码文件
* Link 链接 -- 将编译后的源代码与所需的库代码组合到一起
* Execute 执行 / Run 运行 -- 运行程序
* Debug 调试 -- 以步进方式执行程序


### Hello world

```c
#include <stdio.h>

int main()
{
  printf("Hello World");
  return 0;
}
```





## Data Type

character
integer
floating-point numbers of several sizes

pointer
array
structure
union


## Scope

Variables may be internal to a function, external but known only within a single source file, or visible to the entire program.



#### 程序结构

简单来说，一个C程序就是由若干头文件和函数组成。

`#include <stdio.h>` 是一条预处理命令，即通知C语言编译系统在正式编译之前需做一些预处理工作。

函数就是实现代码逻辑的一个小的单元。

C程序就是执行主函数 main 里的代码，也可以说这个主函数就是C语言中的唯一入口。在最新的C标准中，main 函数前的类型为 int 而不是 void。

#### 注释

```c
/* 多行注释 */
// 单行注释
```

#### 标识符

标识符可以是字母 `A-Za-z`、数字 `0-9`、下划线 `_` 组成的字符串，并且第一个字符不能是数字。

在使用标识符时还要注意以下几点：
  * 标识符的长度最好不要超过8位，因为在某些版本中规定标识符前8位有效，当两个标识符前8位相同时会认为是同一个标识符。
  * 标识符是严格区分大小写的。
  * 标识符不能是C语言的关键字。

#### 变量及赋值

```c
int a, b;
a = 1;
b = 2;
int num = 10;
printf("%d\n", a + b + num);
```


## 数据类型

#### 数据类型

C语言中，数据类型可分为：基本数据类型，构造数据类型，指针类型，空类型四大类。

整型 `int` 字符型 `char` 单精度浮点型 `float` 双精度浮点型 `double`。

C语言中不存在字符串变量，字符串只能存在字符数组中。

#### 格式化输出语句

格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置进行显示。

```c
// 格式: printf("输出格式符", 输出项);
printf("整数 %d 小数 %f 字符 %c 字符串 %s", 1, 3.45, 'a', "str");
```

#### 常量

在程序执行过程中，值不发生改变的量称为常量。C语言的常量可以分为直接常量和符号常量。

**直接常量** 也称为 **字面量**
* 整型常量 `13` `0` `-13`
* 实型常量 `13.33` `-24.4`
* 字符常量 `'a'` `'M'`
* 字符串常量 `"I love imooc!"`

**符号常量**在使用之前必须先定义，其一般形式为： `#define 标识符 常量值`。符号常量的标示符一般习惯使用大写。

```c
#define PI 3.14;
```

#### 自动类型转换

自动转换发生在不同数据类型运算时，在编译的时候自动完成。

字节小的可以向字节大的自动转换: `char` -> `int` -> `double`

#### 强制类型转换

强制类型转换是通过定义类型转换运算来实现的。其一般形式为：`(数据类型) (表达式)`

在使用强制转换时应注意以下问题：
* 数据类型和表达式都必须加括号，如把 `(int)(x/2+y)` 写成 (int)x/2+y 则成了把 x 转换成 int 之后再除 2 再与 y 相加了。
* 转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。
* 强制转换后的运算结果不遵循四舍五入原则。

```c
printf("2.55取整后为%d\n", (int)2.55);  // 2
```

## 运算符

#### 算术运算符

`+` `-` `*` `/` `%` `++` `--`

```c
printf("%d\n", 5 / 2);    // 2      // 如果相除的两个数都是整数，则结果也为整数，小数部分省略
printf("%d\n", 5.1 % 3);  // error  // 只能对整数进行取余运算
printf("%d\n", -10 % 3);  // -1     // 取余运算后的符号取决于被模数的符号
printf("%d\n", 10 % -3);  // 1
```

#### 赋值运算符

赋值运算符分为 **简单赋值运算符** 和 **复合赋值运算符**。复合赋值运算符由简单赋值符 `=` 加其它运算符构成 `+=` `-=` `*=` `/=` `%=`。

#### 关系运算符

`>` `>=` `<` `<=` `==` `!=`

关系表达式的值是“真”和“假”，C 语言中用整数 `1` 和 `0` 表示。

```c
printf("%d\n", 3 < 4);  // 1
printf("%d\n", 3 == 4); // 0
```

#### 逻辑运算符

`&&` `||` `!`

#### 三目运算符

```c
printf("%s", 4 >= 3 ? "yes" : "no");
```

#### 运算符优先级

||
----|-------------------------------
 1  | `()`
 2  | `!` `+` (正号) `-` (负号) `++` `--`
 3  | `*` `/` `%`
 4  | `+` (加) `-` (减)
 5  | `<` `<=` `>=` `>`
 6  | `==` `!=`
 7  | `&&`
 8  | <code>&#124;&#124;</code>
 9  | `? :`
 10 | `=` `+=` `-=` `*=` `/=` `%=`


## 语句结构

#### 条件

```c
if (表达式1)
{
  代码块1;
}
else if (表达式2) {
  代码块2;
}
else
{
  代码块3;
}
```

```c
switch(表达式)
{
  case 常量表达式1:
    代码块1;
    break;
  case 常量表达式2:
    代码块2;
    break;
  default:
    代码块3;
}
```

在使用switch语句时还应注意以下几点：
  * 在 case 后的各常量表达式的值不能相同，否则会报错
  * 在 case 子句后如果没有 `break;` 会一直往后执行一直到遇到 `break;`
  * switch 后面的表达式语句只能是整型或者字符类型
  * 在 case 后，允许有多个语句，可以不用 `{}` 括起来
  * 各 case 和 default 子句的先后顺序可以变动，而不会影响程序执行结果
  * default 子句可以省略不用

```c
switch (i) {
  default:
    printf("default 位置可以随便放，当然正常应该放最后");
    break;
  case 33:
    printf("OK");
}
```

#### 循环

```c
while(表达式)
{
  代码块;
}

do
{
  代码块;
}
while (表达式);

for (表达式1; 表达式2; 表达式3)
{
  代码块;
}

break;    // 跳出当前整个循环
continue; // 结束本次循环开始下一次循环
```

`for` 结构的相关说明
  * 表达式1 和 表达式3 可以是一个简单表达式也可以是(以逗号分割的多个表达式组成的)复杂表达式
  * 表达式2 一般是关系表达式或逻辑表达式，但也可以是数值表达式或字符表达式，只要其值非零，就执行循环体。
  * 各表达式中的变量一定要在 for 循环之前定义

```c
while (i < 5) printf("%d", i++);

int i;
for (i = 1; i < 10; i++)
{
  printf("%d", i)
}
```

#### goto

goto 语句是一种无条件分支语句，使用格式为 `goto 语句标号;` 其中语句标号是一个标识符，该标识符一般用英文大写并遵守标识符命名规则，这个标识符加上一个 `:` 一起出现在函数内某处，执行 goto 语句后，程序将跳转到该标号处并执行其后的语句。

goto 语句通常不用，主要因为它将使程序层次不清，且不易读，但在特定情况下，可以使用 goto 语句来提高程序的执行速度。

```c
int main()
{
  int sum = 0, i = i;
LOOP:
  if (i <= 10)
  {
    sum += i++;
    goto LOOP;
  }
  printf("sum=%d\n", sum);
  return 0;
}
```


## 函数

```
[数据类型说明] 函数名称 ([参数])
{
  执行代码块;
  return (表达式);
}
```

定义函数注意项
* 数据类型说明可省略，默认是 int 类型函数
* 函数名称遵循标识符命名规范
* 自定义函数尽量放在 main 函数之前，否则需先声明 `[数据类型说明] 函数名称 ([参数])`

```c
#include <stdio.h>

int factorial (int n) {
  int result;
  if (n < 0) {
    return 0;
  } else if (n == 0 || n == 1) {
    result = 1;
  } else {
    result = factorial(n-1) * n;
  }
  return result;
}

int main () {
  int n = 5;
  printf("%d的阶乘=%d", n, factorial(n));
  return 0;
}
```

### 形参与实参

函数的形参 arguments 和实参 parameters 具有以下特点：
* 形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。
* 实参可以是常量、变量、表达式、函数等，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。
* 在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配的错误。

### 返回值

函数的返回值要注意以下几点：
* 函数的值只能通过 return 语句返回主调函数。return 语句的一般形式为： `return 表达式;` 或 `return (表达式);`
* 函数值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则强转为函数返回类型
* 没有返回值的函数，返回类型为 void

### 局部与全局

C语言中的变量，按作用域范围可分为两种，即 **局部变量** 和 **全局变量**。

局部变量也称为内部变量。局部变量是在函数内作定义的，其作用域仅限于函数内。在复合语句中也可定义变量，其作用域仅限于复合语句范围内。

全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。

```c
#include <stdio.h>

int x = 77;

void foo()
{
  printf("foo(): x=%d\n", x); // 77
}

int main()
{
  int x = 10;
  if (x > 0)
  {
    int x = 100;
    x /= 2;
    printf("if语句内, x=%d\n", x); // 50
  }
  printf("main方法内, x=%d\n", x); // 10
  foo();
  return 0;
}
```

### 变量存储类别

C语言根据 *变量的生存周期* 来划分，可以分为静态存储方式和动态存储方式。
* *静态存储*方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。
* *动态存储*方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形参；自动变量；函数调用时的现场保护和返回地址等。

C语言中 *存储类别* 又分为四类：自动 `auto`、静态 `static`、寄存器的 `register` 和外部的 `extern`。

1、用关键字 `auto` 定义的变量为自动变量，auto 可以省略，auto 不写则隐含定为“自动存储类别”，属于动态存储方式。

2、用 `static` 修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。

```c
void func () {
  static int x = 0;
  x++;
  printf("x=%d\n"; x);
}
int main () {
  func();  // x=1
  func();  // x=2
}
```

注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。

3、为了提高效率，C语言允许将局部变量的值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字 `register` 作声明。

```c
void func() {
  register int i;
}
```

注意：只有局部自动变量和形参可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。

4、用 `extern` 声明的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。

```c
// int x;  // 如果存在这行声明，main 内部就可以不用 extern 声明外部变量

int main () {
  extern int x;  // 这里声明使用的是外部全局变量
  printf("extern x=%d\n", x);
}
int x = 100;
```

### 内部函数与外部函数

C语言中不能被其他源文件调用的函数称为 **内部函数**，由 `static` 关键字来定义，因此又被称为 **静态函数**。

能被其他源文件调用的函数称为 **外部函数**，用 `extern` 定义。没有指定作用范围时系统默认为外部函数，因此 `extern` 可省略。

```c
static [数据类型] 函数名([参数])

extern [数据类型] 函数名([参数])
```

_say.c_

```c
#include <stdio.h>
void say() {
  printf("I love you.\n");
}
```

_hello.c_

```c
#include "say.c"
int main () {
  say();
}
```


## 数组

生活中我们经常会用到容器，比如我们去超市购物需要使用购物袋装购买的商品。同样我们在程序中也需要容器，只不过该容器有点特殊，它在程序中是一块连续的、大小固定并且里面的数据类型一致的内存空间，它还有个好听的名字叫数组。可以将数组理解为大小固定，所放物品为同类的一个购物袋，在该购物袋中的物品是按一定顺序放置的。

C语言中的数组初始化有三种形式

```
数据类型 数组名称[长度n] = {元素1,元素2…,元素n};
数据类型 数组名称[]     = {元素1,元素2…,元素n};

数据类型 数组名称[长度n];
数组名称[0] = 元素1;
...;
数组名称[n-1] = 元素n;
```

注意：
  * C语言的数组长度一经声明，长度无法改变，并且C语言并不提供计算数组长度的方法
  * 数组的下标均以 `0` 开始
  * 数组在初始化的时候，数组内元素的个数不能大于声明的数组长度
  * 第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为 `0`
  * 声明数组但未初始化时，静态 static 和外部 extern 类型的元素值 `0`，自动 auto 类型的元素值不确定

### 遍历数组

C语言没有检查数组长度改变或者数组越界的机制，如数组越界，编译运行都不报错，但结果不可控。

```c
int arr[] = {1, 2, 3};
int i;
for (i = 0; i < 4; i++)  // 当 i 为 3 时，运行不会报错，值随机
{
  printf("%d\n", arr[i]);
}
```

### 数组作为函数参数

数组作为函数参数时注意以下事项：
1. 数组名作为函数实参传递时，函数定义中的形参既可以指定长度也可以不指定长度。
2. 数组元素作为函数实参传递时，数组元素类型必须与形参数据类型一致。

```c
void printArr (int arr[3])
{
  int i = 0;
  for (; i < 3; i++)
    printf("%d\n", arr[i]);
}

int arr[] = {0, 1, 2, 3, 4};
printArr(arr);
```

### 字符串与数字

在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。一般有以下两种格式：

```c
char 字符串名称[长度] = "字符串值";
char 字符串名称[长度] = {'字符1', '字符2', ..., '字符n', '\0'};
```

注意:
  * `[]` 中的长度是可以省略不写的
  * 第2种方式最后一个元素必须是 `'\0'` 表示字符串的结束标志
  * 第2种方式不支持中文

在输出字符串的时候要使用：`printf("%s", 字符数组名字);` 或者 `puts(字符数组名字);`。

```c
void say (char string[])
{
  printf("%s\n", string);
}

int main ()
{
  char string[] = "我shi卖报的小行家";
  say(string);
  return 0;
}
```

#### 字符串函数

常用的字符串函数

||||
|----------------|--------------------------|---------------------
| strlen(s)      | 获得字符串的长度(单位字节) | strlen("abc")  // 3
| strcmp(s1, s2) | 比较字符串                | strcmp("ab", "ac")  // -1
| strcpy(s1, s2) | 字符串拷贝                | strcpy(s1, "abc")
| strcat(s1, s2) | 拼接字符串                | strcat(s1, "abc")
| atoi(s1)       | 字符串转整数              | atoi("100")  // 100

使用字符串函数注意以下事项：
  * `strlen()` 获取的长度不包括 `'\0'` 而且汉字和字母的长度是不一样的
  * `strcmp()` 会把字符串先转换成ASCII码再进行比较,返回的结果为 `0` 相等 `1` s1比s2大 `-1` s1比s2小
  * `strcpy()` 拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝
  * `strcat()` 在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串

### 多维数组

多维数组的定义格式

```
数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n];`
```

多维数组的初始化与一维数组的初始化类似也是分两种

```
数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = {{值1,..,值n},...,{值1,..,值n}};

数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n];
数组名称[下标1][下标2]...[下标n] = 值;
```

多维数组初始化要注意：第一种必须指定列的维数；第二种必须同时指定行和列的维数。

```c
int arr1[][2] = {{0, 1}, {2, 3}, {4, 5}};
int r, c;
for (r = 0; r < 3; r++)
{
  for (c = 0; c < 2; c++)
    printf("%d ", arr[r][c]);
  printf("\n");
}
```




