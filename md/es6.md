《ECMAScript 6入门》是一本开源的JavaScript语言教程，全面介绍ECMAScript 6新引入的语法特性。
http://es6.ruanyifeng.com/
- - -

Babel 入门教程 http://www.ruanyifeng.com/blog/2016/01/babel.html


## 2. let 和 const 命令

### 2.1. let命令

#### 基本用法
ES6新增了 `let` 命令，用来声明变量。它的用法类似于 `var`，但是所声明的变量，只在 `let` 命令所在的代码块内有效。

#### 不存在变量提升
let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。

#### 暂时性死区
ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。

“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。

ES6规定暂时性死区和不存在变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。

`let` 及后面的 `const` 不允许在相同作用域内，重复声明同一个变量。

### 2.2. 块级作用域

let实际上为JavaScript新增了块级作用域。块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数不再必要了。

#### 块级作用域与函数声明

```js
function f() { console.log('I am outside!'); }
(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();  // 实际输出 I am inside!
}());
```

ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
在上例中，虽然在浏览器中仍然能够执行（严格模式会报错），但因为没有块级作用域，if 内部的函数声明会提到函数头部，导致结果与预期不符。

ES6 引入块级作用域后就不会存在上例中的隐患，明确允许在块级作用域之中声明函数。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

### 2.3. const命令

`const` 声明一个只读的常量。const 一旦声明变量，就必须立即初始化，不能留到以后赋值 (不然报错)。

`const` 的作用域与 `let` 命令相同：只在声明所在的块级作用域内有效。
`const` 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

ES5 只有两种声明变量的方法：`var` 命令和 `function` 命令。ES6 除了添加 `let` 和 `const` 命令，后面章节还会提到，另外两种声明变量的方法：`import` 命令和 `class` 命令。所以，ES6 一共有6种声明变量的方法。

### 2.4. 全局对象的属性

全局对象是最顶层的对象，在浏览器环境指的是 window 对象，在 Node.js 指的是 global 对象。ES5 之中，全局对象的属性与全局变量是等价的。未声明的全局变量，自动成为全局对象 window 的属性，这被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了两个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道，其次程序员很容易不知不觉地就创建了全局变量（比如打字出错）。

ES6 为了改变这一点，一方面规定，为了保持兼容性，`var` 命令和 `function` 命令声明的全局变量，依旧是全局对象的属性；另一方面规定，`let` 命令、`const` 命令、`class` 命令声明的全局变量，不属于全局对象的属性。也就是说，从 ES6 开始，全局变量将逐步与全局对象的属性脱钩。

## 3. 变量的解构赋值

### 3.1. 数组的解构赋值

ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

以前，为变量赋值，只能直接指定值。
```js
var a = 1, var b = 2, var c = 3;
```

ES6允许写成下面这样。
```js
var [a, b, c] = [1, 2, 3];
```

### 3.2. 对象的解构赋值
### 3.3. 字符串的解构赋值
### 3.4. 数值和布尔值的解构赋值
### 3.5. 函数参数的解构赋值
### 3.6. 圆括号问题
### 3.7. 用途

#### 交换变量的值
```js
[x, y] = [y, x];
```

#### 从函数返回多个值
```js
// 返回一个数组
function example() { return [1, 2, 3]; }
var [a, b, c] = example();

// 返回一个对象
function example() {
  return { foo: 1, bar: 2 };
}
var { foo, bar } = example();
```

#### 函数参数的定义
```js
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

#### 提取JSON数据
```js
var jsonData = { id: 42, status: "OK", data: [867, 5309] };
let { id, status, data: number } = jsonData;
```

#### 函数参数的默认值
#### 遍历 Map 结构
#### 输入模块的指定方法

## 4. 字符串的扩展
### 4.1 字符的Unicode表示法
### 4.2 codePointAt()
### 4.3 String.fromCodePoint()
### 4.4 字符串的遍历器接口
### 4.5 at()
### 4.6 normalize()
### 4.7 includes(), startsWith(), endsWith()
### 4.8 repeat()
### 4.9 padStart()，padEnd()
### 4.10 模板字符串
### 4.11 实例：模板编译
### 4.12 标签模板
### 4.13 String.raw()

## 5. 正则的扩展

## 6. 数值的扩展

## 7. 数组的扩展

## 8. 函数的扩展

## 9. 对象的扩展