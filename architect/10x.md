# 10x 程序员工作法


软件行业里有一本名著叫《人月神话》，其中提到两个非常重要的概念：本质复杂度 Essential Complexity 和 偶然复杂度 Accident Complexity。**大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。**如何减少偶然复杂度引发的问题，让软件开发工作有序、高效地进行，这正是本专栏的目的。我会尝试给你提供一个思考框架，帮你在遇到问题时梳理自己真正要做的事情，贯穿这个框架的，有四个原则：**以终为始 任务分解 沟通反馈 自动化**。


## 1. 思考框架

Where are we? 现状  -->  Where are we going? 目标  -->  How can we get there? 实现路径


## 2. 以终为始

### 2.1 让你的努力不白费 <sub>—— 以终为始，一种结果导向的思考方式</sub>

亚马逊开发一项产品，采用后向工作的方法：1.写新闻搞 -> 2.写 FAQ -> 3.写用户文档 -> 4.写代码

### 2.2 你完成了工作，为什么他们还不满意 <sub>—— 什么叫“完成”</sub>

**在做任何事之前，先定义完成的标准。**

Definition of Done
  * 是行业中的一种最佳实践，能够在团队内部很好地同步大家对完成的理解
  * 是**一份由一个个检查项组成的清单**，用来检查我们的工作完成情况，确保不遗漏任何事情
  * 是一种思维模式，是一种尽可能消除不确定性、达成共识的方式

### 2.3 接到需求任务，你要先做哪些事 <sub>—— 用验收标准看需求是否明确</sub>

**在做任何需求或任务之前，先定好验收标准。**

需求，是软件开发中的一个关键环节，一旦需求理解出现问题，势必会造成大量的浪费。传统的功能列表只是简单罗列了要实现的功能，丢失了大量的上下文，会导致团队成员对于需求"只见树木不见森林"。而在比较大的团队中，更是会将一个功能拆分到多个小团队中，每个人看到的只是功能碎片，于是后来产生了其他的需求描述方式，比如用例和用户故事。

很多人学习用户故事，认为最重要的是记住 "As ..., I want to ..., so that ..." 这样的需求描述方式。而在我看来比描述方式更重要的是验收标准。

> **用户故事**
>
> **标题**，简要地说明用户故事的主要内容，如：注册用户使用用户名密码登录  
> **概述**，简要地介绍用户故事的主要内容，一般会用这样的格式：As a (Role), I want to (Activity), so that (Business Value). 如：作为一个注册用户，我想要通过用户密码登录，以便我可以使用注册用户才能够使用的服务  
> **详述**，详细地描述这个用户故事的完整流程，我们会把操作流程、用户界面等信息放到这里  
> **验收标准**，这个部分会描述一个正常使用的流程是怎样的，以及各种异常流程系统是如何给出响应的，这是程序员常常会欠缺的思考。它会把详述中很多叙述的部分变成一个个具体的测试用例。

验收标准非常重要的一环是**异常流程**的描述。大部分程序员都擅长解决正常流程，而异常流程则是最容易忽略的，也是产生扯皮的关键环节。既然容易扯皮，我们就在一开始把它定义清楚。采用用户故事后，我经常在写完了主要流程后，再去看一下验收标准，为自己的开发查缺补漏。因为我知道，那是标准，达不成就不算任务完成。

当我们说自己开发完成可以交给测试人员测试时，我们需要照着验收标准给测试人员演示一遍，证明我们的系统确实能够跑通。这之后，测试人员才会把系统接手过去，做更系统的测试。

验收标准给出了这个需求最基本的测试用例，它保证了开发人员完成需求最基本的质量。如果你了解 BDD 行为驱动开发，就可以按照验收标准中给出的内容编写验收测试用例了。

在实际工作中，许多产品经理把需求交给开发人员之前，很多细节是没想清楚的，那种功能列表式的需求常常只包含了正常路径，那些缺失的细节都是在后续的过程中，由开发人员补全的。用户故事就是一种固定的格式，让产品把这些应该想清楚的问题想清楚。

或许你会有这样的疑问，如果产品经理通过用户故事的方式，将需求实现细节都描绘得清清楚楚，那我们程序员的发挥空间在哪里？请注意，验收标准所给出的实现细节应该是业务上的，我们的发挥空间应该是在技术实现上。

也许你会说，我在一个小公司工作，公司没有专门的产品经理，需求都是老板扔给我们的，谁来帮我们写验收标准呢？没办法，答案只能是你自己。虽然你名义上是程序员，但当拿到一个需求的时候，你要做的不是立即动手写代码，而是扮演产品经理的角色，分析需求，圈定任务范围。相信我，事前分析绝对比你拿一个写好的系统给老板，而他却告诉你这不是他想要的，好太多了。

### 2.4 集成本身就应该是写代码的一个环节 <sub>—— 持续集成</sub>

程序员的交付物不应该是代码，而是一个可工作的软件。把团队中不同成员的代码放到一起，使之成为一个可工作的软件的过程就是集成。集成经历了从 阶段性集成 到 每日构建 再到 持续集成(每次提交都进行集成) 的过程。持续集成的思维让我们认识到，开发和集成可以合二为一。

### 2.5 产品经理不靠谱，你该怎么办 <sub>—— 用精益创业的视角衡量产品特性的有效性</sub>

注: 这里讲的是在产品设计评审时需要注意的情况。排除垃圾需求避免自己做无用功。

产品经理是一个新兴职业。以前的 IT 行业更多的是面向确定性问题，需要的是业务分析师，只有当面向不确定性工作时，产品经理才成为 IT 行业普遍存在的职位。因为新，所以这个职位也没有什么行业标准。所以你会看到很多行业乱象：很多人想进入 IT 行业，一看程序员需要会写代码，觉得门槛高，那就从产品经理开始吧。这些人对产品经理岗位职责的理解是，告诉程序员做什么。没有良好的逻辑性，怎么可能在这个行业中有好的发展？

比较早成型的面向不确定创造新事物的方法论是**精益创业**，它提出了 “(想法 idea) --> 开发 build --> (产品 code)  --> 测量 measure --> (数据 data) --> 认知 learn --> (新想法 idea)” 这样一个**反馈循环**和**最小可行产品 MVP**的概念。当产品经理让我们做一个新的产品特性时，我们可以从精益创业这个实践上得到启发，向产品经理们问一些问题，帮助我们确定产品经理提出的需求确实是经过严格思考的。

### 2.6 解决了很多技术问题，为什么你依然在坑里 <sub>—— 在更大范围内寻找"终"</sub>

在前面的内容中，我给你介绍了几个体现 “以终为始” 原则的实践，包括怎样界定工作是否完成的 DoD、怎样判定需求是否完成的验收标准、还有怎样验证产品经理给出的产品特性是否合理的精益创业理念。了解了这些内容，可能你会想：我为什么要关心这些啊，如果我管了那么多事，我还是不是一个程序员，到底哪里才是我的 "终" 呢? 今天我们就聊一聊这个让许多人困惑的问题。因为只有跳出程序员的角色看问题，工作才会变得更加高效。

程序员总喜欢用技术去解决一切问题，但很多令人寝食难安的问题其实根本不是问题。之所以找不出更简单地解决方案，好多时候原因在于程序员被自己的思考局限住了。

不同角色工作真正的差异在于上下文的差异。在一个局部上下文难以解决的问题，换到另外一个上下文甚至是可以不解决的。所以说无论单点有多努力也只是局部优化，很难达到最优的效果。想把工作做好，就需要不断扩大自己工作的上下文，多了解一下别人的工作逻辑是什么样的，认识软件开发的全生命周期。

**扩大自己的上下文**，除了能对自己当前的工作效率提高有帮助，对自己的职业生涯也是有好处的。随着你看到的世界越来越宽广，得到的机会也就越来越多。

### 2.7 为什么说做事情之前先要推演 <sub>—— 沙盘推演，从军事指挥室里学来的大学问</sub>

无论做的事是什么，那些基本的部分是一样的，差别体现在事前忙还是事后忙。如果只想了功能实现而没考虑过上线，那么上线时会出来一堆问题。

即便已经确定了自己的工作目标，我们依然要在具体动手之前，把实施步骤推演一番，完成一次头脑中的创造。这种思想在军事上称之为沙盘推演，在很多领域都有广泛的应用。

### 2.8 你的工作可以用数字衡量吗 <sub>—— 数字化，一种衡量"终"的方式</sub>

一些人说，自己靠直觉就能把事情做好，其实这是一种误解，因为那种所谓的直觉，通常是一种洞见，洞见很大程度上依赖于一个人在一个领域长期的沉淀和积累，而这其实是某种意义上的大数据。

随着智能时代的来临，人类社会开始逐渐认识到数据的重要性。但我们这群 IT 人在通过数据为其他人服务的同时，却很少把数字化的思维带到自己的工作范围内。这也是工作中很多“空对空”对话的根源所在。结合着"以终为始"的思考，如果我们可以在一开始就设计好测量工作有效性的指标，那么就可以更有目的性地去工作了。而如果我们习惯了用数字去思考，就可以在很多方面让数字帮助我们，如 基于数据进行决策、预先设定系统指标，以及发现系统中的问题等。

### 2.9 启动开发之前，你应该准备什么

在这一讲中介绍了迭代0的概念，它是在正式开发迭代开始之前，进行一些基础准备，以下是一份供参考的准备清单。

在迭代0中将准备工作做好，后续你的一切工作就会变得井然有序，出现的简单问题会很快地被发现，所有人都在一种有条不紊的工作节奏中。

| 大类 | 小类     | 检查项
|----- |---------|-----------------
| 需求 | 功能     | 细化过的迭代需求
| 需求 | 交互     | 用户界面
| 需求 | 交互     | 用户交互
| 技术 | 基础     | 技术选型
| 技术 | 基础     | 技术架构
| 技术 | 数据库   | 数据库表结构
| 技术 | 数据库   | 数据库迁移
| 技术 | 持续集成 | 持续集成服务器
| 技术 | 持续集成 | 持续集成监视器
| 技术 | 持续集成 | 构建脚本
| 技术 | 测试     | 单元测试和集成测试
| 技术 | 测试     | 端到端测试
| 技术 | 发布     | 发布脚本


## 3. 任务分解

### 3.1 将大问题拆解成能够解决的小问题

一个大问题，我们都很难给出答案，但回答小问题却是我们擅长的。所以，当我们学会将问题分解，就相当于朝着问题的解决迈进了一大步。

我们从外星人探索和马斯克的火星探索入手，介绍了任务分解在人类社会诸多方面的应用。

虽然我们很熟悉分而治之的思想，但在日常工作中，我们却没有很好地应用它，这也使得大多数人的工作有很大改进空间。运用这一思想的难点在于，给出一个可执行的分解。一方面，对复杂工作而言，给出一个分解是巨大的挑战；另一方面，面对日常工作，人们更容易忽略的是，分解的任务要可执行。大多数人对于可执行的粒度认识是不足的，只有分解到很小的任务，才容易轻松完成一个开发循环，也让计划调整成为可能。软件行业在倡导拥抱变化，而任务分解是拥抱变化的前提。

### 3.2 开发者测试，程序员工作的一部分

在任务分解模块，我准备从一个让我真正深刻理解任务分解的主题开始，这个主题就是测试。这是一个让程序员又爱又恨的主题，爱测试，因为它能让项目的质量有保证，恨测试，因为测试不好写。而实际上，很多人之所以写不好测试，主要是因为他不懂任务分解。

测试人员只能站在系统外部做功能特性的测试。而一个软件是由它内部诸多模块组成的，测试人员只从外部保障正确性，所能达到的效果是有限的。

在软件开发中有一个重要的概念：软件变更成本，它会随着时间和开发阶段逐步增加。也就是说我们要尽可能早地发现问题，修正问题。“以终为始”就是在强调尽早发现问题。能从需求上解决的问题，就不要到开发阶段。同样，在开发阶段能解决的问题，就不要留到测试阶段。

需求人员要确定验收标准，开发人员则要交出自己的开发者测试。这是一个来自于精益原则的重要思想：内建质量。对于每个程序员来说，只有在开发阶段把代码和测试都写好，才有资格说自己交付的是高质量的代码。

测试框架最大的价值，是把自动化测试作为一种最佳实践引入到开发过程中，使得测试动作可以通过标准化的手段固定下来。

测试类型分：单元测试、集成测试、系统测试等等。越是底层测试，成本越低，执行越快；越是高层测试，成本越高，执行越慢。关于各种测试如何组合时，最佳实践——测试金字塔，强调越底层的测试应该写得越多。当测试数量达到一定规模，测试运行的时间就会很长。一般我们会选择在本地运行所有单元测试和集成测试，而把系统测试放在持续集成服务器上执行。

### 3.3 测试驱动开发，一种设计挑战

一些优秀的程序员不仅仅在写测试，还在探索写测试的实践。有人尝试着先写测试，于是，有了一种实践叫测试先行开发。还有人更进一步，一边写测试，一边调整代码，这叫做测试驱动开发。测试先行开发和测试驱动开发的关键差别就在重构上，TDD 在测试通过之后，要回到代码上，消除代码的坏味道。一旦你有了测试，你就可以大胆地重构了，因为任何修改错误，测试会替你捕获到。在测试驱动开发中，重构与测试是相辅相成的：没有测试，你只能是提心吊胆地重构；没有重构，代码的混乱程度是逐步增加的，测试也会变得越来越不好写。因为重构和测试的互相配合，它会驱动着你的代码写得越来越好。这是对 "驱动" 一词最粗浅的理解。

测试驱动开发已经是行业中的优秀实践，学习测试驱动开发的第一步要记住测试驱动开发的节奏：红 --> 绿 --> 重构。把测试放在前面，还带来了视角的转变，要编写可测的代码，我们甚至需要调整设计，所有有人也把 TDD 称为测试驱动设计。

### 3.4 任务分解，按部就班工作的前提

> **极限编程**
>
> 极限编程之所以叫"极限"，它背后的理念就是把好的实践推向极限：  
> 如果集成是好的，我们就尽早集成，推向极限每一次修改都集成，这就是持续集成  
> 如果开发者测试是好的，我们就尽早测试，推向极限就是先写测试再根据测试调整代码，这就是测试驱动开发  
> 如果代码评审时好的，我们就多做评审，推向极限就是随时随地地代码评审，这就是结对编程  
> 如果客户交流是好的，我们就和客户多交流，推向极限就是客户与开发团队时时刻刻在一起，这就是现成客户

很多人看了一些 TDD 练习觉得很简单，但自己动起手来却不知道如何下手，中间就是缺了任务分解的环节。

Kent Beck 是怎么做的呢？每当遇到一件要做的事，他总会先把它分解成几个小任务，记在一个清单上，然后，才是动手写测试、写代码、重构这样一个小循环。等一个循环完成了，他会划掉已经做完的任务，开始下一个。一旦在解决问题的过程中遇到任何新问题，他会把这个要解决的问题记录在清单上，保证问题不会丢失，然后，继续回到自己正在处理的任务上。当他把一个个任务完成的时候，问题就解决完了。Kent Beck 的做法清晰而有节奏，每个任务完成之后，代码都是可以提交的。

你或许会纳闷，这有什么特别的吗？你不妨回答这样一个问题，你多长时间能够提交一次代码？如果你的答案超过半天，对不起，你的做法步子一定是太大了。你之所以不能小步提交，一定是牵扯了太多相关的部分。

随着我在任务分解上练习的增多，我越发理解任务分解的关键在于 **小**。小到什么程度呢？有时甚至可以小到你可能认为这件事不值得成为一件独立的事，如升级一个依赖的版本，做一次变量改名。这样做的好处是什么呢？它保证了我可以随时停下来。我曾在一本书里读到过关于著名高尔夫球手伍兹的故事。高尔夫球手在打球的时候，可能会受到一些外界干扰。一般情况下，如果他已经开始挥杆，这时受到干扰，一般选手肯定是继续把杆挥下去，但通常的结果是打得不理想。而伍兹遇到这种情况，会停下来重新做挥杆的动作，保证每一杆动作的标准。伍兹能停下来，固然是经过了大量练习，但还有一个关键在于，对于别人而言，挥杆击球是一个动作，必须一气呵成。而对伍兹来说，这个动作是由若干小动作组成的，他只不过是刚好完成了某个小动作，而没有做下一个小动作而已。

**任务分解实战**

将需求分解成一个个任务，每做完一个任务，代码都是可以提交的。

一个最普通的用户登录的需求分解后大概是这个样子的：
* 设计用户信息表
* 数据库迁移选型
* 编写用户信息表的数据库迁移
* 编写 User 对象，包含用户名密码
* 在 UserRepository 中编写 save 方法，保存新创建的 User 对象
* 在 UserService 中编写 register 方法，实现用户注册
* 在 UserResource 中编写 register 方法，调用 UserService 的 register 方法
* 在 UserRepository 中编写 find 方法，根据用户名获取 User 对象
* 在构建脚本依赖中添加 Redis 的依赖
* 编写 UserSession，包含用户名、登录时间和用户 Token 等
* 在 UserService 中编写 login 方法，将 UserSession 放入 Redis 返回 UserSession
* 在 UserResource 中编写 login 方法，调用 userService 的 login 方法，并根据返回的 UserSession 设置 HTTP 头
* 在 UserService 中编写 logout 方法，实现用户退出
* 在 UserResource 中编写 logout 方法，调用 UserService 的 logout 方法
* 在构建脚本依赖中添加 JSON 的依赖
* 在存储到 Redis 时，将对象序列化成 JSON，取出时将 JSON 反序列化成对象
* 编写 AccessFilter，根据待访问地址确定是否进行用户登录信息校验

### 3.5 为什么你的测试不够好

关于测试，我们前面讲了很多，如：开发者应该写测试；要写可测的代码；要想做好 TDD 先要做好任务分解。今天我们再聊聊测试应该写成怎么样，怎么把测试写好。

我看到过很多团队在测试上出现过各种各样的问题，主要原因是因为这些测试不够简单。只有将复杂的测试拆分成简单的测试，测试才有可能做好。

测试的作用是保证代码的正确性，那谁来保证测试的正确性？既然无法用写程序的方式保证测试的正确性，那只剩一个方法：把测试写简单，简单到一目了然，不需要证明它的正确性。测试中应该规避以下常见问题：一个测试做了太多事情；测试没有断言；测试里有判断语句...

怎么衡量测试是否做好了呢？有一个标准：A-TRIP，这是五个单词的缩写，分别是：

* Automatic 自动化：把测试尽可能交给机器执行，人工参与的部分越少越好
* Thorough 全面：应尽可能覆盖各种场景：正常的、异常的、各种边界条件；应尽可能覆盖所有的代码和分支
* Repeatable 可重复：某一个测试反复允许，结果应该是一样的
* Independent 独立：测试和测试之间不应该有任何依赖
* Professional 专业：测试代码也是代码，要符合代码编写规范

### 3.5 程序员也可以砍需求吗

如果你对需求的管理粒度就是主题，那好多事情就没法谈了。比如，时间紧迫的时候，我想砍需求，你问产品经理，我不做登录行不行，你就等着被拒绝吧。但是，如果你说时间比较紧，我能不能把登录验证码放到后面做，或是邮件地址验证的功能放到后面，这种建议产品经理是可以和你谈的。这其中的差别就在于，后者将需求分解了。

评价用户故事有一个 **INVEST 原则**(Independent 独立 Negotiable 可协商 Valuable 有价值 Estimatable 可估算 Small 小 Testable 可测)，其中一个关键点是 "小"，只有小的需求才方便管理和调整。

### 3.6 太多人给你安排任务，怎么办

按照时间管理的理念，重要且紧急的事情要立即做。重要但不紧急的事情应该是我们重点投入精力的地方。紧急但不重要的事情，可以委托别人做。不重要不紧急的事情，尽量少做。这个矩阵带给我们思维上最大的改变是，让人意识到事情和事情不是等价的。如果不把精力放在重要的事情上，到最后可能都变成紧急的事情。把这个思路带回到我们现实的需求管理中，你会发现，其实团队面临的各种需求所采用的优先级排序方式，基本上都是按照紧急程度排列的，但它们是否真的重要呢？

需求分解之后，最重要的是，排列需求的优先级。优先级的排列方式有很多，我们可以借鉴时间管理的方法，把事情按照重要和紧急的维度进行划分，得到了四个象限。我们要尽可能把精力放在重要的事情上，而不是把紧急的事情当成优先级排序的方式。

需求分解成一个个小块，其实也分解了原本合一的上下文。如果想要有效地管理需求，尤其是确定事情的重要程度，一种方式是找回丢失的上下文。如果我们自己无法判断上下文，一种好的办法是，引入外部更大的上下文(话外音：跟产品谈不好一起找老板)。

### 3.7 用最小的代码做产品

前面我们讲了开发任务的分解和需求管理的分解，这些都是针对“已经确定好要做的事情”的分解策略，今天我们再上一个台阶，聊聊面对那些不确定的产品功能该如何分解。

什么叫最小可行产品？就是“刚刚好”满足客户需求的产品。客户需求好理解，怎么算“刚刚好”呢？其中的关键在于理解“最小”和“可行”。

#### 最小的代价

最小的代价，就是能不做的事情就不做，能简化的事情就简化。

首先，我们必须清楚一件事，我们要做的是验证一个想法的可行性，甚至不是为了开发一个软件，开发软件只是一种验证手段。很多程序员都会有一个认识上的误区，容易把解决方案当做问题。我们开发软件的目的是为了解决问题，如果不写软件就把问题解决了，岂不是更好。

有一次，有一个朋友找我帮忙，他手头有一些制造业的客户，想做一个物联网相关的项目，帮助这些客户改造设备，实现物联网功能。该怎么着手呢？把软件写好，给客户试用吗？这样时间太长，成本太高。那么，我们是怎么做的呢？

第一步，我们要验证这样一个想法是否可行。我们做了一个产品文档，就好像我们已经有了这个产品一样，让负责销售的同事拿着这个文档给客户讲讲，看看客户对这个想法的反映。在这个过程中，我们验证了基本的想法，已有设备进行物联网化改造的需求存在，客户看到了这样的一个东西，各种各样的想法和要求就会冒出来。此外，我们还获得了一个额外的收获，我们知道了客户对于这样一个产品能够接受的价格区间，这可以帮助团队给产品进行适当的定价。

验证了方向上的想法，我们开始进入到具体的产品设计阶段。这个阶段我们想验证的是，我们给出的产品设计用户是否可以接受。于是，我们决定把这个产品的交互做出来。得益于原型工具的快速发展，我们用一个原型工具做出了相对完整的用户界面，而且把各种交互流都做出来了。在用户看来，这几乎就是完整的软件了。他们甚至可以在自己的设备上体验一下这个产品用起来是什么感觉的。一旦上手用起来，他们就会抛出各种细节的问题：如果这样就好了，如果能做到这个就太棒了。当然，他们也会说，这个东西我不需要。这个时候，我们就可以知道，我们在产品上的假设哪些是好的，哪些是不流畅的。团队拿到这些反馈，就可以再调整产品设计，然后，再给到用户去测试，如此反复进行。有的时候，产品会在一天之内改好几个版本。

经过多轮测试下来，团队有了一大堆的用户反馈，而且是来自真实用户的反馈。接下来，就是整理这些用户反馈，决定哪些可以真正的开发出来，这时候，团队才真正进入到开发阶段。

不知道你注意到了没有，迄今为止，这个团队验证了一大堆的想法，而代码却是一行都没有写，所有花费的工作量都是有针对性的验证。开发软件是一件成本很高的事情。如果只是验证想法，无论是创业方向，还是产品设计，我们可以找到各种各样的手段，不用写代码。

#### 可行的路径

我再给你分享一个我当年做 P2P 项目经历。这是一个从头开始的项目，项目方和所有的项目方一样，希望昨天这个项目就上线了，如果不能，那就尽快上线一个版本。他们给我们一个时间线，第一个上线的版本是一个月之后。摆在我们面前的问题是，无论如何，在一个“一穷二白”的基础上，要在一个月内完成一个完整的借贷平台是不太可能的。时间有限，我们只能做最基本的东西，许多运营上的想法，比如，发红包代金券之类的，第一期一律不做。即便如此，我们仍然认为完成完整的借贷循环是不现实的。于是，我们就开始从需求完整性的角度动脑筋。这是一个借贷系统，其最基本的模型是：贷款方贷款之后，一次性拿到所有的钱，然后用等额本息的方式每个月还款，最后一个月剩多少钱一次性全还了。我们在这个模型中找到了一个关键点，每个月还款。换句话说，第一笔贷款发生之后，最早的一笔还款是发生在一个月之后的。于是，我们做了一个决定，第一个版本只包含贷款能力。是的，这个版本只能贷款，不能还款。因为用户一个月之内不会用到这个功能，你从页面上，完全看不出这样的能力缺失，因为一个月内，根本没有任何用户有可还的款项。因为缩减了项目规模，我们在预期的一个月内完成所有开发，成功地把项目送上了线。第一批早期用户就开始了使用。从用户的视角看，这是一个功能完整的项目，虽然简单了点，但它是完整的。当然，我们把还款排到了下一期。按照我们两周一迭代的节奏，在第一期上线两周之后，我们就会上线还款功能，届时贷款方将拥有一个真正的还款功能。不过，这个还款功能只是每期的等额本息还款，最后的一次性还剩余所有贷款的功能，我们依然是不支持的。因为根据需求设计，最后一次还款最早发生在一年之后。

在我们把基本的功能全部送上线之后，这个系统就是一个真正的、完整的借贷平台了。但是，相对于其他提供相同能力的平台而言，这个系统依然还是很简单。比如，常见的运营功能、短期借贷计划，这个平台都没有。但我们有了基础，接下来，就是在基础上叠加，而且随着项目方自己团队的构建，我们拥有了够大的团队，可以同时做几个大需求了。就这样，几个月之后，我们就逐步上线了一个功能相对完整的 P2P 平台。在这个过程中，我们每个阶段都会上线新功能，从用户可见的角度，他看到的始终是一个完整的平台，其中的变化只有站在内部实现者的角度才能看得清楚。

和大家分享这个例子，主要是想破除大家对于一个“完整”系统概念的认识。当时间有限时，我们需要学会找到一条可行的路径，在完整用户体验和完整系统之间，找到一个平衡。


## 4. 沟通反馈

### 4.1 为什么世界和你的理解不一样

为什么我们对世界的理解会出现偏差？信息的传达要经过编码和解码两个过程，无论是编码还是解码出现问题，都会造成信息的不准确。因为每个人经历见识的差异，造成了各自编解码器的差异。

改善编解码，需要从几个角度着手，分别是：编码器，让信息能输出更准确；解码器，减少信号过滤，改善解码能力；还有编解码算法，也就是各种来自行业的“最佳实践”，协调沟通的双方。

很多程序员讲东西都有一个通病：讲东西直奔细节，完全没有背景介绍。

### 4.2 你的代码为谁而写

> 任何人都能写出计算机能够理解的代码，只有好程序员才能写出人能够理解的代码 —— Martin Flower  
> 计算机科学中只有两个难题：缓存失效和命名 —— Phil Karlton

**用业务的语言写代码**

写代码的进阶路径：编写可以运行的代码 --> 编写符合代码规范的代码 --> 编写人可以理解的代码 --> 用业务语言写代码

一个专业程序员，追求的不仅是实现功能，还要追求代码可维护。如果你想详细学习如何写好代码，我推荐你读一读《代码整洁之道》，这本书几乎覆盖了把代码写好的方方面面。

命名，是写程序中最基础，也是一个程序员从业余走向专业的门槛。我以命名为基础，给你解释了写好代码的提升路径。最初的层次是编写可以运行的代码，然后是编写符合代码规范的代码。再进一步提升，编写代码是要写出人可以理解的代码。因为代码更重要的作用是人和人沟通的桥梁，起一个降低其他人理解门槛的名字才是好名字。实际上，我们很多没写好的程序有一些原因就是名字起错，把一些概念混淆在一起了。想起好名字，就要学会用业务语言写代码，需要尽可能多地学习业务知识，把业务领域的名字用在代码中。

命名提升案例 1

我们在代码评审中会看到类似的场景：  
评审者：这个叫 `map` 的变量是做什么用的？  
程序员：它是用来存放账户信息的，它的键值是账户 ID，值就是对应的账户信息  
评审者：那为什么不直接命名成 `accounts`？

很多程序员习惯的方式是用计算机的语言进行表达，就像这个例子里面的 `map`，这是一种数据结构的名字，是面向计算机的，而评审者给出的建议，把变量名改成 `accounts`，这是一个业务的名字。虽然只是一个简单的名字修改，但从理解上，这是一步巨大的跨越，缩短了其他人理解这段代码所需填补的鸿沟，工作效率自然会得到提高。

命名提升案例 2

写代码的时候，尽可能用业务语言，会让你转换一个思路。我们用最常用的电商下单过程来说，凭直觉我们会构建一个订单类 Order。什么东西会放在这个类里呢？首先，商品信息应该在这个类里面，这听上去很合理。然后，既然是电商的订单，可能要送货，所以，应该有送货的信息，没问题吧。再来，买东西要支付，我们会选择一些支付方式，所以，还应该有支付信息。就这样，你会发现这个订单类里面的信息会越来越多：会员信息可能也要加进去，折扣信息也可能会加入。你是一个要维护这段代码的人，这个类会越来越庞大，每个修改都要到你这里来，不知不觉中，你就陷入了一个疲于奔命的状态。如果只是站在让代码运行的角度，这几乎是一个无法解决的问题。我们只是觉得别扭，但没有好的解决方案，没办法，改就改呗！

但如果我们有了看业务的视角，我们会问一个问题，这些信息都放在“订单”是合理的吗？我们可以与业务人员交流，询问这些信息到底在什么场景下使用。这时候你就会发现，商品信息主要的用途是下单环节，送货信息是在物流环节，而支付信息则用在支付环节。有了这样的信息，你会知道一件事，虽然我们在用一个“订单”的概念，但实际上，在不同的场景下，用到信息是不同的。所以，更好地做法是，把这个“订单”的概念拆分了，也就有了：交易订单、物流订单和支付订单。我们原来陷入的困境，就是因为我们没有业务知识，只能笼统地用订单去涵盖各种场景。

### 4.3 你总是在开会吗

#### 头疼的开会

开会是为了解决问题，但真实情况却是开了会又没有解决多少问题，这真是一个奇特的矛盾。

在我的职业生涯中，凡是效果特别好的会议，基本上都是用来做信息同步的，比如领导宣布一个事情，宣布消息，大家收到消息，结束。那效果不好的会议室什么样的呢？几乎都是那些讨论会，你一言我一语，每个会都有几个擅长打岔的，这个会基本上都会跑偏，开会是一种重量级的沟通，用开会这种重量级的方式讨论问题，就好比杀鸡用了牛刀。

#### 轻量级沟通

实际上，真正在会议上能够积极参与讨论的人并不会觉得会议是浪费时间，因为高度参与其中，人是进入到心流状态的，时间流逝很快。觉得浪费时间的，往往是没有参与其中的人。换句话说，会议之所以给人留下如此不堪的印象，一个重要的原因是，真正参与讨论的人并不多。所以，我们换个角度思考一下，只要把这些真正参与讨论的人拉到一起讨论不就好了？所以，**改善会议的第一个行动项是，减少参与讨论的人数。**

有人会说，我这个讨论有好几个议题，每个议题要不同的人参与，那你要做的是，分别找这几个人专门讨论，而不是把大家放到一起。相比于会议的形式，面对面沟通议题小，参与人数不多，每个人的投入也会更多一些。所以，我们的第二个行动项是，**如果你要讨论，找人面对面沟通。**

一旦理解了这些改进方式，我们就可以改进自己的行为方式。如果有一个问题需要讨论，我要做的是，分别找到相关人针对关心的主题进行讨论，然后，我把讨论的结果汇总再去征求大家意见。如果大家达成一致了，我才会选择开会。这个时候，开会的目的不再是讨论，而是信息同步：我准备这么干了，相关各方已经同意了，知会大家一下，结束。

#### 站立会议

开会并非都是不好的，一些信息同步的会还是有必要的。有一种实践叫站会，很多工作都在实践它，站会甚至成为每天的开工仪式。

* 站会不超过 10 分钟
* 每个人的发言只说三件事：我昨天做了什么，今天打算做什么，过程中遇到了什么问题需要请求帮助(不展开、具体会后讨论)
* 当团队很大时，应该把团队拆分，5-12 人是一个恰当的团队规模

站会应该避免走入一些误区

* 每个人的发言要尽量简短，一旦一个人说多了，跟你关系不大，你就开始思维发散了
* 还有一个典型的错误是，把站会开成了汇报会，说的人都向负责人在汇报工作，其他人自然就走神了

#### 总结

如果你想用会议的形式与别人讨论问题，最好放弃这种打算，面对面的沟通是最好的方式。因为面对面沟通很轻，人数相对少，每个人参与度就会高很多。基于这种改进，我们可以把大部分会议都改成信息同步的会，效率就会得到提高。

### 4.4 可视化，一种更为直观的沟通方式

**多尝试用可视化的方式进行沟通**

就人脑的进化而言，处理图像的速度远远快于处理文字，所有有一图胜千言的说法。通过创建图像、图标或动画进行信息交流的形式，就是可视化。可视化有很多种不同的分类，我们最常用的应该是数据可视化和信息可视化。

大多数软件过程习惯采用文字的方式进行表达，对于"可视化"利用的还不够。当然，还是有一些利用"可视化"的方法，比如 流程图 UML 等。

利用可视化进行信息沟通的实践：看板。看板把工作分成了几个不同的阶段，在看板上对应不同的列，然后，每个任务作为一张卡贴在上面，每完成一张卡，就把这张卡挪到下一个阶段。看板可以帮助你发现很多问题，如当前进展是否合适，是否有人同时在做很多的事，发现当前工作的瓶颈等。

### 4.5 如何做好持续集成

很多人把 CI 服务器 Jenkins 理解成了持续集成。我曾接触过这样的团队，他们恨不得把所有的事情都放在 CI 服务器上做：编译、代码检查、单元测试、测试覆盖率统计等等。这种做法不是不可行，但不是最佳实践。

持续集成的诞生，就是人们尝试缩短集成周期的结果。为什么要缩短周期呢？因为我们希望尽早得到反馈，知道自己的工作结果是否有效。所以，想要做好持续集成，就需要顺应持续集成的本质：**尽快得到工作反馈**。

...对比之下，在本地运行这些检查，你不需要提交，不需要等 CI 服务器开始执行，不需要跑到额外的地方查看检查结果。所以这个操作比提交到服务器上会快很多。另外，这里还有一个关键点，我们的操作是连续的。一旦检查结果出错了，我们立刻进入修复环节。作为程序员，我们太了解连续操作的重要性了。

使用 CI 服务时，及时得到反馈并采取行动也是一个重点。用邮件通知显然太慢了，我们需要持续集成监视器。市面上有很多 CI 监视器软件，有的是做视觉呈现，有的是做桌面通知。CI 服务器一旦检查出错要立即修复，因为你不修，别人就不能提交，整个团队的工作流就会被打断。

### 4.6 开发中的问题一再出现，该怎么办

**定期复盘，找准问题根因，不断改善**。

#### 回顾会议

如果在开发过程中，同样的问题反复出现，说明你的团队没有做好复盘。复盘，就是过程还原，进行研讨与分析，找到自我改进方法的一个方式。这种方式使我们拥有了客体化的视角，能够更客观地看待曾经发生过的一切。在软件开发中，一个重要的复盘实践是 **回顾会议**。

定期回顾是一个团队自我改善的前提，回顾会议怎么开呢？

1. 作为组织者，我会先在白板上给出一个主题分类。我常用的是分成三类：“做得好的、做得欠佳的、问题或建议”。
2. 然后，我会给与会者五分钟时间，针对这个开发周期内团队的表现，按照分类在便签上写下一些事实。这里面有两个重点。一个是写事实，不要写感受。因为事实就是明摆在那里的东西，而感受无法衡量，你感觉好的东西，也许别人感觉很糟糕。另外，每张便签只写一条，因为后面我要对便签归类。因为大家是分头写的，有可能很多内容是重复的，所以，要进行归类。
3. 五分钟之后，我会号召大家把自己写的便签贴到白板上。等大家把便签都贴好了，我会一张一张地念过去。这样做是为了让大家了解一下其他人都写了些什么，知道不同人的关注点是什么。一旦有哪一项不清楚，我会请这张便签的作者出来解释一下，保证大家对这个问题的理解是一致的。在念便签的同时，我就顺便完成了便签归类的工作。等到所有的便签都归好类，这就会成为后续讨论的主题，与会者也对于大家的关注点和看到的问题有了整体的了解。做得好的部分，是大家值得自我鼓励的部分，需要继续保持。而我们开回顾会议的主要目的是改善和提升，所以，我们的重点在于解决做得不好的部分和有问题出现的地方。
4. 在开始更有针对性的讨论之前，我会先让大家投个票，从这些分类中选出自己认为最重要的几项。我通常是给每人三票，投给自己认为重要的主题。每个人需要在诸多内容中做出取舍，你如果认为哪一项极其重要，可以把所有的票都投给这个主题。根据大家的投票结果，我就会对所有的主题排出一个顺序来，而这就是我们要讨论的顺序。我们不会无限制的开会，所以，通常来说，只有最重要的几个主题才会得到讨论。无论是个人选择希望讨论的主题，还是团队选择最终讨论的主题，所有人都要有“优先级”的概念在心里。然后，我们就会根据主题的顺序，一个一个地进行讨论。
5. 讨论一个具体的主题时，我们先会关注现状。我会先让写下反馈意见的人稍微详细地介绍他看到的现象。比如，测试人员会说，最近的 Bug 比较多，相比于上一个开发周期，Bug 增加了 50%。然后，我会让大家分析造成这个现象的原因。比如，有人会说，最近的任务量很重，没有时间写测试。
6. 再下来，我们会尝试着找到一个解决方案，给出行动项。比如，任务重，我们可以让项目经理更有效地控制一下需求的输入，再把非必要的需求减少一下；测试被忽略了，我们考虑把测试覆盖率加入构建脚本，当测试覆盖率不足时，就不允许提交代码。请注意，**所有给出的行动项应该都是可检查的**，而不是一些无法验证的内容。比如，如果行动项是让每个程序员都“更仔细一些”，因为“仔细”这件事很主观，你说程序员不仔细，程序员说我仔细了，这就是扯皮的开始。而我们上面给出的行动项就是可检查的，项目经理控制输入的需求，我们可以看每个阶段开发的总点数是不是比上一个阶段少了。而测试覆盖率更直接，直接写到构建脚本中，跑不过，不允许提交代码。
7. 好，列好了一个个的行动项，接下来就是找责任人了，责任人要对行动项负责。比如，项目经理负责需求控制，技术负责人负责将覆盖率加入构建脚本。有了责任人，我们就可以保障这个任务不是一个无头公案。下一次做回顾的时候，我们就可以拿着一个个的检查项询问负责人任务的完成情况了。

#### 5 Why 分析法

无论哪种做法，分析问题，找到根因是一个重要的环节。**5 Why 分析法** 就是一个常用的找到根因的方式。需要注意的是，问题是顺着一条主线追问，不能问 5 个无关的问题。

服务器经常返回 504，那我们可以采用 5 Why 的方式来问一下：

* 为什么会出现 504 呢？因为服务器处理时间比较长，超时了。
* 为什么会超时呢？因为服务器查询后面的 Redis 卡住了。
* 为什么访问 Redis 会卡住呢？因为另外一个更新 Redis 的服务删除了大批量的数据，然后，重新插入，服务器阻塞了。
* 为什么它要大批量的删除数据重新插入呢？因为更新算法设计得不合理。
* 为什么一个设计得不合理的算法就能上线呢？因为这个设计没有按照流程进行评审。

### 4.7 作为程序员，你应该了解用户

无论是自己做用户，还是找机会接触已有用户，亦或是没有用户创造用户。只有多多听取来自真实用户的声音，我们才不致于盲目自信或是偏颇地相信产品经理。谁离用户近，谁就有发言权，无论你的角色是什么。

很多程序员只希望安安静静地写好代码，但事实上，对于大多数人来说，安安静静是不太可能写好代码的，只有不断扩大自己的工作范围，才可能对准“靶子”。今天我们讨论的角度，就是要你把工作范围扩大，由听产品经理的话，扩大成倾听用户的声音。

...对我来说，那是一个难忘的下午，我第一次这么近距离地感受用户。他们的关注点，他们的使用方式都和我曾经的假设有很多不同。后面再来设计这个系统时，我便有了更多的发言权，因为产品经理有的角度，我作为开发人员也有。

最后，我还想说一个程序员常见的问题：和产品经理没有"共同语言"。因为他们说的通常是业务语言，而我们的口中基本上是计算机语言。这是两个领域的东西，很难互通。前面在讨论代码的时候，我提到要用业务的语言写代码，实际上，这种做法就是领域驱动设计中的通用语言。所谓通用语言，不只是我们写代码要用到，而是要让所有人说一套语言，而这个语言应该来自业务，来自大家一起构建出的领域模型。这样大家在交流的时候，才可能消除歧义。所以，如果你想让项目顺利进行，先邀请产品经理一起坐下来，确定你们的通用语言。

### 4.8 尽早暴露问题

越往前做，给人留下的空间和余地越大，调整的机会也就越充足。而在最后一刻出现问题的成本实在太高，大到让人无法负担。这个原则在写程序中的体现就是 Fail Fast。

### 4.9 写文档做分享也是一种学习方式

我知道，你可能并不喜欢写文档，因为在你眼中，写文档是繁琐的，是旧时代软件工程的产物。然而文档却是非常重要的。我到过很多公司，凡是我能够比较快上手的，通常都是有比较详尽的文档，而那些文档缺失的公司，想要把信息梳理清楚，往往会花很长时间。另外，我学习很多软件开发的相关知识，通常也是依赖各种各样的文档。大量阅读文档是我们日常工作的一部分。你发现矛盾了吗？一方面，我们讨厌写文档，另一方面，文档却对我们的工作学习有着不可忽视的作用。

写文档时，角色是作者；而读文档时，角色是读者。作为读者，我们读文档，实际上就是按照作者梳理的结构在走，因为呈现出来的内容，多数是已经结构化的，读起来自然会比较顺畅；而作为作者，没有人告诉你结构应该是什么样，我们必须创造出一个结构来，而这正是很多人不擅长的。

输出的过程，本质上就是把知识连接起来的过程。自己以为自己懂的东西，当你真的需要把它按照一个完整的逻辑呈现出来时，那些缺失的细节就会冒出来，而补齐这些细节，一张知识地图就逐渐成型了。将知识对外输出就是一种获得反馈的方式。很多人自以为对知识的理解已经很深入了，但给别人一讲，却发现自己怎么也讲不清楚，这就说明他理解的程度，远未到达他以为的高度。

输出的方式有很多，对于程序员来说，最常接触到的两种应该是写作与演讲。软件行业的很多大师级程序员都是对外输出的高手。

...后来的一些职业机会，也是通过我写 blog 认识的朋友。考虑到我当时人在 IT 边缘的东北，能有后来的职业发展，很大程度都是常年坚持对外输出的结果。

而想要做好知识输出，还需要不断地进行练习，写作和做公开演讲都是可以通过练习提高的。**无他，唯手熟尔！**


## 5. 自动化

### 5.1 懒惰应该是所有程序员的骄傲

Perl 语言的发明人 Larry Wall 曾经说过，优秀程序员应该有三大美德：懒惰、急躁和傲慢（Laziness, Impatience and hubris）。想要成为一个优秀的程序员，就要让机器为自己很好地工作，而这需要对自动化有着很好地理解。

我们学习自动化，先要知道哪些东西不要自动化，尽最大的努力不做浪费时间的事。一方面，我们要从需求上规避那些没必要做的事；另一方面，我们也从自身防止 NIH 综合症（Not Invented Here Syndrome），争取做一个懒惰的程序员。

对于要自动化的事，我们需要反思一下，在为别人打造自动化工具的同时，我们自己的工作过程有没有很好地自动化。而如果我们想拥有打造良好的自动化工具，我们需要对软件设计有着充分地理解。

我不想让我的**设计**随着某一个**技术选型(实现)**而不断摇摆。不懂软件设计，只专注各种工具，其结果一定是被新技术遗弃，这也是很多人经常抱怨 IT 行业变化快的重要原因。回到 Larray Wall 的说法上，你要想写出一个别人挑不出毛病的程序，你先要懂得软件设计。幸运的是，软件设计这些年的变化真不大，掌握了软件设计再来看很多框架和工具，学习起来就会容易很多。在这个模块的后半部分，我会与你探讨软件设计的话题，降低自己给自己挖坑的概率。

### 5.2 开发过程的自动化

通过构建脚本实现开发过程的自动化

### 5.3 程序员怎么学习运维知识

部署过程要依赖于运维知识，每个程序员都应该学习运维知识，保证我们对软件的运行有更清楚地认识，而且部署工作是非常适合自动化的。但是，对运维工具的学习是非常困难的，因为我们遇到的很多工具是非常零散的，缺乏体系。这里，我给你介绍了一个运维的知识体系，这个体系借鉴自 Java 的知识体系，包括了编程语言、核心库、第三方库、开发框架、单机部署和集群部署等诸多方面。

| 类别     | Java                       | 运维
|----------|----------------------------|----------------------
| 语言     | Java 语言                   | Shell 脚本
| 核心库   | JDK                         | Unix/Linux 核心命令
| 第三方库 | 第三方程序库，如 Guava SLF4J  | 第三方命令，如 rsync curl
| 开发框架 | 开发框架，如 Spring          | 配置管理工具，如 Chef Puppet Ansible
| 单机部署 | 应用服务器，如 Tomcat Jetty   | 部署环境，如 虚拟机 Docker
| 集群部署 | 企业级应用服务器，如 IBM WebSphere | 云服务器，如 Amazon AWS, 阿里云, Docker 集群, Kubernates

### 5.4 持续交付，一种延伸的持续集成

> 自动化全貌：程序员写好程序，用构建脚本执行检查，提交代码，在服务器上打出一个发布镜像，部署到各个环境进行检查，检查好了，随时可以发布上线。

什么是持续交付？简言之，它就是一种让软件随时处于可以部署到生产环境的能力。从一个打好的发布包到部署到生产环境可用，这中间还差了什么呢？那就是验证发布包，部署到环境中。验证发布包，你或许会想，这不是测试的事吗？这不是已经在持续集成阶段完成的吗？不尽然。在持续集成阶段验证的包，往往缺少了环境的支持。因为**持续集成**的环境往往是单机的，主要强调功能验证，而一些与生产环境相关的测试往往是欠缺的。所以，这里就引出了持续交付中一个需要关注的点：环境。一旦通过了各种验证，就会到构建流水线的最后一个阶段，生产发布。通常来说，生产发布这个过程不是自动化的。我们说，**持续交付**的关注点在于，让软件具备随时可以发布的能力，但并不等于它要立刻上线，所以，最后这一下，还要由人来决定，到底是不是要上线。如果把由人决定的是否上线变成自动化的，就成了另外一个实践：**持续部署**。但通常人们都会比较谨慎，最后这一下还是由人拍板比较稳妥，所以，持续交付是现在的主流。

在传统的 IT 公司中，开发和运维往往是井水不犯河水的两个职位，甚至是两个不同的部门，由此带来了很多问题，比如，开发人员修改了配置，但没有通知运维，造成了新代码不能运行。DevOps 提倡的就是将二者融合起来，打破壁垒。

### 5.5 如何做好验收测试 —— 站在用户的角度看测试

验收测试（Acceptance Testing），是确认应用是否满足设计规范的测试。验收测试是技术交付必经的环节，只不过，各个团队实践水平有所差异，有的靠人工，有的用简单自动化，一些做得比较好的团队才有完善的自动化。

让验收测试从各自为战的混乱中逐渐有了体系的是行为驱动开发（Behavior Driven Development）这个概念的诞生。行为驱动开发中的行为，指的是业务行为。BDD 希望促进业务人员与开发团队之间的协作，换句话说，如果你想做 BDD，就应该用业务语言进行描述。这与我们传统上理解的系统测试有着很大的差别，传统意义上的系统测试是站在开发团队的角度，所以，更多的是在描述系统与外部系统之间的交互，用的都是计算机的术语。而 BDD 则让我们换了一个视角，用业务语言做系统测试，所以，它是一个更高级别的抽象。今天最流行的 BDD 框架应该是 Cucumber。

### 5.6 你们的代码是怎么变混乱的 —— 单一职责，划分界限

你会抱怨写一段代码吗？你肯定不会，毕竟这是你养家糊口的本领。那抱怨的是什么呢？是维护一段代码。为什么维护代码那么难？因为通常来说，你维护的这段代码是有一定年龄的，所以，你总会抱怨前人没有好好写这段代码。好，现在你拿到了一个新的需求，要在这段代码上添加一个新功能，你会怎么做呢？很多人的做法是，在原有的代码上添加一段新的逻辑，然后提交完工。从前，我也认为很多程序员是不负责任，一开始就没有把代码写好，后来，我才知道很多代码其实只是每次加一点。你要知道，一个产品一旦有了生命力，它就会长期存在下去，代码也就随着时间逐渐腐烂了。

这样的问题有解吗？一个解决方案自然就是我们前面说过的重构，但重构的前提是，你得知道代码驶向何方。对于这个问题，更好的答案是，你需要了解一些软件设计的知识。

许多程序员学习设计是从设计模式起步的，但这种学法往往会因为缺乏结构，很难有效掌握。设计原则，是一个更好的体系，掌握设计原则之后，才能更好地理解设计模式这些招式。Robert Martin 总结出的“SOLID”是一套相对完整易学的设计原则。

当我看到了 SOLID 的五个原则之后，我终于想明白了，原来我追求的方向错了。如果说**设计模式是“术”，设计原则才是“道”**。设计模式并不能帮你建立起知识体系，而设计原则可以。

SOLID 原则

* 单一职责原则（Single responsibility principle，SRP）
* 开放封闭原则（Open–closed principle，OCP）
* Liskov 替换原则（Liskov substitution principle，LSP）
* 接口隔离原则（Interface segregation principle，ISP）
* 依赖倒置原则（Dependency inversion principle，DIP）

### 5.7 你真的理解分层吗

MVC 分层架构实际是一种设计上的分解，将不同的内容放在不同的地方，降低软件开发和维护的成本。分层，更关键的是，提供抽象。这种分层抽象在计算机领域无处不在，无论是编程语言，还是网络协议，都体现着分层抽象的价值。有了分层抽象，人们才能更好地在抽象的基础上构建更复杂的东西。

在日常工作中，我们应该把精力重点放在构建自己的领域模型上，因为它才是工作最核心、不易变的东西。

### 5.8 总有人觉得 5 万块就能做个淘宝
### 5.9 先做好 DDD 再谈微服务吧


## 6. 综合运用

### 6.1 新入职一家公司改如何快速进入工作状态
### 6.2 面对遗留系统你该如何做
### 6.3 我们应该如何保持竞争力
### 6.4 少做事才能更有效地工作




