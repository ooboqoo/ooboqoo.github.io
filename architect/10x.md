# 10x 程序员工作法


软件行业里有一本名著叫《人月神话》，其中提到两个非常重要的概念：本质复杂度 Essential Complexity 和 偶然复杂度 Accident Complexity。大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。如何减少偶然复杂度引发的问题，让软件开发工作有序、高效地进行，这正是本专栏的目的。我会尝试给你提供一个思考框架，帮你在遇到问题时梳理自己真正要做的事情，贯穿这个框架的，有四个原则：**以终为始 任务分解 沟通反馈 自动化**。


## 1. 思考框架

Where are we? 现状  -->  Where are we going? 目标  -->  How can we get there? 实现路径


## 2. 以终为始

### 2.1 如何让你的努力不白费 <sub>—— 以终为始，一种结果导向的思考方式</sub>

亚马逊开发一项产品，采用后向工作的方法：1.写新闻搞 -> 2.写 FAQ -> 3.写用户文档 -> 4.写代码

### 2.2 你完成了工作，为什么他们还不满意 <sub>—— 什么叫“完成”</sub>

**在做任何事之前，先定义完成的标准。**

Definition of Done
  * 是行业中的一种最佳实践，能够在团队内部很好的同步大家对完成的理解
  * 是一份由一个个检查项组成的清单，用来检查我们的工作完成情况，确保不遗漏任何事情
  * 是一种思维模式，是一种尽可能消除不确定性、达成共识的方式

### 2.3 接到需求任务，你要先做哪些事 <sub>—— 用验收标准看需求是否明确</sub>

**在做任何需求或任务之前，先定好验收标准。**

需求，是软件开发中的一个关键环节，一旦需求理解出现问题，势必会造成大量的浪费。传统的功能列表只是简单罗列了要实现的功能，丢失了大量的上下文，会导致团队成员对于需求"只见树木不见森林"。而在比较大的团队中，更是会将一个功能拆分到多个小团队中，每个人看到的只是功能碎片，于是后来产生了其他的需求描述方式，比如用例和用户故事。

很多人学习用户故事，认为最重要的是记住 "As ..., I want to ..., so that ..." 这样的需求描述方式。而在我看来比描述方式更重要的是验收标准。

> **用户故事**
>
> **标题**，简要地说明用户故事的主要内容，如：注册用户使用用户名密码登录  
> **概述**，简要地介绍用户故事的主要内容，一般会用这样的格式：As a (Role), I want to (Activity), so that (Business Value). 如：作为一个注册用户，我想要通过用户密码登录，以便我可以使用注册用户才能够使用的服务  
> **详述**，详细地描述这个用户故事的完整流程，我们会把操作流程、用户界面等信息放到这里  
> **验收标准**，这个部分会描述一个正常使用的流程是怎样的，以及各种异常流程系统是如何给出响应的，这是程序员常常会欠缺的思考。它会把详述中很多叙述的部分变成一个个具体的测试用例。

验收标准非常重要的一环是异常流程的描述。大部分程序员都擅长解决正常流程，而异常流程则是最容易忽略的，也是产生扯皮的关键环节。既然容易扯皮，我们就在一开始把它定义清楚。采用用户故事后，我经常在写完了主要流程后，再去看一下验收标准，为自己的开发查缺补漏。因为我知道，那是标准，达不成就不算任务完成。

当我们说自己开发完成时，可以交给测试人员测试时，我们需要照着验收标准给测试人员演示一遍，怎么我们的系统确实能够跑通。这之后，测试人员才会把系统接手过去，做更系统的测试。

验收标准给出了这个需求最基本的测试用例，它保证了开发人员完成需求最基本的质量。如果你了解 BDD 行为驱动开发，就可以按照验收标准中给出的内容编写验收测试用例了。

在实际工作中，许多产品经理把需求交给开发人员之前，很多细节是没想清楚的，那种功能列表式的需求常常只包含了正常路径，那些缺失的细节就是在后续的过程中，由开发人员补全的。用户故事就是一种固定的格式，让他们把这些应该想清楚的问题想清楚。

或许你会有这样的疑问，如果产品经理通过用户故事的方式，将需求实现细节都描绘得清清楚楚，那我们程序员的发挥空间在哪里？请注意，验收标准所给出的实现细节应该是业务上的，我们的发挥空间应该是在技术实现上。

也许你会说，我在一个小公司工作，公司没有专门的产品经理，需求都是老板扔给我们的，谁来帮我们写验收标准呢？没办法，答案只能是你自己。虽然你名义上是程序员，但当拿到一个需求的时候，你要做的不是立即动手写代码，而是扮演产品经理的角色，分析需求，圈定任务范围。相信我，事前分析绝对比你拿一个写好的系统给老板，而他却告诉你这不是他想要的，好太多了。

### 2.4 集成本身就应该是写代码的一个环节 <sub>—— 从持续集成的角度看开发</sub>

### 2.5 产品经理不靠谱，你该怎么办 <sub>—— 用精益创业的视角衡量产品特性的有效性</sub>

### 2.6 解决了很多技术问题，为什么你依然在坑里 <sub>—— 在更大范围内寻找"终"</sub>

### 2.7 为什么说做事情之前先要推演 <sub>—— 沙盘推演，从军事指挥室里学来的大学问</sub>

### 2.8 你的工作可以用数字衡量吗 <sub>—— 数字化，一种衡量"终"的方式</sub>

### 2.9 启动开发之前，你应该准备什么


## 3. 任务分解

### 3.1 将大问题拆解成能够解决的小问题
### 3.2 开发者测试，程序员工作的一部分
### 3.3 测试驱动开发，一种设计挑战
### 3.4 任务分解，按部就班工作的前提
### 3.5 程序员也可以砍需求吗
### 3.6 太多人给你安排任务，怎么办
### 3.7 用最小的代码做产品




## 4. 沟通反馈

### 4.1 为什么世界和你的理解不一样
### 4.2 你的代码为谁而写
### 4.3 你总是在开会吗
### 4.4 可视化，一种更为直观的沟通方式
### 4.5 为什么总是做不好持续集成
### 4.6 开发中的问题一再出现，该怎么办
### 4.7 作为程序员，你应该了解用户
### 4.8 为什么被指责的总是你
### 4.9 写文档做分享也是一种学习方式





## 5. 自动化

### 5.1 懒惰应该是所有程序员的骄傲
### 5.2 构建脚本，让日程开发更简单
### 5.3 程序员怎么学习运维知识
### 5.4 持续交付，一种延伸的持续集成
### 5.5 如何做好验收测试 —— 站在用户的角度看测试
### 5.6 你们的代码是怎么变混乱的 —— 单一职责，划分界限
### 5.7 你真的理解分层吗
### 5.8 总有人觉得 5 万块就能做个淘宝
### 5.9 先做好 DDD 再谈微服务吧


## 6. 综合运用

### 6.1 新入职一家公司改如何快速进入工作状态
### 6.2 面对遗留系统你该如何做
### 6.3 我们应该如何保持竞争力
### 6.4 少做事才能更有效地工作




