# 10x 程序员工作法


软件行业里有一本名著叫《人月神话》，其中提到两个非常重要的概念：本质复杂度 Essential Complexity 和 偶然复杂度 Accident Complexity。**大部分程序员忙碌解决的问题，都不是程序问题，而是由偶然复杂度导致的问题。**如何减少偶然复杂度引发的问题，让软件开发工作有序、高效地进行，这正是本专栏的目的。我会尝试给你提供一个思考框架，帮你在遇到问题时梳理自己真正要做的事情，贯穿这个框架的，有四个原则：**以终为始 任务分解 沟通反馈 自动化**。


## 1. 思考框架

Where are we? 现状  -->  Where are we going? 目标  -->  How can we get there? 实现路径


## 2. 以终为始

### 2.1 让你的努力不白费 <sub>—— 以终为始，一种结果导向的思考方式</sub>

亚马逊开发一项产品，采用后向工作的方法：1.写新闻搞 -> 2.写 FAQ -> 3.写用户文档 -> 4.写代码

### 2.2 你完成了工作，为什么他们还不满意 <sub>—— 什么叫“完成”</sub>

**在做任何事之前，先定义完成的标准。**

Definition of Done
  * 是行业中的一种最佳实践，能够在团队内部很好地同步大家对完成的理解
  * 是**一份由一个个检查项组成的清单**，用来检查我们的工作完成情况，确保不遗漏任何事情
  * 是一种思维模式，是一种尽可能消除不确定性、达成共识的方式

### 2.3 接到需求任务，你要先做哪些事 <sub>—— 用验收标准看需求是否明确</sub>

**在做任何需求或任务之前，先定好验收标准。**

需求，是软件开发中的一个关键环节，一旦需求理解出现问题，势必会造成大量的浪费。传统的功能列表只是简单罗列了要实现的功能，丢失了大量的上下文，会导致团队成员对于需求"只见树木不见森林"。而在比较大的团队中，更是会将一个功能拆分到多个小团队中，每个人看到的只是功能碎片，于是后来产生了其他的需求描述方式，比如用例和用户故事。

很多人学习用户故事，认为最重要的是记住 "As ..., I want to ..., so that ..." 这样的需求描述方式。而在我看来比描述方式更重要的是验收标准。

> **用户故事**
>
> **标题**，简要地说明用户故事的主要内容，如：注册用户使用用户名密码登录  
> **概述**，简要地介绍用户故事的主要内容，一般会用这样的格式：As a (Role), I want to (Activity), so that (Business Value). 如：作为一个注册用户，我想要通过用户密码登录，以便我可以使用注册用户才能够使用的服务  
> **详述**，详细地描述这个用户故事的完整流程，我们会把操作流程、用户界面等信息放到这里  
> **验收标准**，这个部分会描述一个正常使用的流程是怎样的，以及各种异常流程系统是如何给出响应的，这是程序员常常会欠缺的思考。它会把详述中很多叙述的部分变成一个个具体的测试用例。

验收标准非常重要的一环是**异常流程**的描述。大部分程序员都擅长解决正常流程，而异常流程则是最容易忽略的，也是产生扯皮的关键环节。既然容易扯皮，我们就在一开始把它定义清楚。采用用户故事后，我经常在写完了主要流程后，再去看一下验收标准，为自己的开发查缺补漏。因为我知道，那是标准，达不成就不算任务完成。

当我们说自己开发完成可以交给测试人员测试时，我们需要照着验收标准给测试人员演示一遍，证明我们的系统确实能够跑通。这之后，测试人员才会把系统接手过去，做更系统的测试。

验收标准给出了这个需求最基本的测试用例，它保证了开发人员完成需求最基本的质量。如果你了解 BDD 行为驱动开发，就可以按照验收标准中给出的内容编写验收测试用例了。

在实际工作中，许多产品经理把需求交给开发人员之前，很多细节是没想清楚的，那种功能列表式的需求常常只包含了正常路径，那些缺失的细节都是在后续的过程中，由开发人员补全的。用户故事就是一种固定的格式，让产品把这些应该想清楚的问题想清楚。

或许你会有这样的疑问，如果产品经理通过用户故事的方式，将需求实现细节都描绘得清清楚楚，那我们程序员的发挥空间在哪里？请注意，验收标准所给出的实现细节应该是业务上的，我们的发挥空间应该是在技术实现上。

也许你会说，我在一个小公司工作，公司没有专门的产品经理，需求都是老板扔给我们的，谁来帮我们写验收标准呢？没办法，答案只能是你自己。虽然你名义上是程序员，但当拿到一个需求的时候，你要做的不是立即动手写代码，而是扮演产品经理的角色，分析需求，圈定任务范围。相信我，事前分析绝对比你拿一个写好的系统给老板，而他却告诉你这不是他想要的，好太多了。

### 2.4 集成本身就应该是写代码的一个环节 <sub>—— 持续集成</sub>

程序员的交付物不应该是代码，而是一个可工作的软件。把团队中不同成员的代码放到一起，使之成为一个可工作的软件的过程就是集成。集成经历了从 阶段性集成 到 每日构建 再到 持续集成(每次提交都进行集成) 的过程。持续集成的思维让我们认识到，开发和集成可以合二为一。

### 2.5 产品经理不靠谱，你该怎么办 <sub>—— 用精益创业的视角衡量产品特性的有效性</sub>

注: 这里讲的是在产品设计评审时需要注意的情况。排除垃圾需求避免自己做无用功。

产品经理是一个新兴职业。以前的 IT 行业更多的是面向确定性问题，需要的是业务分析师，只有当面向不确定性工作时，产品经理才成为 IT 行业普遍存在的职位。因为新，所以这个职位也没有什么行业标准。所以你会看到很多行业乱象：很多人想进入 IT 行业，一看程序员需要会写代码，觉得门槛高，那就从产品经理开始吧。这些人对产品经理岗位职责的理解是，告诉程序员做什么。没有良好的逻辑性，怎么可能在这个行业中有好的发展？

比较早成型的面向不确定创造新事物的方法论是**精益创业**，它提出了 “(想法 idea) --> 开发 build --> (产品 code)  --> 测量 measure --> (数据 data) --> 认知 learn --> (新想法 idea)” 这样一个**反馈循环**和**最小可行产品 MVP**的概念。当产品经理让我们做一个新的产品特性时，我们可以从精益创业这个实践上得到启发，向产品经理们问一些问题，帮助我们确定产品经理提出的需求确实是经过严格思考的。

### 2.6 解决了很多技术问题，为什么你依然在坑里 <sub>—— 在更大范围内寻找"终"</sub>

在前面的内容中，我给你介绍了几个体现 “以终为始” 原则的实践，包括怎样界定工作是否完成的 DoD、怎样判定需求是否完成的验收标准、还有怎样验证产品经理给出的产品特性是否合理的精益创业理念。了解了这些内容，可能你会想：我为什么要关心这些啊，如果我管了那么多事，我还是不是一个程序员，到底哪里才是我的 "终" 呢? 今天我们就聊一聊这个让许多人困惑的问题。因为只有跳出程序员的角色看问题，工作才会变得更加高效。

程序员总喜欢用技术去解决一切问题，但很多令人寝食难安的问题其实根本不是问题。之所以找不出更简单地解决方案，好多时候原因在于程序员被自己的思考局限住了。

不同角色工作真正的差异在于上下文的差异。在一个局部上下文难以解决的问题，换到另外一个上下文甚至是可以不解决的。所以说无论单点有多努力也只是局部优化，很难达到最优的效果。想把工作做好，就需要不断扩大自己工作的上下文，多了解一下别人的工作逻辑是什么样的，认识软件开发的全生命周期。

**扩大自己的上下文**，除了能对自己当前的工作效率提高有帮助，对自己的职业生涯也是有好处的。随着你看到的世界越来越宽广，得到的机会也就越来越多。

### 2.7 为什么说做事情之前先要推演 <sub>—— 沙盘推演，从军事指挥室里学来的大学问</sub>

无论做的事是什么，那些基本的部分是一样的，差别体现在事前忙还是事后忙。如果只想了功能实现而没考虑过上线，那么上线时会出来一堆问题。

即便已经确定了自己的工作目标，我们依然要在具体动手之前，把实施步骤推演一番，完成一次头脑中的创造。这种思想在军事上称之为沙盘推演，在很多领域都有广泛的应用。

### 2.8 你的工作可以用数字衡量吗 <sub>—— 数字化，一种衡量"终"的方式</sub>

一些人说，自己靠直觉就能把事情做好，其实这是一种误解，因为那种所谓的直觉，通常是一种洞见，洞见很大程度上依赖于一个人在一个领域长期的沉淀和积累，而这其实是某种意义上的大数据。

随着智能时代的来临，人类社会开始逐渐认识到数据的重要性。但我们这群 IT 人在通过数据为其他人服务的同时，却很少把数字化的思维带到自己的工作范围内。这也是工作中很多“空对空”对话的根源所在。结合着"以终为始"的思考，如果我们可以在一开始就设计好测量工作有效性的指标，那么就可以更有目的性地去工作了。而如果我们习惯了用数字去思考，就可以在很多方面让数字帮助我们，如 基于数据进行决策、预先设定系统指标，以及发现系统中的问题等。

### 2.9 启动开发之前，你应该准备什么

在这一讲中介绍了迭代0的概念，它是在正式开发迭代开始之前，进行一些基础准备，以下是一份供参考的准备清单。

在迭代0中将准备工作做好，后续你的一切工作就会变得井然有序，出现的简单问题会很快地被发现，所有人都在一种有条不紊的工作节奏中。

| 大类 | 小类     | 检查项
|----- |---------|-----------------
| 需求 | 功能     | 细化过的迭代需求
| 需求 | 交互     | 用户界面
| 需求 | 交互     | 用户交互
| 技术 | 基础     | 技术选型
| 技术 | 基础     | 技术架构
| 技术 | 数据库   | 数据库表结构
| 技术 | 数据库   | 数据库迁移
| 技术 | 持续集成 | 持续集成服务器
| 技术 | 持续集成 | 持续集成监视器
| 技术 | 持续集成 | 构建脚本
| 技术 | 测试     | 单元测试和集成测试
| 技术 | 测试     | 端到端测试
| 技术 | 发布     | 发布脚本


## 3. 任务分解

### 3.1 将大问题拆解成能够解决的小问题

一个大问题，我们都很难给出答案，但回答小问题却是我们擅长的。所以，当我们学会将问题分解，就相当于朝着问题的解决迈进了一大步。

我们从外星人探索和马斯克的火星探索入手，介绍了任务分解在人类社会诸多方面的应用。

虽然我们很熟悉分而治之的思想，但在日常工作中，我们却没有很好地应用它，这也使得大多数人的工作有很大改进空间。运用这一思想的难点在于，给出一个可执行的分解。一方面，对复杂工作而言，给出一个分解是巨大的挑战；另一方面，面对日常工作，人们更容易忽略的是，分解的任务要可执行。大多数人对于可执行的粒度认识是不足的，只有分解到很小的任务，才容易轻松完成一个开发循环，也让计划调整成为可能。软件行业在倡导拥抱变化，而任务分解是拥抱变化的前提。

### 3.2 开发者测试，程序员工作的一部分

在任务分解模块，我准备从一个让我真正深刻理解任务分解的主题开始，这个主题就是测试。这是一个让程序员又爱又恨的主题，爱测试，因为它能让项目的质量有保证，恨测试，因为测试不好写。而实际上，很多人之所以写不好测试，主要是因为他不懂任务分解。

测试人员只能站在系统外部做功能特性的测试。而一个软件是由它内部诸多模块组成的，测试人员只从外部保障正确性，所能达到的效果是有限的。

在软件开发中有一个重要的概念：软件变更成本，它会随着时间和开发阶段逐步增加。也就是说我们要尽可能早地发现问题，修正问题。“以终为始”就是在强调尽早发现问题。能从需求上解决的问题，就不要到开发阶段。同样，在开发阶段能解决的问题，就不要留到测试阶段。

需求人员要确定验收标准，开发人员则要交出自己的开发者测试。这是一个来自于精益原则的重要思想：内建质量。对于每个程序员来说，只有在开发阶段把代码和测试都写好，才有资格说自己交付的是高质量的代码。

测试框架最大的价值，是把自动化测试作为一种最佳实践引入到开发过程中，使得测试动作可以通过标准化的手段固定下来。

测试类型分：单元测试、集成测试、系统测试等等。越是底层测试，成本越低，执行越快；越是高层测试，成本越高，执行越慢。关于各种测试如何组合时，最佳实践——测试金字塔，强调越底层的测试应该写得越多。当测试数量达到一定规模，测试运行的时间就会很长。一般我们会选择在本地运行所有单元测试和集成测试，而把系统测试放在持续集成服务器上执行。

### 3.3 测试驱动开发，一种设计挑战

一些优秀的程序员不仅仅在写测试，还在探索写测试的实践。有人尝试着先写测试，于是，有了一种实践叫测试先行开发。还有人更进一步，一边写测试，一边调整代码，这叫做测试驱动开发。测试先行开发和测试驱动开发的关键差别就在重构上，TDD 在测试通过之后，要回到代码上，消除代码的坏味道。一旦你有了测试，你就可以大胆地重构了，因为任何修改错误，测试会替你捕获到。在测试驱动开发中，重构与测试是相辅相成的：没有测试，你只能是提心吊胆地重构；没有重构，代码的混乱程度是逐步增加的，测试也会变得越来越不好写。因为重构和测试的互相配合，它会驱动着你的代码写得越来越好。这是对 "驱动" 一词最粗浅的理解。

测试驱动开发已经是行业中的优秀实践，学习测试驱动开发的第一步要记住测试驱动开发的节奏：红 --> 绿 --> 重构。把测试放在前面，还带来了视角的转变，要编写可测的代码，我们甚至需要调整设计，所有有人也把 TDD 称为测试驱动设计。

### 3.4 任务分解，按部就班工作的前提

> **极限编程**
>
> 极限编程之所以叫"极限"，它背后的理念就是把好的实践推向极限：  
> 如果集成是好的，我们就尽早集成，推向极限每一次修改都集成，这就是持续集成  
> 如果开发者测试是好的，我们就尽早测试，推向极限就是先写测试再根据测试调整代码，这就是测试驱动开发  
> 如果代码评审时好的，我们就多做评审，推向极限就是随时随地地代码评审，这就是结对编程  
> 如果客户交流是好的，我们就和客户多交流，推向极限就是客户与开发团队时时刻刻在一起，这就是现成客户

很多人看了一些 TDD 练习觉得很简单，但自己动起手来却不知道如何下手，中间就是缺了任务分解的环节。

Kent Beck 是怎么做的呢？每当遇到一件要做的事，他总会先把它分解成几个小任务，记在一个清单上，然后，才是动手写测试、写代码、重构这样一个小循环。等一个循环完成了，他会划掉已经做完的任务，开始下一个。一旦在解决问题的过程中遇到任何新问题，他会把这个要解决的问题记录在清单上，保证问题不会丢失，然后，继续回到自己正在处理的任务上。当他把一个个任务完成的时候，问题就解决完了。Kent Beck 的做法清晰而有节奏，每个任务完成之后，代码都是可以提交的。

你或许会纳闷，这有什么特别的吗？你不妨回答这样一个问题，你多长时间能够提交一次代码？如果你的答案超过半天，对不起，你的做法步子一定是太大了。你之所以不能小步提交，一定是牵扯了太多相关的部分。

随着我在任务分解上练习的增多，我越发理解任务分解的关键在于 **小**。小到什么程度呢？有时甚至可以小到你可能认为这件事不值得成为一件独立的事，如升级一个依赖的版本，做一次变量改名。这样做的好处是什么呢？它保证了我可以随时停下来。我曾在一本书里读到过关于著名高尔夫球手伍兹的故事。高尔夫球手在打球的时候，可能会受到一些外界干扰。一般情况下，如果他已经开始挥杆，这时受到干扰，一般选手肯定是继续把杆挥下去，但通常的结果是打得不理想。而伍兹遇到这种情况，会停下来重新做挥杆的动作，保证每一杆动作的标准。伍兹能停下来，固然是经过了大量练习，但还有一个关键在于，对于别人而言，挥杆击球是一个动作，必须一气呵成。而对伍兹来说，这个动作是由若干小动作组成的，他只不过是刚好完成了某个小动作，而没有做下一个小动作而已。

**任务分解实战**

将需求分解成一个个任务，每做完一个任务，代码都是可以提交的。

一个最普通的用户登录的需求分解后大概是这个样子的：
* 设计用户信息表
* 数据库迁移选型
* 编写用户信息表的数据库迁移
* 编写 User 对象，包含用户名密码
* 在 UserRepository 中编写 save 方法，保存新创建的 User 对象
* 在 UserService 中编写 register 方法，实现用户注册
* 在 UserResource 中编写 register 方法，调用 UserService 的 register 方法
* 在 UserRepository 中编写 find 方法，根据用户名获取 User 对象
* 在构建脚本依赖中添加 Redis 的依赖
* 编写 UserSession，包含用户名、登录时间和用户 Token 等
* 在 UserService 中编写 login 方法，将 UserSession 放入 Redis 返回 UserSession
* 在 UserResource 中编写 login 方法，调用 userService 的 login 方法，并根据返回的 UserSession 设置 HTTP 头
* 在 UserService 中编写 logout 方法，实现用户退出
* 在 UserResource 中编写 logout 方法，调用 UserService 的 logout 方法
* 在构建脚本依赖中添加 JSON 的依赖
* 在存储到 Redis 时，将对象序列化成 JSON，取出时将 JSON 反序列化成对象
* 编写 AccessFilter，根据待访问地址确定是否进行用户登录信息校验

### 3.5 为什么你的测试不够好

关于测试，我们前面讲了很多，如：开发者应该写测试；要写可测的代码；要想做好 TDD 先要做好任务分解。今天我们再聊聊测试应该写成怎么样，怎么把测试写好。

我看到过很多团队在测试上出现过各种各样的问题，主要原因是因为这些测试不够简单。只有将复杂的测试拆分成简单的测试，测试才有可能做好。

测试的作用是保证代码的正确性，那谁来保证测试的正确性？既然无法用写程序的方式保证测试的正确性，那只剩一个方法：把测试写简单，简单到一目了然，不需要证明它的正确性。测试中应该规避以下常见问题：一个测试做了太多事情；测试没有断言；测试里有判断语句...

怎么衡量测试是否做好了呢？有一个标准：A-TRIP，这是五个单词的缩写，分别是：

* Automatic 自动化：把测试尽可能交给机器执行，人工参与的部分越少越好
* Thorough 全面：应尽可能覆盖各种场景：正常的、异常的、各种边界条件；应尽可能覆盖所有的代码和分支
* Repeatable 可重复：某一个测试反复允许，结果应该是一样的
* Independent 独立：测试和测试之间不应该有任何依赖
* Professional 专业：测试代码也是代码，要符合代码编写规范

### 3.5 程序员也可以砍需求吗

如果你对需求的管理粒度就是主题，那好多事情就没法谈了。比如，时间紧迫的时候，我想砍需求，你问产品经理，我不做登录行不行，你就等着被拒绝吧。但是，如果你说时间比较紧，我能不能把登录验证码放到后面做，或是邮件地址验证的功能放到后面，这种建议产品经理是可以和你谈的。这其中的差别就在于，后者将需求分解了。

评价用户故事有一个 **INVEST 原则**(Independent 独立 Negotiable 可协商 Valuable 有价值 Estimatable 可估算 Small 小 Testable 可测)，其中一个关键点是 "小"，只有小的需求才方便管理和调整。

### 3.6 太多人给你安排任务，怎么办

按照时间管理的理念，重要且紧急的事情要立即做。重要但不紧急的事情应该是我们重点投入精力的地方。紧急但不重要的事情，可以委托别人做。不重要不紧急的事情，尽量少做。这个矩阵带给我们思维上最大的改变是，让人意识到事情和事情不是等价的。如果不把精力放在重要的事情上，到最后可能都变成紧急的事情。把这个思路带回到我们现实的需求管理中，你会发现，其实团队面临的各种需求所采用的优先级排序方式，基本上都是按照紧急程度排列的，但它们是否真的重要呢？

需求分解之后，最重要的是，排列需求的优先级。优先级的排列方式有很多，我们可以借鉴时间管理的方法，把事情按照重要和紧急的维度进行划分，得到了四个象限。我们要尽可能把精力放在重要的事情上，而不是把紧急的事情当成优先级排序的方式。

需求分解成一个个小块，其实也分解了原本合一的上下文。如果想要有效地管理需求，尤其是确定事情的重要程度，一种方式是找回丢失的上下文。如果我们自己无法判断上下文，一种好的办法是，引入外部更大的上下文(话外音：跟产品谈不好一起找老板)。

### 3.7 用最小的代码做产品

前面我们讲了开发任务的分解和需求管理的分解，这些都是针对“已经确定好要做的事情”的分解策略，今天我们再上一个台阶，聊聊面对那些不确定的产品功能该如何分解。

什么叫最小可行产品？就是“刚刚好”满足客户需求的产品。客户需求好理解，怎么算“刚刚好”呢？其中的关键在于理解“最小”和“可行”。

#### 最小的代价

最小的代价，就是能不做的事情就不做，能简化的事情就简化。

首先，我们必须清楚一件事，我们要做的是验证一个想法的可行性，甚至不是为了开发一个软件，开发软件只是一种验证手段。很多程序员都会有一个认识上的误区，容易把解决方案当做问题。我们开发软件的目的是为了解决问题，如果不写软件就把问题解决了，岂不是更好。

有一次，有一个朋友找我帮忙，他手头有一些制造业的客户，想做一个物联网相关的项目，帮助这些客户改造设备，实现物联网功能。该怎么着手呢？把软件写好，给客户试用吗？这样时间太长，成本太高。那么，我们是怎么做的呢？

第一步，我们要验证这样一个想法是否可行。我们做了一个产品文档，就好像我们已经有了这个产品一样，让负责销售的同事拿着这个文档给客户讲讲，看看客户对这个想法的反映。在这个过程中，我们验证了基本的想法，已有设备进行物联网化改造的需求存在，客户看到了这样的一个东西，各种各样的想法和要求就会冒出来。此外，我们还获得了一个额外的收获，我们知道了客户对于这样一个产品能够接受的价格区间，这可以帮助团队给产品进行适当的定价。

验证了方向上的想法，我们开始进入到具体的产品设计阶段。这个阶段我们想验证的是，我们给出的产品设计用户是否可以接受。于是，我们决定把这个产品的交互做出来。得益于原型工具的快速发展，我们用一个原型工具做出了相对完整的用户界面，而且把各种交互流都做出来了。在用户看来，这几乎就是完整的软件了。他们甚至可以在自己的设备上体验一下这个产品用起来是什么感觉的。一旦上手用起来，他们就会抛出各种细节的问题：如果这样就好了，如果能做到这个就太棒了。当然，他们也会说，这个东西我不需要。这个时候，我们就可以知道，我们在产品上的假设哪些是好的，哪些是不流畅的。团队拿到这些反馈，就可以再调整产品设计，然后，再给到用户去测试，如此反复进行。有的时候，产品会在一天之内改好几个版本。

经过多轮测试下来，团队有了一大堆的用户反馈，而且是来自真实用户的反馈。接下来，就是整理这些用户反馈，决定哪些可以真正的开发出来，这时候，团队才真正进入到开发阶段。

不知道你注意到了没有，迄今为止，这个团队验证了一大堆的想法，而代码却是一行都没有写，所有花费的工作量都是有针对性的验证。开发软件是一件成本很高的事情。如果只是验证想法，无论是创业方向，还是产品设计，我们可以找到各种各样的手段，不用写代码。

#### 可行的路径

我再给你分享一个我当年做 P2P 项目经历。这是一个从头开始的项目，项目方和所有的项目方一样，希望昨天这个项目就上线了，如果不能，那就尽快上线一个版本。他们给我们一个时间线，第一个上线的版本是一个月之后。摆在我们面前的问题是，无论如何，在一个“一穷二白”的基础上，要在一个月内完成一个完整的借贷平台是不太可能的。时间有限，我们只能做最基本的东西，许多运营上的想法，比如，发红包代金券之类的，第一期一律不做。即便如此，我们仍然认为完成完整的借贷循环是不现实的。于是，我们就开始从需求完整性的角度动脑筋。这是一个借贷系统，其最基本的模型是：贷款方贷款之后，一次性拿到所有的钱，然后用等额本息的方式每个月还款，最后一个月剩多少钱一次性全还了。我们在这个模型中找到了一个关键点，每个月还款。换句话说，第一笔贷款发生之后，最早的一笔还款是发生在一个月之后的。于是，我们做了一个决定，第一个版本只包含贷款能力。是的，这个版本只能贷款，不能还款。因为用户一个月之内不会用到这个功能，你从页面上，完全看不出这样的能力缺失，因为一个月内，根本没有任何用户有可还的款项。因为缩减了项目规模，我们在预期的一个月内完成所有开发，成功地把项目送上了线。第一批早期用户就开始了使用。从用户的视角看，这是一个功能完整的项目，虽然简单了点，但它是完整的。当然，我们把还款排到了下一期。按照我们两周一迭代的节奏，在第一期上线两周之后，我们就会上线还款功能，届时贷款方将拥有一个真正的还款功能。不过，这个还款功能只是每期的等额本息还款，最后的一次性还剩余所有贷款的功能，我们依然是不支持的。因为根据需求设计，最后一次还款最早发生在一年之后。

在我们把基本的功能全部送上线之后，这个系统就是一个真正的、完整的借贷平台了。但是，相对于其他提供相同能力的平台而言，这个系统依然还是很简单。比如，常见的运营功能、短期借贷计划，这个平台都没有。但我们有了基础，接下来，就是在基础上叠加，而且随着项目方自己团队的构建，我们拥有了够大的团队，可以同时做几个大需求了。就这样，几个月之后，我们就逐步上线了一个功能相对完整的 P2P 平台。在这个过程中，我们每个阶段都会上线新功能，从用户可见的角度，他看到的始终是一个完整的平台，其中的变化只有站在内部实现者的角度才能看得清楚。

和大家分享这个例子，主要是想破除大家对于一个“完整”系统概念的认识。当时间有限时，我们需要学会找到一条可行的路径，在完整用户体验和完整系统之间，找到一个平衡。


## 4. 沟通反馈

### 4.1 为什么世界和你的理解不一样

为什么我们对世界的理解会出现偏差？信息的传达要经过编码和解码两个过程，无论是编码还是解码出现问题，都会造成信息的不准确。因为每个人经历见识的差异，造成了各自编解码器的差异。

改善编解码，需要从几个角度着手，分别是：编码器，让信息能输出更准确；解码器，减少信号过滤，改善解码能力；还有编解码算法，也就是各种来自行业的“最佳实践”，协调沟通的双方。

很多程序员讲东西都有一个通病：讲东西直奔细节，完全没有背景介绍。

### 4.2 你的代码为谁而写

### 4.3 你总是在开会吗

#### 头疼的开会

开会是为了解决问题，但真实情况却是开了会又没有解决多少问题，这真是一个奇特的矛盾。

在我的职业生涯中，凡是效果特别好的会议，基本上都是用来做信息同步的，比如领导宣布一个事情，宣布消息，大家收到消息，结束。那效果不好的会议室什么样的呢？几乎都是那些讨论会，你一言我一语，每个会都有几个擅长打岔的，这个会基本上都会跑偏，开会是一种重量级的沟通，用开会这种重量级的方式讨论问题，就好比杀鸡用了牛刀。

#### 轻量级沟通

实际上，真正在会议上能够积极参与讨论的人并不会觉得会议是浪费时间，因为高度参与其中，人是进入到心流状态的，时间流逝很快。觉得浪费时间的，往往是没有参与其中的人。换句话说，会议之所以给人留下如此不堪的印象，一个重要的原因是，真正参与讨论的人并不多。所以，我们换个角度思考一下，只要把这些真正参与讨论的人拉到一起讨论不就好了？所以，**改善会议的第一个行动项是，减少参与讨论的人数。**

有人会说，我这个讨论有好几个议题，每个议题要不同的人参与，那你要做的是，分别找这几个人专门讨论，而不是把大家放到一起。相比于会议的形式，面对面沟通议题小，参与人数不多，每个人的投入也会更多一些。所以，我们的第二个行动项是，**如果你要讨论，找人面对面沟通。**

一旦理解了这些改进方式，我们就可以改进自己的行为方式。如果有一个问题需要讨论，我要做的是，分别找到相关人针对关心的主题进行讨论，然后，我把讨论的结果汇总再去征求大家意见。如果大家达成一致了，我才会选择开会。这个时候，开会的目的不再是讨论，而是信息同步：我准备这么干了，相关各方已经同意了，知会大家一下，结束。

#### 站立会议

开会并非都是不好的，一些信息同步的会还是有必要的。有一种实践叫站会，很多工作都在实践它，站会甚至成为每天的开工仪式。

* 站会不超过 10 分钟
* 每个人的发言只说三件事：我昨天做了什么，今天打算做什么，过程中遇到了什么问题需要请求帮助(不展开、具体会后讨论)
* 当团队很大时，应该把团队拆分，5-12 人是一个恰当的团队规模

站会应该避免走入一些误区

* 每个人的发言要尽量简短，一旦一个人说多了，跟你关系不大，你就开始思维发散了
* 还有一个典型的错误是，把站会开成了汇报会，说的人都向负责人在汇报工作，其他人自然就走神了

#### 总结

如果你想用会议的形式与别人讨论问题，最好放弃这种打算，面对面的沟通是最好的方式。因为面对面沟通很轻，人数相对少，每个人参与度就会高很多。基于这种改进，我们可以把大部分会议都改成信息同步的会，效率就会得到提高。

### 4.4 可视化，一种更为直观的沟通方式

**多尝试用可视化的方式进行沟通**

就人脑的进化而言，处理图像的速度远远快于处理文字，所有有一图胜千言的说法。通过创建图像、图标或动画进行信息交流的形式，就是可视化。可视化有很多种不同的分类，我们最常用的应该是数据可视化和信息可视化。

大多数软件过程习惯采用文字的方式进行表达，对于"可视化"利用的还不够。当然，还是有一些利用"可视化"的方法，比如 流程图 UML 等。

利用可视化进行信息沟通的实践：看板。看板把工作分成了几个不同的阶段，在看板上对应不同的列，然后，每个任务作为一张卡贴在上面，每完成一张卡，就把这张卡挪到下一个阶段。看板可以帮助你发现很多问题，如当前进展是否合适，是否有人同时在做很多的事，发现当前工作的瓶颈等。

### 4.5 如何做好持续集成

很多人把 CI 服务器 Jenkins 理解成了持续集成。我曾接触过这样的团队，他们恨不得把所有的事情都放在 CI 服务器上做：编译、代码检查、单元测试、测试覆盖率统计等等。这种做法不是不可行，但不是最佳实践。

持续集成的诞生，就是人们尝试缩短集成周期的结果。为什么要缩短周期呢？因为我们希望尽早得到反馈，知道自己的工作结果是否有效。所以，想要做好持续集成，就需要顺应持续集成的本质：**尽快得到工作反馈**。

...对比之下，在本地运行这些检查，你不需要提交，不需要等 CI 服务器开始执行，不需要跑到额外的地方查看检查结果。所以这个操作比提交到服务器上会快很多。另外，这里还有一个关键点，我们的操作是连续的。一旦检查结果出错了，我们立刻进入修复环节。作为程序员，我们太了解连续操作的重要性了。

使用 CI 服务时，及时得到反馈并采取行动也是一个重点。用邮件通知显然太慢了，我们需要持续集成监视器。市面上有很多 CI 监视器软件，有的是做视觉呈现，有的是做桌面通知。CI 服务器一旦检查出错要立即修复，因为你不修，别人就不能提交，整个团队的工作流就会被打断。

### 4.6 开发中的问题一再出现，该怎么办

**定期复盘，找准问题根因，不断改善**。

#### 回顾会议

如果在开发过程中，同样的问题反复出现，说明你的团队没有做好复盘。复盘，就是过程还原，进行研讨与分析，找到自我改进方法的一个方式。这种方式使我们拥有了客体化的视角，能够更客观地看待曾经发生过的一切。在软件开发中，一个重要的复盘实践是 **回顾会议**。

定期回顾是一个团队自我改善的前提，回顾会议怎么开呢？

1. 作为组织者，我会先在白板上给出一个主题分类。我常用的是分成三类：“做得好的、做得欠佳的、问题或建议”。
2. 然后，我会给与会者五分钟时间，针对这个开发周期内团队的表现，按照分类在便签上写下一些事实。这里面有两个重点。一个是写事实，不要写感受。因为事实就是明摆在那里的东西，而感受无法衡量，你感觉好的东西，也许别人感觉很糟糕。另外，每张便签只写一条，因为后面我要对便签归类。因为大家是分头写的，有可能很多内容是重复的，所以，要进行归类。
3. 五分钟之后，我会号召大家把自己写的便签贴到白板上。等大家把便签都贴好了，我会一张一张地念过去。这样做是为了让大家了解一下其他人都写了些什么，知道不同人的关注点是什么。一旦有哪一项不清楚，我会请这张便签的作者出来解释一下，保证大家对这个问题的理解是一致的。在念便签的同时，我就顺便完成了便签归类的工作。等到所有的便签都归好类，这就会成为后续讨论的主题，与会者也对于大家的关注点和看到的问题有了整体的了解。做得好的部分，是大家值得自我鼓励的部分，需要继续保持。而我们开回顾会议的主要目的是改善和提升，所以，我们的重点在于解决做得不好的部分和有问题出现的地方。
4. 在开始更有针对性的讨论之前，我会先让大家投个票，从这些分类中选出自己认为最重要的几项。我通常是给每人三票，投给自己认为重要的主题。每个人需要在诸多内容中做出取舍，你如果认为哪一项极其重要，可以把所有的票都投给这个主题。根据大家的投票结果，我就会对所有的主题排出一个顺序来，而这就是我们要讨论的顺序。我们不会无限制的开会，所以，通常来说，只有最重要的几个主题才会得到讨论。无论是个人选择希望讨论的主题，还是团队选择最终讨论的主题，所有人都要有“优先级”的概念在心里。然后，我们就会根据主题的顺序，一个一个地进行讨论。
5. 讨论一个具体的主题时，我们先会关注现状。我会先让写下反馈意见的人稍微详细地介绍他看到的现象。比如，测试人员会说，最近的 Bug 比较多，相比于上一个开发周期，Bug 增加了 50%。然后，我会让大家分析造成这个现象的原因。比如，有人会说，最近的任务量很重，没有时间写测试。
6. 再下来，我们会尝试着找到一个解决方案，给出行动项。比如，任务重，我们可以让项目经理更有效地控制一下需求的输入，再把非必要的需求减少一下；测试被忽略了，我们考虑把测试覆盖率加入构建脚本，当测试覆盖率不足时，就不允许提交代码。请注意，**所有给出的行动项应该都是可检查的**，而不是一些无法验证的内容。比如，如果行动项是让每个程序员都“更仔细一些”，因为“仔细”这件事很主观，你说程序员不仔细，程序员说我仔细了，这就是扯皮的开始。而我们上面给出的行动项就是可检查的，项目经理控制输入的需求，我们可以看每个阶段开发的总点数是不是比上一个阶段少了。而测试覆盖率更直接，直接写到构建脚本中，跑不过，不允许提交代码。
7. 好，列好了一个个的行动项，接下来就是找责任人了，责任人要对行动项负责。比如，项目经理负责需求控制，技术负责人负责将覆盖率加入构建脚本。有了责任人，我们就可以保障这个任务不是一个无头公案。下一次做回顾的时候，我们就可以拿着一个个的检查项询问负责人任务的完成情况了。

#### 5 Why 分析法

无论哪种做法，分析问题，找到根因是一个重要的环节。**5 Why 分析法** 就是一个常用的找到根因的方式。需要注意的是，问题是顺着一条主线追问，不能问 5 个无关的问题。

服务器经常返回 504，那我们可以采用 5 Why 的方式来问一下：

* 为什么会出现 504 呢？因为服务器处理时间比较长，超时了。
* 为什么会超时呢？因为服务器查询后面的 Redis 卡住了。
* 为什么访问 Redis 会卡住呢？因为另外一个更新 Redis 的服务删除了大批量的数据，然后，重新插入，服务器阻塞了。
* 为什么它要大批量的删除数据重新插入呢？因为更新算法设计得不合理。
* 为什么一个设计得不合理的算法就能上线呢？因为这个设计没有按照流程进行评审。

### 4.7 作为程序员，你应该了解用户
### 4.8 为什么被指责的总是你
### 4.9 写文档做分享也是一种学习方式





## 5. 自动化

### 5.1 懒惰应该是所有程序员的骄傲
### 5.2 构建脚本，让日程开发更简单
### 5.3 程序员怎么学习运维知识
### 5.4 持续交付，一种延伸的持续集成
### 5.5 如何做好验收测试 —— 站在用户的角度看测试
### 5.6 你们的代码是怎么变混乱的 —— 单一职责，划分界限
### 5.7 你真的理解分层吗
### 5.8 总有人觉得 5 万块就能做个淘宝
### 5.9 先做好 DDD 再谈微服务吧


## 6. 综合运用

### 6.1 新入职一家公司改如何快速进入工作状态
### 6.2 面对遗留系统你该如何做
### 6.3 我们应该如何保持竞争力
### 6.4 少做事才能更有效地工作




