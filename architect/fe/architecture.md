# 前端架构 <sub>从入门到微前端</sub>


## 前端架构

架构往往都是在一定的约束条件下设计出来的。没有一种架构能满足未来的需求，架构是需要持续迭代优化的。

软件开发的过程就好比盖房子...

### 收集架构需求

1. 了解相关利益人的利益

架构并非完全从技术角度来考虑问题，它需要从多方的利益出发
* 产品或业务负责人(PO)，关心是否能按时上线
* 项目经理，根据架构来决定项目计划和项目人选
* 架构师、开发人员，关心系统的构建、演进及维护
* 业务分析人员，关心如何分配和安排项目的迭代计划
* 测试人员，设计合理的测试计划，如对系统集成部分的测试等

2. 寻找架构关注点

* 性能
* 安全
* 平台化
* 代码维护
* 用户体验

3. 明确跨功能需求

* 浏览器的支持范围
* 移动端设备支持的版本

4. 罗列技术风险点

* 技术风险
* 第三方系统集成
* 受限制的线上运行环境

### 1.2.2 架构模式(风格)

和设计模式一样，架构风格可以体现架构的一致性，提高人们对架构的可理解性。

应用的软件架构并非是凭空想象出来的，它们往往是在实践的基础上总结出来的。

常见的前端架构风格有

* 分层风格，这是最常见的架构风格，它将系统按照水平切分的方式分成多个层。
* MVC 风格，这种风格应用得相当广泛，它强调职责分离。当涉及图形界面是往往都有它的身影。
* 发布——订阅风格，这种风格又可以称为基于事件的架构风格。
* 管道和过滤器，这是一种适合于处理数据流的架构模式。

### 1.2.3 架构设计方法

前端架构可以通过层次设计的方式来进行，即由顶至底进行一层层的技术决策，再由底至顶逐层验证方案的可行性。

1. 4+1视图法

从4个不同的维度来考虑软件技术的设计：逻辑架构、开发流程、部署架构、运行时

2. TOGF 及 ADM

### 1.2.4 生成架构产出物

* 架构图：说明整个系统是如何构成的，以及各个部分之间的关系
* 迭代计划：按照业务和技术的要求，按时间顺序排列出项目的实施计划
* 技术栈及选型：确定项目中使用的语言、框架、库等相关的技术栈，以及相应的依赖等
* 示例代码：在这些代码中展示架构的风格及相应的设计规范
* 测试策略：明确项目的测试类型、测试流程，以及相应的人员在哪些层级进行测试
* 部署方式


### 1.3 架构设计原则

* 不多不少：不做多余的设计，也不缺少关键的部分
* 演进式：不断地演进以使架构适应当前的环境
* 持续性：长期的架构改进比什么都重要

如对于前端开发而言，为了将来在内部开发自己的组件库，当前可以通过适配者、代理模式对第三方组件进行二次封装。

适应环境能够生存下来的物种，并不是那些最强壮的，也不是那些最聪明的，而是那些对变化做出快速反应的。 —— 达尔文

“先上线，后解决问题”才是真理。

### 1.4 前端架构发展史

随着单页面应用的流行，前后端分离架构也成为行业内的标准实践。
* API 管理，采用了诸如 Swagger 的 API 管理工具，各式的 Mock Server 也成为标准实践
* 大前端，由前端来开发跨平台移动应用框架
* 组件化，前端应用从此由一个个细小的组件结合而成，而不再是一个大的页面

系统变得越来越复杂，架构在前端的作用也变得越来越重要。MVC满足不了开发需求，于是采用了组件化架构。而组件化 + MV* 也无法应对大型的前端应用，微前端便又出现在我们的面前，它解决了以下问题
* 跨框架。在一个页面上运行，可以同时使用多个前端框架
* 应用拆分。将一个复杂的应用拆解为多个微小的应用，类似于微服务
* 遗留系统迁移。让旧的前端框架可以直接嵌入现有的应用运行

### 1.5 前端架构设计：层次设计

前后端分离架构其实是一个笼统的概念，它是指前后端分离如何实施的技术决策。它包含了一系列的决策、用户鉴权、API接口管理与设计、API(契约)文档管理、MockServer使用、BFF(服务于前端的后端)、是否需要服务端渲染等。

当在一个系统内时，微前端是一个应用间的架构方案，当在多个应用间时，微前端则是一种系统间的架构方案。


## 7 组件化架构

组件化架构于 MV* 架构是现今前端应用的基本架构，它们往往相互结合，以用于降低 Web 应用的复杂度——将应用中的部分复杂度，由应用程序转移向组件库(模式库)。

* 风格指南，侧重于设计。其在设计的实现是定义 UI 规范，其在前端的实现则是通过 CSS 框架来体现。
* 模式库，侧重于前端开发。其重点是 *基础组件、复合组件及业务组件* 的相互结合。
* 设计系统，结合风格指南与模式库，加强了模式和原则的运用。


## 8 前后端分离架构

### 8.1.3 API 设计


API 与安全
* Token 管理。对于前端来说，只是在遇到 401 未授权时进行相应的逻辑处理。通常我们要借助于 HttpInterceptor 进行全局统一的非法授权处理。
* 表单校验。前端进行表单校验往往是出于用户体验的目的。后端进行校验时默认前端是不可信的。
* 权限管理。

### 8.4 服务于前端的后端 BFF

很多业务逻辑放在前端或放在后端处理，并没有太大的区别。一个简单的共识是，如果多端都需要一个计算，那么应该由后端提供。

我们真的需要 BFF 吗
* 是否需要提供多个接口，来适应不同的客户端
* 是否需要针对某一特定客户端，进行后端接口优化
* 是否需要为第三方提供 API
* 是否存在大量的后端服务需要聚合
* 是否需要为客户端进行业务逻辑处理

API Gateway (API 网关) 是一个位于前端与后台服务之间的代理，也是后台服务的唯一入口。它将请求由客户端路由到对应的服务，并执行身份验证、监控、负载均衡等任务。BFF 会根据业务逻辑进行编码，而 API Gateway 只做数据转发，不做额外的数据。因此从某种程度上来说，BFF 是一种高级的 API Gateway。

#### 8.4.2 前端如何实现 BFF

由 Node.js 来实现 BFF 层几乎是前端的第一选择。前端开发人员可以选择合适的 Web 框架(如 Koa Express Egg.js)来打造 BFF，也可以使用更合适的 GraphQL 来完成。

#### 8.4.3 使用 GraphQL 作为 BFF

优势
* 按需获取。客户端可以按自己的需要从服务端获取已定义好的资源，而不需要进行 BFF 相关编程。
* 代码即文档。与参数相比，GraphQL 编写的查询语句更像是一份文档，适合人类阅读。
* 易于使用的 API 调试工具。多数 GraphQL 实现都能提供一个开发用的前端调试 API 界面。
* 强类型的  API 检查。面向前端的接口都有强类型的 Schema 做保证，能快速地定位问题。
* 易于版本化的 API。其可以通过 Schema 扩展 API，而 REST 则需要通过 URI 或 HTTPHeader 等来接收版本。

缺点
* HTTP 请求无法被缓存
* 错误码处理不友好。GraphQL 统一返回 200，在其中对错误信息进行包装。
* 学习成本。使用 GraphQL 就要学习一门查询语言，同时还需要写一大堆 Schema 才能使用。
* 实现复杂。需要开发人员编写 Schema 声明，手动编写 Resolver 来关联字段。一旦遇到复杂的场景，就会难以控制。

相比之下，很难在常规的 BFF 和 GraphQL 中做出选择。如果业务一直在变动，或者需要对外提供 API，选择 GraphQL 更合适。而如果业务变动不频繁，或者客户端数据量少，那么使用 BFF 也可以。

GraphQL API 的强类型特性也非常适合模拟 MockServer 的存在。同时，结合测试框架 Jest + Relay 便可以进行快照 Snapshot 测试。


## 9 微前端架构

* 应用自治。多个应用组件之间不存在依赖关系。
* 单一职责。前端面向最终用户，需要保证用户体验的连续性，要实现单一职责并不像微服务那么容易。
* 技术栈无关。在后端微服务架构中，技术栈无关是一个相当重要的特性，可以选用合适的语言和框架来开发，服务之间使用 API 通信即可。

### 9.1.2 为什么需要微前端

* 遗留系统迁移。解决遗留系统才是人们采用微前端方案最重要的原因。对于已经在线上稳定运行的、又没有新功能的应用，尽量不重写，而是直接整合到新的应用中去。
* 后端解耦，前端聚合。在大型组织机构里，采用微服务的主要原因是使用微服务架构解耦服务间的依赖。而在前端微服务化上则恰恰相反，人们更想要的是 *聚合前端应用*，尤其是 toB 项目。最近几年，移动应用出现了一种趋势，即用户不想装那么多应用了。

### 9.2 微前端的拆分方式

* 路由分发式。通过 HTTP 服务器的反向代理功能实现，或者通过应用框架自带的路由来解决。
* 前端微服务化。
* 微应用
* 微件化。
* 前端容器化。将 iframe 作为容器来容纳其他前端应用。
* 应用组件化。借助 Web Components 技术来构建跨框架的前端应用。

### 9.5 微前端的架构模式

从微前端应用间的关系来看分为两种：基座模式(管理式)、自组织式，分别对应两种不同的架构模式
* 基座模式。通过一个主应用来管理其他应用。设计难度小、方便实践，但是通用度低。
* 自组织模式。应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高。

不论哪种微前端方式，都需要一个应用注册表的服务，它可以是一个固定值的配置文件，或者是一个可动态更新的配置服务。它主要做以下事情
* 应用发现。让主应用可以寻找其他应用。
* 应用注册。即提供新的微前端应用，向应用注册表注册新应用。
* 第三方应用注册
* 访问权限等相关配置

#### 9.5.1 基座模式

在基座模式的微前端架构中，基座承担了微前端应用的基础与技术核心。基座模式，是由一个主应用和一系列业务子应用构成的系统，并由这个主应用来管理其他子应用，包括从子应用的生命周期管理到应用间的通信机制。


基座模式中的主应用，类似于 API Gateway 的概念，它作为系统的统一入口，负责将对应的请求指向对应的服务。这个主应用既可以只带有单纯的基座功能，也可以带有业务功能。它所处理的业务功能指的是核心部分的业务功能，如
* 用户的登录、注册管理
* 系统的统一鉴权管理
* 导航菜单管理
* 路由管理
* 数据管理
* 通信代理
* 维护应用注册表
* 管理其他子应用

要实现这种模式的微前端架构，只需要设计好对应的应用加载机制即可，因此在实施的时候也比较方便。










