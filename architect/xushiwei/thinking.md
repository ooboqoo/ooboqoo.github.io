# 架构思维


工程师思维可能是个坑，太强调逻辑而让系统变得庞杂，并且很容易陶醉于那些酷炫的功能。
而技术创业另一个失败率比较高的原因，可能就是情商相对较低。
商业的本质是成就别人，而七牛云希望成就的对象，则是企业（2B）。
许式伟还觉得，人工智能某种程度上已经出现了，只不过，智能并非存在于某一台机器当中，而是体现在互联网这个整体之中。当每一家企业通过互联网连接在一起之后，这些企业就变成了一个个的节点，企业在不断迭代，就像细胞在不断更新，让整张网络有了自我演进的功能，也演进出了越来越丰富的“人工智能”。

## 67 回顾与总结

<image src="xushiwei/images/c5.webp" width="663" />

架构设计，设计为先，架构为魂。用架构的系统化和全局性思维来做设计。

从技能来说，我们可能把 *架构师能力* 归结为：*理需求* 的能力，*读代码* 的能力，*抽象系统* 的能力。

但架构师的成长之旅，首先是 *心性修炼* 之旅，这包括
* *同理心* 的修炼，认同他人的能力
* *全局观* 的修炼，保持好奇心和学习的韧性
* *迭代能力* 的修炼，学会反思，学会在自我否定中不断成长

### 业务的正交分解

*架构就是业务的正交分解*。每个模块都有它自己的业务。这里的模块是一种泛指，它包括：函数、类、接口、包、子系统、网络服务程序、桌面程序等。

正交分解是一切架构动作的基础。架构行为的三部步曲：需求分析、概要设计、模块的详细设计，背后都直指业务的正交分解，只是逐步递进。

对业务进行分解得到的每一个模块来说，最重要的是 *模块的边界*，我们通常称之为 *接口*。接口是业务的抽象，同时也是它与使用方的耦合方式。

在架构分解过程中有两大难题：需求交织 + 需求易变。

业务分解就是最小化核心系统，加上多个正交分解的周边系统。*核心系统一定要最小化，要稳定*，坚持不往核心系统中增加新功能，这样你的业务架构就不会有臭味。

做业务的正交分解的第一件事情，就是要分出哪些是核心系统，哪些是周边子系统。核心系统构成了业务的最小功能集，而后通过不断增加新的周边功能，而演变成功能强大的复杂系统。

### 领域理解

应对业务需求的变化，最好的结构就是：最小化的核心系统 + 多个彼此正交的周边系统。

但是光理解了这一点，并不足以根本性地改变你的架构能力，因为这里面最难的是领域理解。所以需求分析很关键。怎么做需求分析？这一点要讲透真的很难。我们用的是笨方法。把整个信息科技的演进史讲了一遍。整个信息科技的发展，我们把它分为 *程序驱动和数据驱动* 两个阶段。程序驱动的本质，是自动化的极致。

我们的架构课，把话题收敛到了 “如何把软件跑起来，并保证它持续健康运行” 这件事情上。

### 结语

架构的功夫全在平常。无论是在我们架构范式的不断完善上，还是应对架构老化的经验积累上，都是在日常工作过程中见功夫。我们不能指望有一天架构水平会突飞猛进。架构能力提升全靠平常一点一滴地不断反思与打磨得来。





## 58 如何判断架构设计的优劣

组合优于继承
* *组合是乘法*，用相互正交、完全没有相关性的模块组合出我们要的业务场景
* *继承是加法*，通过叠加能力把一个模块改造成另一个模块



## 59 少谈框架多谈业务

架构就是业务的正交分解，每个模块都有它自己的业务。

模块的接口是架构设计的核心

最有效的方法是在概要设计（也叫系统设计）阶段就把框架代码写出来，真正用代码把用户故事串一遍。这样做的好处是，我们把联调工作做到了前头，工程的最大风险就得到了管理。剩下的就是每个模块自身的好坏，和组织能力无关，只取决于招聘的工程师个体素质了。

在架构的两侧，一边是用户需求，一边是技术。接口代表用户需求，代表业务；框架代表技术，是我们满足需求的方法。在系统迭代的过程中，框架会经常变化来适应需求的演进过程。抓住稳定的东西比追逐变化更重要。


我个人经常给架构师们说的一句话是：*重要程度：接口 > 数据结构 > 框架(架构图)*。

## 61 全局性功能的架构设计

架构的本质是业务的正交分解。

架构分解中有两大难题
* 需求的交织。不同需求混杂在一起，也就是存在所谓的全局性功能
* 需求的易变。不同客户，不同场景下的需求看起来很不一样，场景呈发散趋势


业务分解就是最小化的核心系统，加上多个正交分解的周边系统。

无论如何，我们需要坚持作为一名架构师的信仰：任何功能都死可以正交分解的，即使我目前还没有找到方法。

## 62 重新认识开闭原则

> 重新认识开闭原则
> * 模块的业务要稳定，遵循 *只读* 原则
> * 模块业务的变化点
>   - 简单一点的，通过 *回调函数* 或 *接口* 交给其他业务模块
>   - 复杂一点的，引入 *插件机制* 把系统分解为 “最小化的核心系统 + 多个彼此正交的周边系统”

就架构的本质而言，我们核心要掌握的架构设计的工具其实就只有两个
* 组合。用小业务组装出大业务，组装出越来越复杂的系统
* 如何应对变化（开闭原则）

开闭原则：软件实体（模块、类、函数等）应该对于功能扩展是开放的，但对于修改是封闭的。
一个软件产品只要在其生命周期内，都会不断变化。我们应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性，真正实现“拥抱变化”。

开闭原则告诉我们，应尽量通过扩展软件实体的行为来应对变化，满足新的需求，而不是通过修改现有代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。

我个人非常推崇“开闭原则”，它背后所隐含的架构哲学，和我说的“架构额本质是业务的正交分解”一脉相承。

与其修改模块的业务，不如实现一个新业务。只要业务的分解一直被正确执行的话，实现一个新的业务模块来完成新的业务范畴，是一件极其轻松的事情。从这个角度来说，开闭原则鼓励写 *只读* 的业务模块，一经设计就不可修改，如果要修改业务就直接废弃它，转而实现新的业务模块。

### CPU 背后的架构思维

冯·诺依曼体系的中央处理器（CPU）的设计完美体现了 “开闭原则” 的架构思想。它表现在：
* 指令是稳定的，但指令序列是变化的，只有这样计算机才能够实现 “解决一切可以用 ‘计算’ 来解决的问题” 这个目标。
* 计算是稳定的，但数据交换是多变的，只有这样才能够让计算机不必修改基础架构却可以适应不断发展变化的交互技术革命。

### 插件机制

一般来说，提供插件机制的二次开发接口需要包含以下三个部分
* *软件自身能力的暴露*，也就是我们经常说的 DOM API
* *插件加载机制*
* *事件监听* 这是关键，也是难点所在。没有事件，插件没有机会介入到业务中。但应该提供什么样的事件，提供多少个事件，这非常依赖架构能力。

原则来说，在提供的能力相同的情况下，事件当然越少越好。但是怎么做到少而精，这非常有讲究。一般来说，事件分以下三类
* *界面操作类* 最原始的是鼠标和键盘操作，但它们太过于底层。更多时候会选择暴露更高级的界面事件，如菜单项或按钮的点击
* *数据变更类* 数据发生变化时，允许捕获它并做点什么。如 MVC 框架中 Model 层会发出数据变更通知
* *业务流程类* 通常发生在业务流的某个中间环节，或者业务流完成之后。如 Office 软件在打开文件之初或之后，都可能发出相应的事件

我们说的架构分解，把复杂系统分解为一个最小化的核心系统，加上多个相互正交的周边系统，它背后的机制往往就是我们这里提的插件机制。

插件机制的确让核心系统与周边系统耦合度大大降低。但插件机制并非没有成本。插件机制本身也是核心系统的一个功能，它本身也需要考虑与核心系统其他功能的耦合度。维持足够的通用性，是提供插件机制的重大前提。

### 单一职责原则

单一职责原则 强调的是每个模块只负责一个业务，而不是同时干多个业务。而开闭原则强调的是把模块业务的变化点抽离出来，包给其他的模块。本质上它两谈得失同一个问题的两个面。


作为架构师，我们除了做业务架构，还有一个同等难度的大事，就是选择合适的基础架构。基础架构 + 业务架构，才是你设计的软件的全部。作为架构师，千万不要一叶障目，不见泰山，忘记基础架构选择的重要性。

## 63 接口设计的准则

接口在不同的语义环境下，主要有两个不同含义
* 一种是模块的使用界面，比如公开的类或函数的原型
* 另一种是模块对依赖环境的抽象。这种情况下，接口是模块与模块之间的契约。在架构设计中我们经常会听到 “契约式设计 Design by Contract” 这种说法，它鼓励模块与模块的交互基于接口作为契约，而不是依赖于具体实现。

### 模块的使用界面

*「方法名或参数」要简单直观，遵循社区惯例*

对于模块的使用界面，最重要的是 KISS 原则，让人一眼就明白这个模块在做什么样的业务。

接口要 KISS，要简单自然，很重要的一点是符合语言和社区的惯例，尽可能沿用约定俗成的接口。

### 模块的环境依赖

模块的环境依赖分两种
* *使用界面依赖* 是指用户在使用该模块的使用界面时自然涉及的
* *实现依赖* 指模块当前实现方案涉及到的组件带来的依赖，如果换一种实现方案，这类依赖可能就不再存在或变成其他依赖了

在环境依赖上，我们遵循的是 *最小依赖原则*，或者叫 “最少知识原则 Least Knowledge Principle，LKP”，去尽可能发现模块中多余的依赖。

#### 使用界面依赖

*对参数进行「泛化」获得更大的「通用性」*

接口定义更多考虑的往往是对参数的泛化与抽象，以便让我们可以适应更广泛的场景。

比如，我们前面谈到 IO 系统的时候，把存盘与读盘的接口从 *.os.File 换成 io.Reader、io.Writer，以获得更强的通用性，比如对剪贴板的支持。类似的情况还有很多，一个接口的参数类型稍加变化，就会获得更大的通用性。再比如，对于上面 mockhttp.v1 中 rpc.Client 这个接口就存在多余的依赖，改为 http.Client 会更好一些。

当然，在接口参数的抽象上，也不适合过度。如果某种泛化它不会发生，那就是过度设计。不要一开始就把系统设计得非常复杂，而陷入“过度设计”的深渊。应该让系统足够的简单，而却又不失扩展性，这其中的平衡完全依赖你对业务的理解，它是一个难点。

#### 实现依赖

*在模块的「可配置性」与「学习成本」之间寻找平衡*

从模块实现的角度，我们环境依赖有两个选择：一个是直接依赖所基于的组件，一个是将所依赖的组件所有被引用的方法抽象成一个接口，让模块依赖接口而不是具体的组件。那么，这两种方式应该怎么选择？我的建议是，*大部分情况下应该选择直接依赖组件，而不必去抽象它*。如无必要，勿增实体。如果我们大量抽象所依赖的基础组件，意味着我们系统的可配置性（Configurable）更好，但学习成本也更高。

什么时候应当考虑把依赖抽象化？
* 需要提供多种选择时。比较典型的是日志的 Logger 组件。对于绝大部分的业务模块，都并不希望绑定 Logger 的选择，把决策权交给使用方。
* 需要解除一个庞大的外部系统依赖时。有时候我们并不是需要多个选择，而是某个外部依赖过重，我们测试或其他场景可能会选择 mock 一个外部依赖，以便降低测试系统的依赖。
* 依赖的外部系统为可选组件时


## 64 不断完善的架构范式

* 接口隔离原则 ISP，模块应该依赖于尽可能小的接口
* 依赖倒置原则 DIP，高层模块不应该依赖低层模块，而应该依赖于抽象接口
* 无环依赖原则 ADP，模块之间不要出现循环依赖，使用依赖倒置原则可解
* 组合优于继承
* 高内聚低耦合
* 惯例优于配置 COC，Convention over Configuration，灵活性会增加复杂性，通过惯例来减少配置
* 命令查询分离 CQS，Command Query Separation，读写操作要分离
* 关注点分离 SOC，Separation of Concerns，将一个复杂问题分解为多个简单问题

软件工程的复杂性自然存在，不会因为好的架构思维而消除。

软件是可以以 *搭积木* 的方式搭出来的，核心的一点是如何形成更多的“积木”。真正提高工程效率的，是我们的业务分解能力和历史积累的成果。

架构范式，不仅仅是一些架构思维，而是 *一个个业务只读、接口稳定、易于组合的模块 + 组合的方法论*，这才是架构师真正的武器库。

架构分解中有两大难题，需求交织 + 需求易变。61 讲重点聊的是需求交织。对于全局性功能怎么去拆解，把它从我们的业务中剥离出来，并无统一的解决思路。但好的一点是，绝大部分全局性功能都会有很多人去拆解，并最终会被 *基础设施化*，所以具体业务中我们会碰到的全局性功能并不是非常多。比如，怎么做用户的鉴权？怎么保障软件 24 小时持续服务？怎么保障快速定位用户反馈的问题？这些需求和所有业务需求是交织在一起的，也足够普适，所以就会有很多人去思考对应的解决方案。

架构师需要有自己的信仰。我们需要坚持对业务进行正交分解的信念，要坚持不断地探索各类需求的架构分解方法。这样的思考多了，我们就逐步形成了各种各样的架构范式。


### 56 服务治理篇总结

我个人不太喜欢常规意义上的 “设计模式”。或者说，我们对设计模式常规的打开方式是有问题的。理解每一个设计模式，都应该放到它想要解决的问题域来看。所以，我个人更喜欢的架构范式更多的是 “设计场景” 的总结。“设计场景” 和设计模式的区别在于它有自己清晰的问题域定义，是一个实实在在的通用子系统。

是的，这些 “通用的设计场景”，才是架构师真正的武器库。如果我们架构师总能把自己所要解决的业务场景分解为多个 “通用的设计场景” 的组合，这就代表架构师有了极强的架构范式的抽象能力。而这一点，正是架构师成熟度的核心标志。


## 架构老化与重构

架构能力提升全靠平常一点一滴地不断反思与打磨得来。无论是我们架构范式的不断完善，还是应对架构老化的经验积累，都是在日常工作过程中见功夫。

架构老化源于什么？在我们不断给系统添加各种新功能的时候，往往会遇到功能需求的实现方式不在当初框架设定的范围之内，于是很多功能代码逸出框架的范围之外。这些散落在各处的代码，把系统绞得支离破碎。久而久之，代码就出现老化，散发出臭味。代码老化的标志，是添加功能越来越难，迭代效率降低，问题却是持续不断，解决了一个问题却又由此生出好几个新问题。

在理想的情况下，如果我们坚持以 “最小化的核心系统 + 多个相互正交的周边系统” 这个指导思想来构建应用，那么代码就很难出现老化。

怎么应对架构老化？
* 该怎么重构系统，才能让我们的软件重新恢复活力？
* 在重构系统之前，我们应该如何进行局部改善，如果增加新功能又应该如何考虑？

### 老系统怎么添加新功能

正常来说，我们添加新功能，对于已经有大量历史沉淀的项目，我们应该把自己要添加的功能定位为周边功能。对于周边功能，往往考虑最多的点是如何少给核心系统添加麻烦。但其实这还不够，当我们把视角放在周边系统的时候，它本身也应该被看做独立业务系统。

如何让新功能的代码与既有系统解耦，能够不依赖尽量不依赖
* 不依赖的核心是业务不依赖
* 另外要考虑的是要不要依赖公司内部的基础库

*新功能的绝大部分代码独立于既有业务系统，只有少量桥接的代码是耦合的*。对于任何被正交分解的周边系统 B 与核心系统 A，理想情况下我们最终得到的应该是三个模块：A、B（与 A 无关部分）、A 与  B 桥接代码（与 A 相关的部分）。虽然从归属来说，A 与 B 桥接代码我们通常也会放到 B 模块，但是它应该尽可能小，且尽可能独立于与核心系统无关的代码。

要不要依赖公司内部的基础库，判断的标准是，成熟度越高的基础库越值得依赖。模块规格是否符合你的预期，以及经过了多少用户使用的打磨，这些是评估成熟度的依据。

### 架构的局部优化

局部优化有两种常见的做法
* 重写，这和开发一个新功能没什么两样，顶多可以保留些设计比较好的部分
  - 重构一定要基于你对这块代码的业务比较了解的基础上
  - 一定要把老代码清理干净，不要残留一些不必要的代码在系统里
* 依赖优化，关注的重心不是某项功能本身的实现，而是它与系统之间的关系
  - 用于理清楚周边系统与核心系统的耦合，即对核心系统的伤害值，基于此伤害值觉定是否要进一步重构
  - 工作量小，只搬运代码不改变业务逻辑。可以不深入功能细节，找出该功能的所有相关代码（这是难点）再把它们集中起来
  - 关注的是核心系统的边界，如果耦合过多说明核心系统需要提供事件机制

不要盲目地去做局部重构，而应基于「伤害值」的客观判断。认同他人是很重要的能力修炼。事情优先级的排列是第一位的，有太多重要的事情值得去做。

### 核心系统的重构

周边系统对核心系统的依赖无非两类：
* 一是核心系统的功能，表现为它提供的 *DOM 接口*
* 二是核心系统提供的 *事件*，让周边系统能够介入它的业务流程

对所有周边模块进行依赖优化的整理，细加分析后可以初步确定核心系统需要暴露的事件集合。进一步要做的事情是把核心系统的 DOM 接口也抽象出来。这一步比较复杂。它包含两件事情：让周边系统对它的依赖变成 *依赖接口而非依赖实现*；审视核心系统功能的 DOM 接口的合理性，明确出我们期望的接口设计。

完成了 *接口改造*，剩下来就简单了。核心系统，每一个周边系统，彼此完全独立，可以 *单独调整和优化*。

重构是一个集架构设计（未来架构应该是什么样的）、资源规划与调度（与新功能开发的优先级怎么排）、阶段规划（如何把大任务变小，降低内部的抵触情绪和项目风险）以及持久战的韧性与毅力的庞大工程。








1

2

3

4

5

6

















