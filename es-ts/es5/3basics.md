# 3 ECMAScript 基本概念

## 3.1 ECMAScript 语法
ECMAScript 的语法很容易掌握，因为它借用了 Java、C 和 Perl 语言的语法。

### 3.1.1 区分大小写
与 Java 一样，变量、函数名、运算符以及其他一切东西都是区分大小写的。

### 3.1.2 标识符
所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。须遵守以下规则：

* 第一个字符必须是一个字母、下划线 `_` 或一个美元符号 `$`；
* 其他字符可以是字母、下划线、美元符号或<b>数字</b>

按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。

### 3.1.5 语句以分号结尾

Java、C 和 Perl 都要求每行代码以分号`;`结束才符合语法。ECMAScript 则允许开发者省略分号。如果没有分号，则由解析器确定语句的结尾。虽然语句结尾的分号不是必需的，但我们**建议任何时候都不要省略它**，因为：

* 加上分号可以避免很多错误，如不完整的输入
* 开发人员可以放心地通过删除多余的空格来压缩ES代码(代码行结尾处没有分号会导致压缩错误)
* 加上分号也会在某些情况下增进代码性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了

```js
if (false)
alert("test");  // 换行写有效，不会被认为是2条代码，即本例不会弹出窗口，但应该避免这种写法
```

### 3.1.3 注释

ECMAScript 的注释与 Java、C 和 PHP 语言的注释相同。有两种类型的注释：

```js
// 单行注释 - 以双斜杠开头

/*
 * 多行注释 - 以单斜杠和星号开头，以星号和单斜杠结尾
 */

/*!
 * 文件注释 - 按照惯例，可以在 /* 后加 ！来表示文件注释，放在文件开头说明文件信息
 */

/**
 * 文档注释 - 如果用 JSDoc 来自动生成 API 文档，那么必须严格以 /** 开头，/* /*** 这些都不行
 */ 
```

### 括号表示代码块

从 Java 中借鉴的另一个概念是代码块。代码块表示一系列应该按顺序执行的语句，这些语句被封装在花括号 `{}` 之间。

### 3.1.4 严格模式

ES5 引入了严格模式的概念，在严格模式下，ES3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。

要在整个脚本中启用严格模式，可以在顶部添加代码；也可以通过在函数内部的上方包含这条编译指示，指定函数在严格模式下执行。
```js
"use strict";
```

## 3.2 关键字和保留字

### 关键字

ECMA-262 定义了 ECMAScript 支持的一套关键字 keyword。

这些关键字标识了 ECMAScript 语句的开头和/或结尾。关键字是保留的，不能用作变量名或函数名。

下面是 ECMAScript 关键字的完整列表：

```txt
break case catch continue debugger default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with
```

注意：如果把关键字用作变量名或函数名，可能得到诸如 "Identifier Expected" 这样的错误消息。

### 保留字

ECMA-262 定义了 ECMAScript 支持的一套保留字 reserved word。

保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。

ES5 中保留字的完整列表如下：

```txt
abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile
```

ES5 非严格模式下的保留字缩减为以下这些：

```txt
class const enum export extend import super
```

ES5 严格模式下的保留字在非严格模式的基础上增加：

```txt
implements interface let package private protected public static yield eval* arguments*
```

ES3 中如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。  
ES5 对使用关键字和保留字的规则进行了少许修改，关键字和保留字虽然仍然不能作为标识符使用，但现在可以用作对象的属性名。  
ES5 在严格模式下，eval 和 arguments 这两个名字不能作为标识符或属性名，但是在非严格模式下不会抛出错误。

## 3.3 变量

### 变量是弱类型的

与 Java 和 C 不同，ECMAScript 中的变量无特定的类型，定义变量时只用 `var` 运算符，可以将它初始化为任意值。因此，可以随时改变变量所存数据的类型(但请尽量避免这样做)。

### 声明变量

ECMAScript 中的变量是用 `var` 运算符(variable 的缩写)加变量名定义的。

```js
var test = "hi";  // 定义变量并初始化，由于ECMAScript是弱类型的，无需明确的类型声明
var test;         // 变量并不一定要初始化，未经初始化的变量会保存一个特殊值 undefined
var test2 = "hello", age = 25;  // 一个 var 语句可以定义多个变量，且不必具有相同的类型
var test = "hi"; test = 55;     // 变量可以存放不同类型的值，这是弱类型变量的优势。
```

### 命名变量

变量名需要遵守两条简单的规则：

* 第一个字符必须是字母、下划线 `_` 或美元符号 `$`
* 余下的字符可以是下划线、美元符号、字母或数字

### 变量声明不是必须的

ECMAScript 另一个有趣的方面(也是与大多数程序设计语言的主要区别)，是在使用变量之前不必声明。解释程序遇到未声明过的标识符时，**会用该变量名创建一个全局变量**，并将其初始化为指定的值。

这是该语言的便利之处，不过如果不能紧密跟踪变量，这样做也很危险。最好的习惯是像使用其他语言一样，总是声明所有变量。  
ES5 在严格模式下给未声明的变量赋值会导致抛出 ReferenceError 错误。


## 3.4 ECMAScript 数据类型

ECMAScript 具有 5 种简单数据类型(primitive type) 和 1 种复杂数据类型。
  * 简单数据类型也称为基本数据类型，包含 Undefined、Null、Boolean、Number 和 String。
  * 复杂类型只有 Object，Object 本质上是由一组无序的名值对组成的。

简单数据类型存储在栈 stack 中，也就是说，它们的值直接存储在变量访问的位置。

复杂数据类型为存储在堆 heap 中的对象，存储在变量处(stack 中)的值是一个指针 point，指向存储对象的内存处。

### 3.4.1 typeof 运算符

`typeof` 运算符有一个参数，即要检查的变量或值。例如：

```js
alert (typeof "string"); //输出 "string"
alert (typeof 86);       //输出 "number"
```

`typeof` 运算符将返回下列值之一：
  * undefined - 值未定义
  * boolean - 布尔值
  * number - 数值
  * string - 字符串
  * object - 对象或 null
  * function - 函数

有时候 typeof 操作符会返回一些令人迷惑但技术上正确的值：
  * 对于 null 值会返回 "object"，因为 null 被认为是对象的占位符；
  * 函数在 ES 中属于对象，但函数也确实有一些特殊的属性，所以将函数从对象中独立出来了。

### 3.4.2 Undefined 类型

Undefined 类型只有一个值，即特殊的 `undefined`。当声明的变量未初始化时，该变量的默认值就是 `undefined`。

ES3 引入这个值是为了正式区分 **空对象指针** `null` 与 **未经初始化的变量** `undefined`。

注意：包含 `undefined` 值的变量与尚未定义的变量是不一样的，但 `typeof` 运算符并不真正区分这两种值。  
注意：对于未定义的变量，其他运算符会报错，而 `typeof` 不会报错，这是 `typeof` 特别的地方。

```js
var oTemp;
alert(typeof oTemp);   // 输出 "undefined"
alert(typeof oTemp2);  // 输出 "undefined"
alert(oTemp2 == undefined);  // 代码将引发错误
```

当函数无明确返回值时，返回的也是 `undefined`：

```js
function testFunc() { }
alert(testFunc() === undefined);  // 输出 "true"
```

### 3.4.3 Null 类型

另一种只有一个值的类型是 Null，它只有一个专用值 `null`，即它的字面值。

从逻辑角度来看，`null` 值表示一个空对象指针，而这也是 `typeof` 操作符检测 `null` 时会返回 `'object'` 的原因。

实际上值 `undefined` 是从值 `null` 派生来的，因此 ECMAScript 把它们定义为相等的。

```js
alert(null == undefined);   // 输出 true
alert(null === undefined);  // 输出 false
alert(null == {});          // 输出 false
```

注意：如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 `null`。

建议：如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 `null`。

### 3.4.4 Boolean 类型

Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 `true` 和 `false`。

虽然 Bloolean 类型的字面值只有两个，但 ES 中所有类型的值都有与这两个Boolean值等价的值。可以调用转型函数 Boolean()将一个值转换为其对应的 Boolean 值。下表给出了各种数据类型及其对应的转换规则：

| 数据类型  | 转换为 `true` 的值       | 转换为 `false` 的值
|-----------|--------------------------|---------------------
| String    | 任何非空字符串           | `""`
| Number    | 任何非零数字值(含无穷大) | `0` 和 `NaN`
| Object    | 任何对象                 | `null`
| Undefined | n/a                      | `undefined`

这些转换规则对理解流控制语句(如 `if` 语句)自动执行相应的 Boolean 转换是非常重要的。

### 3.4.5 Number 类型

Number 类型 应该是最令人关注的数据类型了，这种类型使用 IEEE754 格式来表示整数和浮点数。

直接输入的(而不是从另一个变量访问的)任何数字都被看做 Number 类型的字面值。

#### 字面量：八、十、十六进制

最基本的数字字面量格式是十进制整数，除了十进制表示外，整数也可以通过八进制或十六进制的字面值来表示。

八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7）。

```js
var iNum = 070;      // 070 等于十进制的 56
var octalNum = 079;  // 无效的八进制数值——解释为十进制 79
```

注意：如果字面值中的数值超出了范围，那么前导0将被忽略，后面的数值将被当做十进制解析。  
注意：八进制字面量在 ES5 严格模式下报错 Uncaught SyntaxError: Octal literals are not allowed in strict mode.

十六进制的字面量前面两位数字必须为 `0x`，然后是任意的十六进制数字(0-9 和 A-F) 这些字母不区分大小写。

```js
var iNum = 0x1f;  // 0x1f 等于十进制的 31
var iNum = 0xAB;  // 0xAB 等于十进制的 171
```

提示：尽管所有整数都可以用八进制或十六进制的字面值表示，但算术运算返回的结果都用十进制表示。

#### 浮点数

所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。

由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ES会不失时机地将浮点数值转换为整数值。

```js
var floatNum1 = 1.;   // 小数点后面没有数字，解析为整数1
var floatNum2 = 1.0;  // 整数，解析为整数1
```


##### 科学计数法

对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数。例如：

```js
var fNum = 5.618e7  // 表示的是数 56180000
var fNum2 = 8e-7    // 表示小数 0.0000008
```

ECMAScript 默认会将那些小数点后面带有6个或以上0的浮点数转换成科学计数法。

##### 精度 -- 永远不要测试某个特定的浮点数值

浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。如

```js
alert(0.1+0.2)  // 结果不是0.3 而是0.30000000000000004
```

浮点数值计算会产生舍入误差，这是所有基于 IEEE754 数值格式的浮点计算的通病，该问题同样存在于其他采用 IEEE754 的语言。

**正因为存在浮点计算误差，所以永远不要测试某个特定的浮点数值，如真有需要请转成整数测试！**

#### 数值范围

Number.MIN_VALUE -- 保存 ES 能够表示的最小数值，大多浏览器中这个值是 5e-324

Number.MAX_VALUE -- 保存 ES 能够表示的最大数值，大多浏览器中这个值是 1.7976931348623157e+308

Infinity -- 如果某次计算结果超出了 ES 数值范围，那么这个数值将被自动转换成 Infinity 值，如果是负数，则是 -Infinity

Number.POSITIVE_INFINITY 属性保存了 Infinity 值

Number.NEGATIVE_INFINITY 保存了 -Infinity值。

如果某次计算返回了正的或负的 Infinity 值，那么该值将无法参与下一次计算。

可以使用 isFinite() 函数判断一个数值是否是介于最小和最大值之间。

参考资料：关于64位浮点数精度和取值范围：[IEEE二进制浮点数算术标准](http://blog.sina.com.cn/s/blog_814e83d80
101bgcf.html)

#### NaN

特殊数值NaN，表示非数值（Not a Number），这个数值用于表示一个本来要返回数值的操作却未返回数值的情况（这样就不会抛出错误了）。

NaN 本身有两个非同寻常的特点：

  * 任何涉及 NaN 的操作都会返回 NaN；
  * NaN 与任何值不相等，包括 NaN 本身。

##### isNaN() 函数

出于以上原因，ES 设计了 isNaN() 函数用于确定一个给定值是否“不是数值”。

isNaN() 在接收到一个值之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回 true

```js
alert(isNaN("blue"));  // true（不能被转换成数值）
```

isNaN() 函数也适用于对象，它首先会调用对象的 valueOf() 方法，然后确定返回值是否可以转换为数值，如果不能，基于这个返回值再调用 toString() 方法，再测试返回值。这个过程也是 ES 中内置函数和操作符的一般执行流程。

### 3.4.6 String 类型

String 类型的值是由零或多个 _16位 Unicode 字符_ 组成的字符序列，即字符串。

String 类型的独特之处在于，它是唯一没有固定大小的简单数据类型。

字符串的长度都可以通过访问其 length 属性取得。

字符串字面量是由双引号（"）或单引号（'）声明的。与 Java、PHP 等程序不同，单双引号的效果是完全相同的，没有区分。

#### 转义序列

String 类型包含一些特殊的字符字面量，也叫作转义序列，用于表示非打印字符或具有其他用途字符：

|||
|--------|----------------------------------------------------------------------------------
| \n     | 换行
| \t     | 制表符
| \b     | 退格
| \r     | 回车
| \f     | 换页符
| \\\    | 反斜杠
| \'     | 单引号
| \"     | 双引号
| \xnn   | 十六进制代码 _nn_ 表示的字符（_n_ 是 0 到 F 中的一个十六进制数字）
| \unnnn | 十六进制代码 _nnnn_ 表示的 Unicode 字符（_n_ 是 0 到 F 中的一个十六进制数字）

#### 字符串的特点

ES中字符串是不可变的，也就是说，字符串一旦创建，他们的值是不能改变的。要改变某个变量保存的字符串，需要重新创建一个新的字符串。这也是一些老版本的浏览器中拼
接字符串时速度很慢的原因所在，不过现代浏览器已经解决了这个低效率问题。

### 3.4.7 Object 类型

ES 中的对象其实就是一组数据和功能的集合。Object 类型是所有它的实例的基础。

从技术角度讲，ECMA-262 中的对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为他们是由宿主实现和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承 Object。


## 3.5 ECMAScript 操作符

### 3.5.2 位操作符

位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。由于是在数值表示的最底层执行操作，因此速度更快。

#### 重温整数

默认情况下，ECMAScript 中所有整数都是有符号整数，当然，也存在无符号整数。

有符号整数使用低 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。正数以纯二进制格式存储，负数使用二进制补码格式存储。

计算数字二进制补码的步骤有三步：
  1. 确定该数字的非负版本的二进制表示（例如，要计算 -18的二进制补码，首先要确定 18 的二进制表示）
  2. 求得二进制反码，即要把 0 替换为 1，把 1 替换为 0 （反码）
  3. 在二进制反码上加 1（补码）

```
0000 0000 0000 0000 0000 0000 0000 0000   //  0 的二进制编码
                                     -1
---------------------------------------
1111 1111 1111 1111 1111 1111 1111 1111   // -1 的二进制编码
```

#### 注意事项

ECMAScript 中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像只存在32位的整数一样。

所有整数字面量都默认存储为有符号整数。只有位运算符才能创建无符号整数。

在对特殊的 NaN 和 Infinity 值应用位操作时，这两个值都会被当成 0 来处理。

如果对非数值应用位操作符，会先进行强制类型转换，然后再应用位操作，得到的结果将是一个数值。

ES 在把数值转换成二进制字符串时，会以更合乎逻辑的形式展示出来，如 -18 只会显示为 -10010

#### 按位非 NOT `~`

按位非由否定号 `~` 表示，按位非的结果就是返回数值的反码，即操作数的负值再减 1。

```js
var iNum1 = 25       // 25 等于 00000000000000000000000000011001
var iNum2 = ~iNum1;  // 转换为 11111111111111111111111111100110 即-26
```

#### 按位与 AND `&`

按位与由和号 `&` 表示，它把每个数字中的数位对齐，然后对同一位置上的两个数位进行 AND 运算。

```text
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

#### 按位或 OR `|`

按位或由符号 `|` 表示，对同一位置上的两个数位进行 OR 运算。

```text
25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
```

#### 按位异或 XOR `^`

按位异或由符号 `^` 表示，对同一位置上的两个数位进行 XOR 运算。

```text
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
```

#### 左移 `<<`

左移操作符由两个小于号表示 `<<`。它把数字中的所有数位向左移动指定的位数。右边的空位用 0 填充。

注意：左移不会影响操作数的符号位。

#### 有符号的右移 `>>`

有符号右移操作符由两个大于号表示 `>>`。它会将数值向右移动，但保留符号位。右移产生的空位用**符号位的值**填充。

#### 无符号右移 `>>>`

无符号右移操作符由三个大于号 `>>>` 表示，它将 32 位数的所有数位整体右移。右移产生的空位用** 0 **填充。

对于正数，无符号右移运算的结果与有符号右移运算一样。

对于负数，因为右移运算用 0 填充所有空位，负数变成了正数，无符号右移总是得到一个非常大的数字。


## 3.6 语句

ECMA-262 规定了一组语句(也称为流控制语句)，语句定义了 ES 中主要的语法，语句通常使用一个或多个关键字来完成任务。

### 3.6.1 if 语句

<pre> if (<i>condition</i>) statement1 else statement2</pre>
<br />
<pre>
 if (<i>condition1</i>) statement1
 else if (<i>condition2</i>) statement2
 else statement3
</pre>

业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码，因为这样可以消除人们的误解。

### 3.6.2 do-while 语句
do-while 语句是后测试循环。这意味着在计算表达式之前，至少会执行循环主体一次。
<pre> do { <i>statement</i> } while (<i>expression</i>);</pre>

### 3.6.3 while 语句
while 语句是前测试循环，退出条件是在执行循环内部的代码之前计算的。
<pre> while (<i>expression</i>) <i>statement</i></pre>

### 3.6.4 for 语句
for 语句是前测试循环，而且在进入循环之前，能够初始化变量，并定义循环后要执行的代码。  
for 语句存在极大的灵活性，因此它也是 ES 中最常用的一个语句。
<pre> for (<i>initialization; expression; post-loop-expression</i>) statement</pre>

注意：*post-loop-expression* 之后不能写分号，否则无法运行。

注意：for 循环的变量初始化表达式需要带 `var` 关键字，不然会生成一个全局变量。因为 ES 没有块级概念，所有循环执行完后计数变量会保留在当前作用域内。

for 语句和 while语句可相互转换，for循环只是把与循环有关的代码集中在了一个位置。

### 3.6.5 for-in 语句
for-in 语句是是一种精准的迭代语句，可以用于枚举对象的属性。

<pre> for (<i>property</i> in <i>expression</i>) statement</pre>

```js
for (var propName in window) {  // 这里同样会生成新变量，加 var 以尽量避免全局变量污染
  document.writeln(propName);
}
```

**注意：**ECMAScript对象的属性没有顺序，因此，通过 for-in 循环输出的属性名顺序是不可预测的。

### 3.6.6 label 语句
<pre> <i>label</i> : statement</pre>

```js
  start : i = 5;
```

加标签的语句一般都要与循环语句配合使用，即为循环中的 break 或 continue 提供一个跳出点。

### 3.6.7 break 和 continue 语句
break 和 continue 语句用于在循环中精确地控制代码的执行。

其中 break 语句会立即退出整个循环，强制继续执行循环后面的语句。  
而 continue 语句只是退出当前单步循环，但退出后会从循环顶部继续执行下步循环。

#### 与有标签的语句一起使用
break 语句和 continue 语句都可以与 label 语句联合使用，返回代码中的特定位置。这种联合使用的情况多发生在循环嵌套的情况下。

```js
var iNum = 0;
outermost:
for (var i=0; i < 10; i++) {
  for (var j=0; j < 10; j++) {
    if (i == 5 && j == 5) { break outermost; }
    iNum++;
  }
}
alert(iNum);  // 输出 "55"
```

虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果过度使用，也会给调试代码带来麻烦。我们建议如果使用label语句，一定要使用描述性的标签，同时不要嵌套太多层循环。

### 3.6.9 with 语句

with 语句用于设置代码作用域到特定对象中。

在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询设定的对象中是否有同名的属性。如果发现了同名属性，就以对象属性的值作为变量的值。

<pre> with (<i>expression</i>) statement</pre>

```js
var sMessage = "hello";
with(sMessage) {
  alert(toUpperCase());  // 输出 "HELLO"
}
```

**警告：**由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用。

ES5 严格模式下禁止使用 with 语句。

### 3.6.9 switch 语句

switch 语句是 if 语句的兄弟语句。

```js
switch (expression) {
  case value1:
    statement1;
    // ...;
    break;
  case value2:
    statement2;
    // ...;
    break;
  // ......
  default:
    statement3;
    // ...
}
```

通过为每个 case 后面都添加一个 break 语句，就可以避免同时执行多个 case 代码的情况。如果确实需要混合几种情形，不要忘了在代码中添加注释，说明你有意省略了 break 关键字。

```js
switch (i) {
  case 25:      // 合并两种情形
  case 35:
    alert("25 or 35");
    break;
  case 45:
    alert("45");
    break;
  default:
    alert("other");
}
```

ECMAScript 中 switch 语句与其他语言中不同的地方在于：

* 可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串还是对象。
* 每个 case 的值不一定是常量，可以是变量，甚至是表达式。

```js
var num = 25;
switch (true) {    // 传递的是 true，因为每个 case 值都可以返回一个布尔值
  case num < 0:
    alert("Less than 0.");
    break;   
  case num >= 0 && num <= 20:
    alert("Between 0 and 20.");
    break;
  default:
    alert("More than 20.")
}
```

注意：switch 语句在 _比较值时使用的是全等操作符_ ，因此不会发生类型转换（例如，"10" 不等于10）

## 3.7 函数

函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。

ES 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。

```js
function functionName(arg0, arg1, ..., argN) {
  statements
}
```

函数可以通过 return 语句后跟要返回的值来实现返回值，如果没有指定，默认返回 undefined。  
函数执行中如果碰到 return 语句，会立即跳出，而不会再执行后续语句。

### 3.7.1 理解参数

ES 函数的参数与大多数其他语言中的函数的参数有所不同。ES函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。之所以会这样，原因是 ES 中的 _参数在内部是用一个数组来表示的_ 。函数接收到的始终都是这个数组（这个数组可以不包含任何元素），而不关心数组中包含哪些参数。实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。

arguments 对象只是与数组类似，但并不是 Array 的实例。可以使用方括号语法访问它的每一个元素（arguments[0] arguments[1] ... ），使用 length 属性来确定传递进来多少个参数。

arguments 对象的存在使得形参不再重要，命名的参数只提供便利，但不是必需的。

ES5 严格模式下无法更改 arguments 对象内容，即使通过形参修改也是无效的。

#### 关于 arguments 对象 与 形参 的关系

```js
function doAdd(num1, num2) {

  // num1 与 argumets[0] 始终保持同步，哪怕是定义新对象
  num1=[12,34];
  document.writeln(typeof arguments[0]);  // 输出 object

  // num2 与 arguments[1] 无法保持同步，只不过是两个没有联系的变量
  num2 = arguments[1] = [56];      // 建立联系
  num2= [78];
  document.writeln(num2);          // 输出 78
  document.writeln(arguments[1]);  // 输出 56，说明没有同步，如果只是修改对象的一个属性，两者是同步的，但这只是因为两个变量存放的是对同一个对象的引用，与“始终保持同步”不是一个概念。

  // length 只是一个普通属性成员，不像数组中的 length 更新会导致数组结构变化
  document.writeln(arguments.length);    // 即使设置了argumets[1]，length依然是1
  arguments.length = 2;
  document.writeln(arguments.length);    // 输出 2，说明 length 只是一个普通属性成员
}

doAdd(8);  // 只传入一个参数，然后具体输出备注在函数定义中
```

通过上述试验，个人给出以下观点（以上例分析）

* 调用函数时，初始化arguments对象，并将形参 num1 作为别名绑定到 arguments[0] 上，从而确保始终保持同步
* 调用函数时，初始化arguments对象，并将其 length 属性值设置为1，这个值不会像 Array 中那样会自动更新
* 调用函数时，形参 num2 只相当于定义了一个局部变量，并没有作为别名绑定到 arguments[1]，即使后续在函数内部设置了 arguments[1]，因为没有在初始化时实现绑定，所以两者无法保持同步。

### parameter和argument的区别

简略描述为：parameter = 形参(formal parameter)， argument = 实参(actual parameter)

### 3.7.2 没有重载

在多数其他语言中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。在ES中函数不能像传统意义上那样实现重载。如果ES中定义了两个名字相同的函数，这该名字只属于后定义的函数，也就是说前面的定义被覆盖了。

但因为ES对传入的参数没有限制，可以通过检查传入函数的类型和数量来作出不同的反应，从而模仿重载功能。
