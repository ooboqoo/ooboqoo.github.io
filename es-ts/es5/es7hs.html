<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/resource/lib/html-main.css" />
<script src="/resource/lib/html-main.js"></script>
<title>ECMAScript 函数</title>
</head>
<body>
<div id="article">

<h1>7.1 递归</h1>

<h1>7.2 闭包（closure）</h1>

<div>
<p><strong>闭包的使用场合：</strong>需要一个全局变量，但这个全局变量只能通过一个函数调用。如果定义一个全局变量，那么，其他任何函数都可以改变这个全局变量的值；如果使用内部变量，函数运行完后，变量值无法保留；采用闭包技术，将一个变量隐藏到一个函数内部，再通过该函数的子函数来操作该变量，任务达成。</p>


<h2>Self-Invoking Functions</h2>
<p>Function expressions can be made "self-invoking".</p>
<p>A self-invoking expression is invoked (started) automatically, without being called.</p>
<p>Function expressions will execute automatically if the expression is followed by ().</p>
<p>You cannot self-invoke a function declaration. You have to add parentheses around the function to indicate that it is a function expression:</p>
<pre>
(function () {
    var x = "Hello!!";      // I will invoke myself
})();
</pre>
<p>The function above is actually an anonymous self-invoking function (function without name).</p>

<h2>JavaScript Closures</h2>
<p>Remember self-invoking functions? What does this function do?</p>
<pre>
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();

add();
add();
add();
// the counter is now 3 
</pre>
<p>The variable <strong>add</strong> is assigned the return value of a self-invoking 
function.</p>
<p>The self-invoking function only runs once. It sets the counter to zero (0), 
and returns a function expression.</p>
<p>This way add becomes a function. The "wonderful" part is that it can access 
the counter in the parent scope. </p>
<p>This is called a JavaScript <strong>closure.</strong> It makes it possible 
for a function to have "<strong>private</strong>" variables.</p>
<p>The counter is protected by the scope of the anonymous function, 
and can only be changed using the add function.</p>
</div>


<h1>7.3 模仿块级作用域</h1>
<h1>7.4 私有变量</h1>

<h1>7.5 小结</h1>

<div>
<p>在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点：</p>
<ul>
<li>函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫作匿名函数。</li>
<li>在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；</li>
<li>递归函数应该始终使用 arguments.callee 来递归调用自身，不要使用函数名——函数名可能会发生变化。</li>
</ul>

<P>当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下：</P>
<ul>
<li>在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域 和 全局作用域；</li>
<li>通常，函数的作用域及其所有变量都会在函数执行结束后销毁；但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。</li>
</ul>

<p>使用闭包可以在JS中模仿块级作用域，要点如下</p>
<ul>
<li>创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用；</li>
<li>结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。</li>
</ul>

<p>闭包还可以用于在对象中创建私有变量，相关概念和要点如下</p>
<ul>
<li>即使JS中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。</li>
<li>有权访问私有变量的公有方法叫做特权方法。</li>
<li>可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。</li>
</ul>
<p>JS中的函数表达式和闭包都有极其有用的特性，利用他们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。</p>

</div>

</div>
</body>
</html>