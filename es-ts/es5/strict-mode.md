# 严格模式

ES5 最早引入了 “严格模式” 的概念。通过严格模式，可以在函数内部选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中存在的错误，及时捕获一些可能导致编程错误的行为。

ES6 类和模块的内部，只有默认的严格模式可用。考虑到未来所有代码都将运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。

## B1 声明严格模式

使用编译指示 `"use strict";` 来声明严格模式。  
需要注意的是，如果在全局作用域（函数外部）给出编译指示，则整个脚本都将使用严格模式。换句话说，如果把带有这个编译指示的脚本放到其他文件中，则该文件中的 JavaScript 代码也将处于严格模式下。

```js
function() {
  "use strict";    // 声明严格模式，为防止影响其他代码，该编译指示应该始终放在函数内
}
```

## B2 变量

在严格模式下，如果给一个没有声明的变量赋值，代码执行时会抛出 ReferenceError。  
而在非严格模式下，这种用法会创建全局变量，这往往不是所期望的。

严格模式下不能对变量调用 `delete` 操作符，删除变量会导致错误。  
而非严格模式下不会报错，只是静默失败（返回 false）。

严格模式下对变量名也有限制。特别地，不能使用 `implements` `interface` `let` `package` `private` `protected` `public` `static` 和 `yield` 作为变量名，这些都是保留字，使用这些标识符作为变量名会导致语法错误。

## B3 对象

在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。

在下列情形下操作对象的属性会导致错误：

* 为只读属性赋值会抛出 TypeError；
* 对不可配置 nonconfigurable 的属性使用 delete 操作符会抛出 TypeError；
* 为不可扩展 nonextensible 的对象添加属性会抛出 TypeError；
* 严格模式下使用对象字面量时，属性名必须唯一，否则会抛出语法错误。

```js
var person = {name: "Nicholas", name: "Greg"};  // 严格模式下，重名属性会抛出语法错误
                                                // 非严格模式下，以第二个属性为准
```

## B4 函数

严格模式要求命名函数的参数必须唯一，重名参数会抛出语法错误。

```js
function sum(num, num) {}  // 严格模式下，重名参数会抛出错误
                           // 非严格模式下通过参数名只能访问第二个参数，要访问第一个参数必须通过 arguments 对象
```

在非严格模式下，修改命名参数的值也会反映到 arguments 对象中，而严格模式下这两个值是完全独立的。

```js
+function showValue(value) {
  value = "Foo";
  console.log(value, arguments[0]);  // 非严格模式 "Foo Foo"，严格模式 "Foo Hi"
}("Hi");
```

另一个变化是淘汰了 `arguments.callee` 和 `arguments.caller`。在非严格模式下，这两个属性一个引用函数本身，一个引用调用函数。而在严格模式下，访问这两个属性都会抛出 TypeError。

类似地，尝试读写函数的 `caller` 属性，也会导致抛出 TypeError。

与变量类似，严格模式对函数名也做了限制，不允许用 `implements` `interface` `let` `package` `private` `protected` `public` `static` 和 `yield` 作为函数名。

对函数的最后一点限制，就是只能在脚本的顶级和在函数内部声明函数，也就是说，在 if 语句中声明函数会导致语法错误。

## B5 `eval()` 与 `arguments`

饱受诟病的 eval() 函数在严格模式下也得到了提升。最大的变化就是它在包含上下文中不再创建变量或函数。

```js
function() {
  eval("var x = 10");
  alert(x);  // 严格模式下会抛出 ReferenceError，非严格模式下显示 10
}
```

严格模式已经明确禁止使用 eval 和 arguments 作为标识符，也不允许读写它们的值。

## B7 `this`

在非严格模式下使用函数的 apply() 或 call() 方法时，null 或 undefined 值会被转换为全局对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值。

## B8 其他变化

严格模式摒弃了 with 语句。

严格模式也去掉了八进制字面量，以 `0` 开头的数值会被认为是十进制的。（ES6 又添加了八进制字面量，但改成了 `0o` 开头）

# 严格模式详解

来源：http://www.cnblogs.com/susufufu/p/5859222.html

本文参考MDN做的详细整理，方便大家参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript）


## ES5 中的严格模式  [##](http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html)

严格模式主要有以下限制。

- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用`with`语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀0表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量`delete prop`，会报错，只能删除属性`delete global[prop]`
- `eval`不会在它的外层作用域引入变量
- `eval`和`arguments`不能被重新赋值
- `arguments`不会自动反映函数参数的变化
- 不能使用`arguments.callee`
- 不能使用`arguments.caller`
- 禁止`this`指向全局对象
- 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈
- 增加了保留字（比如`protected`、`static`和`interface`）



### 设计目的

设立“严格模式”的目的，主要有以下几个。

* 明确禁止一些不合理、不严谨的语法，减少一些怪异行为。
* 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。
* 提高编译器效率，增加运行速度。
* 为未来新版本的 JavaScript 做好铺垫。
* “严格模式”体现了 JavaScript 更合理、更安全、更严谨的发展方向

### 开启严格模式

严格模式可以应用到整个 script 标签或个别函数中。

不要在封闭大括弧 {} 内这样做，在这样的上下文中这么做是没有效果的。

在 eval 代码，Function 代码，事件处理属性，传入 setTimeout 方法的字符串 和 包含整个脚本的块中开启严格模式会如预期一样工作。

#### 针对整个脚本文件

将 `"use strict"` 放在脚本文件的第一行，整个脚本都将以“严格模式”运行。但如果该语句不在第一行就无效。(严格地说，只要前面不是产生实际运行结果的语句，use strict 可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)

合并均为严格模式的脚本或均为非严格模式的脚本都没问题，只有在合并严格模式与非严格模式时有可能出问题。建议按一个个函数去开启严格模式。您也可以将整个脚本的内容用一个立即执行的匿名函数包括起来，然后在这个函数中使用严格模式。

#### 为某个函数开启严格模式

同样的，要给某个函数开启严格模式，得把 "use strict";  (或 'use strict'; )声明放在函数体所有语句之前

### 将拼写错误转成异常

* 严格模式下无法再意外创建全局变量，即所有变量必须用显式声明;
* 严格模式下任何在正常模式下引起静默失败的赋值操作都会抛出异常;
* 在严格模式下, 试图删除不可删除的属性时会抛出异常(之前这种操作不会产生任何效果);
* 在严格模式下要求一个对象内的所有属性名在对象内必须唯一，重名属性被认为是语法错误;
* 严格模式要求函数的参数名唯一，重名参数被认为是语法错误;
* 严格模式禁止八进制数字语法，八进制语法将会引起语法错误(整数第一位为0，将报错)。

### 简化变量的使用

* 严格模式禁用 with，严格模式下, 使用 with 会引起语法错误。
* 严格模式下的 eval 不会给上下文引入新变量。当直接调用 eval(str) 时，若 eval(str) 在严格模式下，则 str代码也在严格模式下执行；当间接调用 eval(str)时，str代码必须自行开启严格模式。
* 严格模式禁止删除变量，只能删除对象的属性，否则会引起语法错误。
* 严格模式让 arguments 和 eval 少了一些奇怪的行为：
  * 名称 eval 和 arguments 不能通过程序语法被绑定(be bound)或赋值.
  * 严格模式下，eval、arguments 将作为保留字，使用 eval 或者 arguments 作为标识名，将会报错
  * 严格模式下，函数内部改变参数与 arguments 的联系被切断了，两者不再存在联动关系。

### 增强的安全措施

禁止 `this` 关键字指向全局对象。这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 `new`，这时 `this` 不再指向全局对象，而是报错。

函数内部不得使用 `fn.caller`、`fn.arguments`，否则会报错。这意味着不能在函数内部得到调用栈了(同时，也使尾调用优化成功导入ES6)。

禁止使用 `arguments.callee`、`arguments.caller`


### 静态绑定

严格模式下，禁止使用 with 语句，使用 with 语句将报错。因为 with 语句无法在编译时就确定某个属性到底归属哪个对象，从而影响了编译效果。

严格模式创设了第三种作用域：eval作用域。eval 语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval 所生成的变量只能用于 eval 内部。

### 向下一个版本过渡

JavaScript 的新版本 ES6 会引入“块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。如 if 语句内、for 循环体内。

为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。
