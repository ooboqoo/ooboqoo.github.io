<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="/resource/lib/html-main.css" />
<script src="/resource/lib/html-main.js"></script>
<title>ECMAScript 数据类型</title>
</head>
<body>
<div id="article">

<h1>3.4 ECMAScript 数据类型</h1>

<div>
<p>ECMAScript 具有 5 种简单数据类型（primitive type）和 1 种复杂数据类型。</p>
<ul><li>简单数据类型也称为基本数据类型，包含 Undefined、Null、Boolean、Number 和 String。</li>
    <li>复杂类型只有 Object，Object 本质上是由一组无序的名值对组成的。</li>
</ul>
<p>简单数据类型存储在栈（stack）中，也就是说，它们的值直接存储在变量访问的位置。</p>
<p>复杂数据类型为存储在堆（heap）中的对象，存储在变量处（stack 中）的值是一个指针（point），指向存储对象的内存处。</p>
</div>

<div>
<h2>3.4.1 typeof 运算符</h2>
<p>typeof 运算符有一个参数，即要检查的变量或值。例如：</p>
<pre>
alert (typeof "string");  <span>//输出 "string"</span>
alert (typeof 86);        <span>//输出 "number"</span>
</pre>
<p>typeof 运算符将返回下列值之一：</p>
<ul>
<li>undefined - 值未定义</li>
<li>boolean - 布尔值</li>
<li>number - 数值</li>
<li>string - 字符串</li>
<li>object - 对象或 null</li>
<li>function - 函数</li>
</ul>
<p>有时候 typeof 操作符会返回一些令人迷惑但技术上正确的值：</p>
<ul><li>对于 null 值会返回 "object"，因为 null 被认为是对象的占位符；</li>
    <li>函数在 ES 中属于对象，但函数也确实有一些特殊的属性，所以将函数从对象中独立出来了。</li>
</ul>

</div>

<div>
<h2>3.4.2 Undefined 类型</h2>
<p>Undefined 类型只有一个值，即特殊的 undefined。当声明的变量未初始化时，该变量的默认值就是 undefined。</p>
<p>ES3 引入这个值是为了正式区分<b>空对象指针</b> null 与 <b>未经初始化的变量</b> undefined。</p>
<p>注意：包含 undefined 值的变量与尚未定义的变量是不一样的，但 typeof 运算符并不真正区分这两种值。</p>
<p>注意：对于未定义的变量，其他运算符会报错，而 typeof 不会报错，这是 typeof 特别的地方。</p>
<pre>var oTemp;
alert(typeof oTemp);  <span>//输出 "undefined"</span>
alert(typeof oTemp2);    //输出 "undefined"
alert(oTemp2 == undefined);  // 代码将引发错误</pre>
<p>当函数无明确返回值时，返回的也是 undefined ：</p>
<pre>function testFunc() {}
alert(testFunc() == undefined);  <span>//输出 "true"</span>
</pre>
</div>

<div>
<h2>3.4.3 Null 类型</h2>
<p>另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面值。</p>
<p>从逻辑角度来看，null 值表示一个空对象指针，而这也是 typeof 操作符检测 null 时会返回 object 的原因。</p>
<p>实际上值 undefined 是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。</p>
<pre>alert(null == undefined);   // 输出 true
alert(null === undefined);  <span>// 输出 false</span>
alert(null == { });         // 输出 false
</pre>
<p>注意：如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null</p>
<p>建议：如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null</p>
</div>

<div>
<h2>3.4.4 Boolean 类型</h2>
<p>Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false</p>
<p>虽然 Bloolean 类型的字面值只有两个，但 ES 中所有类型的值都有与这两个Boolean值等价的值。可以调用转型函数 Boolean() 将一个值转换为其对应的 Boolean 值。下表给出了各种数据类型及其对应的转换规则：</p>
<table>
<tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr>
<tr><td>String</td><td>任何非空字符串</td><td>""（空字符串）</td></tr>
<tr><td>Number</td><td>任何非零数字值（含无穷大）</td><td>0 和 NaN</td></tr>
<tr><td>Object</td><td>任何对象</td><td>null</td></tr>
<tr><td>Undefined</td><td>n/a</td><td>undefined</td></tr>
</table>
<p>这些转换规则对理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换是非常重要的。</p>
</div>

<div>
<h2>3.4.5 Number 类型</h2>
<p>Number 类型 应该是最令人关注的数据类型了，这种类型使用 IEEE754 格式来表示整数和浮点数。</p>
<p>直接输入的（而不是从另一个变量访问的）任何数字都被看做 Number 类型的字面值。

<h3>3.4.5.0 字面值：八进制、十进制和十六进制</h3>
<p>最基本的数字字面量格式是十进制整数，除了十进制表示外，整数也可以通过八进制或十六进制的字面值来表示。</p>
<p>八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7）。</p>
<pre>var iNum = 070;  <span>//070 等于十进制的 56</span>
var octalNum = 079;  // 无效的八进制数值——解释为十进制 79</pre>
<p>注意：如果字面值中的数值超出了范围，那么前导0将被忽略，后面的数值将被当做十进制解析。</p>
<p>注意：八进制字面量在 ES5 严格模式下是无效的，会导致支持该模式的 JS 引擎抛出错误。</p>
<p>要创建十六进制的字面量，前面两位数字必须为 0x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的。</p>
<pre>var iNum = 0x1f;  <span>//0x1f 等于十进制的 31</span>
var iNum = 0xAB;  <span>//0xAB 等于十进制的 171</span>
</pre>
<p class="tip"><span>提示：</span>尽管所有整数都可以用八进制或十六进制的字面值表示，但算术运算返回的结果都用十进制表示。</p>

<h3>3.4.5.1 浮点数</h3>
<p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。</p>
<p>由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ES会不失时机地将浮点数值转换为整数值。</p>
<pre>
var floatNum1 = 1.;   // 小数点后面没有数字，解析为整数1
var floatNum2 = 1.0;  // 整数，解析为整数1
</pre>
<h4>科学计数法</h4>
<p>对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数。例如：</p>
<pre>
var fNum = 5.618e7  // 表示的是数 56180000
var fNum2 = 8e-7    // 表示小数 0.0000008
</pre>
<p>ECMAScript 默认会将那些小数点后面带有6个或以上0的浮点数转换成科学计数法。</p>
<h4>精度 -- 永远不要测试某个特定的浮点数值</h4>
<p>浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。如</p>
<pre>alert(0.1+0.2)  // 结果不是0.3 而是0.30000000000000004</pre>
<p>浮点数值计算会产生舍入误差的问题是所有基于 IEEE754 数值的浮点计算的通病，该问题也同样存在于其他采用IEEE754数值格式的语言。</p>
<p><b>正因为存在浮点计算误差，所以永远不要测试某个特定的浮点数值，如真有需要请转成整数测试！</b></p>

<h3>3.4.5.2 数值范围</h3>
<p>Number.MIN_VALUE -- 保存 ES 能够表示的最小数值，大多浏览器中这个值是 5e-324</p>
<p>Number.MAX_VALUE -- 保存 ES 能够表示的最大数值，大多浏览器中这个值是 1.7976931348623157e+308</p>
<p>Infinity -- 如果某次计算结果超出了 ES 数值范围，那么这个数值将被自动转换成 Infinity 值，如果是负数，则是 -Infinity</p>
<p>Number.POSITIVE_INFINITY 属性保存了 Infinity 值</p>
<p>Number.NEGATIVE_INFINITY 保存了 -Infinity值。</p>
<p>如果某次计算返回了正的或负的 Infinity 值，那么该值将无法参与下一次计算。</p>
<p>可以使用 isFinite() 函数判断一个数值是否是介于最小和最大值之间。</p>
<p>参考资料：关于64位浮点数精度和取值范围：<a href="http://blog.sina.com.cn/s/blog_814e83d80101bgcf.html">IEEE二进制浮点数算术标准</a></p>

<h3>3.4.5.3 NaN</h3>
<p>特殊数值NaN，表示非数值（Not a number），这个数值用于表示一个本来要返回数值的操作却未返回数值的情况（这样就不会抛出错误了）。</p>
<p>NaN 本身有两个非同寻常的特点：</p>
<ul><li>任何涉及 NaN 的操作都会返回 NaN；</li>
    <li>NaN 与任何值不相等，包括 NaN 本身。</li>
</ul>
<h4>isNaN() 函数</h4>
<p>出于以上原因，ES 设计了 isNaN() 函数用于确定一个给定值是否“不是数值”。</p>
<p>isNaN() 在接收到一个值之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回 true</p>
<pre>alert(isNaN("blue"));  // true（不能被转换成数值）</pre>
<p>isNaN() 函数也适用于对象，它首先会调用对象的 valueof() 方法，然后确定返回值是否可以转换为数值，如果不能，基于这个返回值再调用 toString() 方法，再测试返回值。这个过程也是 ES 中内置函数和操作符的一般执行流程。</p>
</div>

<div>
<h2>3.4.6 String 类型</h2>
<p>String 类型的值是由零或多个16位 Unicode 字符组成的字符序列，即字符串。</p>
<p>String 类型的独特之处在于，它是唯一没有固定大小的简单数据类型。</p>
<p>字符串的长度都可以通过访问其 length 属性取得。</p>
<p>字符串字面量是由双引号（"）或单引号（'）声明的。与Java、php等程序不同，单双引号的效果是完全相同的，没有区分。</p>
<h4>转义序列</h4>
<p>String 类型包含一些特殊的字符字面量，也叫作转义序列，用于表示非打印字符或具有其他用途字符：</p>
<table>
<tr><th>字面量</th><th>含义</th></tr>
<tr><td>\n</td><td>换行</td></tr>
<tr><td>\t</td><td>制表符</td></tr>
<tr><td>\b</td><td>退格</td></tr>
<tr><td>\r</td><td>回车</td></tr>
<tr><td>\f</td><td>换页符</td></tr>
<tr><td>\\</td><td>反斜杠</td></tr>
<tr><td>\'</td><td>单引号</td></tr>
<tr><td>\"</td><td>双引号</td></tr>
<tr><td>\x<i>nn</i></td><td>十六进制代码 <i>nn</i> 表示的字符（<i>n</i> 是 0 到 F 中的一个十六进制数字）</td></tr>
<tr><td>\u<i>nnnn</i></td><td>十六进制代码 <i>nnnn</i> 表示的 Unicode 字符（<i>n</i> 是 0 到 F 中的一个十六进制数字）</td></tr>
</table>
<h4>字符串的特点</h4>
<p>ES中字符串是不可变的，也就是说，字符串一旦创建，他们的值是不能改变的。要改变某个变量保存的字符串，需要重新创建一个新的字符串。这也是一些老版本的浏览器中拼接字符串时速度很慢的原因所在，不过现代浏览器已经解决了这个低效率问题。</p>
</div>

<div>
<h2>3.4.7 Object 类型</h2>
<p>ES 中的对象其实就是一组数据和功能的集合。Object 类型是所有它的实例的基础。</p>
<p>从技术角度讲，ECMA-262 中的对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为他们是由宿主实现和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。</p>
</div>

<h1>ECMAScript 类型转换</h1>

<div>
<p>大部分类型具有进行简单转换的方法，还有几个全局方法可以用于更复杂的转换。</p>
</div>

<div>
<h2>3.4.5.3 转换成字符串</h2>
<p>ECMAScript 中 Boolean、Number 和 String 这三种简单类型的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。如：</p>
<pre>var sColor = "red"; alert(sColor.length);  <span>//输出 "3"，字符串拥有 length 属性</span></pre>
<p>总而言之，数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString()方法，该方法返回字符串的一个副本）都有 toString() 方法。但 null 和 undefined 值没有这个方法。</p>
<p>多数情况下，调用 toString() 方法不必传递参数，但是 Number 类型的 toString() 方法可以传递一个参数：输出数值的基数。HTML 采用十六进制表示每种颜色，在 HTML 中处理数字时这种功能非常有用。</p>
<pre>var iNum = 10;
alert(iNum.toString(2));	<span>//输出 "1010"</span>
alert(iNum.toString(8));	<span>//输出 "12"</span>
alert(iNum.toString(16));	<span>//输出 "A"</span>
</pre>
</div>

<div>
<h2>3.4.5.4 转换成数字</h2>
<p>parseInt() 和 parseFloat() 专门用于把字符串转换成数值。</p>
<p>前者把值转换成整数，后者把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。</p>
<h3>parseInt()</h3>
<ul>
<li>它会忽略字符串前面的空格，直到找到第一个非空格字符</li>
<li>如果第一个字符不是数字字符或者负号，返回 NaN，也就是说，parseInt("") 返回 NaN，而 Number("")会返回 0</li>
<li>小数点不会被当做数字字符</li>
<li>parseInt() 能够识别出各种整数格式（十进制、八进制*和十六进制）（ES5 下不再支持识别八进制值，将忽略前导 0 ）</li>
</ul>
<p>parseInt() 方法还有基模式，基是由 parseInt() 方法的第二个参数指定的:</p>
<pre>var iNum1 = parseInt("10", 2);	<span>//返回 2</span>
var iNum2 = parseInt("10", 8);	<span>//返回 8</span>
var iNum3 = parseInt("10", 10);	<span>//返回 10</span>
</pre>
<p>建议：为避免错误的解析，建议无论在什么情况下都明确指定基数，多数情况下，该参数为 10</p>

<h3>parseFloat()</h3>
<p>parseFloat() 方法与 parseInt() 方法的处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成数值。</p>
<ul>
<li>第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。</li>
<li>parseFloat() 只解析十进制数值，因此他没有基模式，同时也会忽略任何前导 0 </li>
<li>如果字符串包含的是一个可解析为整数的数（没有小数点或小数点后都是0），将返回整数</li>
</ul>
<pre>
var fNum2 = parseFloat("0xA");	<span>//返回 0</span>
var fNum4 = parseFloat("11.22.33");	<span>//返回 11.22</span>
var fNum1 = parseFloat("red");	<span>//返回 NaN</span>
</pre>
</div>

<div>
<h2>强制类型转换</h2>
<p>ECMAScript 中可用的 3 种强制类型转换如下：</p>
<ul>
<li>Boolean(value) - 把给定的值转换成 Boolean 值；</li>
<li>Number(value) - 把给定的值转换成数字（可以是整数或浮点数）；</li>
<li>String(value) - 把给定的值转换成字符串；</li>
</ul>

<h3>Boolean() 函数</h3>
<p>当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，Boolean() 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。</p>

<h3>Number() 函数</h3>
<p>Number) 函数的强制类型转换与 parseInt() 和 parseFloat() 方法的处理方式相似，只是<b>它转换的是整个值，而不是部分值</b>，如转换"1.2.3" 将返回 NaN，因为整个字符串值不能转换成数字。</p>
<table>
<tr><td>Boolean</td><td>true 转换为 1；false转换为 0</td></tr>
<tr><td>Number</td><td>简单的传入和返回</td></tr>
<tr><td>Null</td><td>返回 0</td></tr>
<tr><td>Undefined</td><td>返回 NaN</td></tr>
<tr><td>String</td><td>
字符串只包含有效的十六进制格式，例如0xf，则转换成等同的十进制整数；<br />
字符串只包含数字（包括带正负号的情况），则将其转换为十进制数值（前导0会被忽略）<br />
字符串只包含有效的浮点格式，如1.3， 则将其转换为对应的浮点数值（前导0会被忽略）<br />
空字符串转换为0；<br />
字符串中包含除上述格式之外的字符，这返回 NaN</td></tr>
<tr><td>Object</td><td>调用对象的 valueof() 方法，然后依照前面的规则转换返回的值</td></tr>
</table>
<p>注：一元操作符 + 的操作与 Number() 函数相同。</p>
<p>注：由于 Number() 函数在转换字符串时比较复杂而且不够合理，所以应该优先使用 parseInt() parseFloat()</p>

<h3>String() 函数</h3>
<p>最后一种强制类型转换方法 String() 是最简单的，因为它可把任何值转换成字符串。</p>
<p>强制转换 与 toString() 方法的唯一不同之处在于，可以转换 null 和 undefined 而不引发错误：</p>
<pre>var s1 = String(null);	<span>//"null"</span>
var s2 = null.toString();	<span>//会引发错误</span>
</pre>
</div>

</div>
</body>
</html>