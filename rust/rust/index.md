# Rust

### 学习资源

微软出的入门视频教程 https://www.youtube.com/watch?v=2H-O43Hl94c&list=PLlrxD0HtieHjbTjrchBwOVks_sr8EVW1x
极客时间课程 https://time.geekbang.org/column/intro/100085301
中文在线学习教程 https://course.rs


### 常用库

序列化/反序列化
* serde

命令行开发
* clap      - 命令行参数处理
* structopt - 通过结构体来解析命令行参数，是对 clap 库的补充
* colored   - 命令终端彩色显示

异步/Web/网络开发
* tokio   - 异步处理
* tracing - 日志追踪

FFi开发
* libc


API开发
* reqwest - HTTP客户端
* jsonwebtoken
* validator
* protobuf
* hyper

WebAssembly
* wasm-bindgen



* jsonxf  - JSON处理

* anyhow  - 错误处理


* axum    - web服务器

* prost   - ptotobuf 处理
* base64  - base64 编/解码
* mime    - mime类型处理

* lru     - LRU缓存


## 概述

使用合适的工具解决特定问题

* Rust是一门非常重视开发者用户体验的语言（如，编译器报错提示非常详尽）
* 集表达力、高性能、内存安全于一身
  - 内存安全和高性能兼得。让开发者在摒弃垃圾回收(GC)这样的内存和性能杀手的前提下还无需手动管理内存
  - 强大的表现力和高性能兼得。使用起来很像 Python/TypeScript 这样的高级语言但性能不输C/C++

学习 Rust 需要经过一段时间的思维转换（Paradigm Shift）
* 从命令式(imperative)编程转换到函数式(function)编程
* 从变量的可变性(mutable)迁移到不可变性(immutable)，从弱类型语言迁移到强类型语言
* *从手工或者自动内存管理到通过生命周期来管理内存*

如何学好Rust？回归本原，也就是常说的第一性原理：回归事物最基础的条件，将其拆分成基本要素解构分析，来探索解决的问题。

* 分子：所有权和生命周期
* 原子：基本原则
  1. 值被唯一的 scope 拥有，两者（值和scope）共存亡
  2. 值可以移动到另一个 scope，新的 scope 拥有这个值
  3. 一个值可以有多个只读引用和单个可变引用，它们之间是互斥关系
  4. 引用不能超越值的存活期
* 原子核：值在内存中的访问规则
* 基本粒子：堆或栈中值的存储方式

对 Rust 的前途持非常乐观的态度
* 它在系统开发层面可以取代一部分 C/C++ 的场景
* 在服务开发层面可以和 Java/Golang 竞争
* 在高性能前端应用通过编译成 WebAssembly，可以部分取代 JavaScript
* 同时，它又可以方便地通过 FFI 为各种流行的脚本语言提供安全的、高性能的底层库



问答区

【问】Rust 和 Go 在很多领域有重叠，老师如何看待这两门语言  
【答】Rust 和 Go 重叠的领域主要在服务开发领域。
* golang 的优点在于 *简单，上手快*，语言内置并发模型。开发不需要复杂建模的服务开发快性能好。Go for the code that has to ship tomorrow, Rust for the code that has to keep running for the next five years.
* Go带运行时，Rust不带，决定了两者的使用场景不同
  - Go 虽然想做新时代的 C，但因为它 *庞大的运行时* ，不适合做直接和机器打交道的底层开发。*使用场景更多是应用程序、服务等的开发*
  - Rust 的诞生目标就是取代 C/C++，想要做出更好的系统层面的开发工具，所以在语言设计之初就要求不能有运行时。所以你看到的类似 Golang 运行时的库比如 Tokio，都是第三方库，这样可以把是否需要引入运行时的自由度给到开发者。
* 两者未来的前景都很好
  - golang 继续在很多场景取代 Java
  - Rust 在有些场景取代 C/C++，有些场景取代 golang/Java，有些场景取代 JavaScript(通过 WebAssembly)，还能在很多场景帮助其他语言构建高性能的底层库

【问】Rust 目前没有被大规模采用的缺点有哪些  
【答】
* 语言还比较新，整个生态，尤其是web开发相关的生态，在 2019年 1.39 async/await 正式进入语言后才逐渐成熟
* 学习门槛比较高
* 没有有足够号召力的公司(Mozilla还是太小)，不过2021年几大公司的加入让未来可期

【问】求推荐高质量的开源项目供学习参考  
【答】
* 入门可以看看 bytes，代码结构清晰，很容易读
* 网络、异步相关的建议看看 tower 系列、tokio 系列
* 对 DB 感兴趣的可以看看 教学版的 sqlite 实现 https://github.com/joaoh82/rust_sqlite
* 标准库一定要读，用过的数据结构和方法，建议都至少扫一眼源码，对学习很有帮助
* 用到的库都可以扫一扫源码看看质量，有时候也能学到不少新东西

【问】张汉东 - 2021 年 Rust 行业调研报告 https://mp.weixin.qq.com/s/9rjeVgVzmrC0wWhV4wA9FA

为了方便开发者学习 Rust，Rust 官方团队做出了如下努力：

* 独立出专门的社区工作组，编写官方 Rust Book，以及其他各种不同深度的文档，比如编译器文档、nomicon book 等。甚至组织免费的社区教学活动 Rust Bridge，大力鼓励社区博客写作，等等。
* Rust 语言的文档支持 Markdown 格式，因此 Rust 标准库文档表现力丰富。生态系统内很多第三方包的文档的表现力也同样得以提升。
* 提供了非常好用的在线 Playground 工具，供开发者学习、使用和分享代码。
* Rust 语言很早就实现了自举，方便学习者通过阅读源码了解其内部机制，甚至参与贡献。
* Rust 核心团队一直在不断改进 Rust，致力于提升 Rust 的友好度，极力降低初学者的心智负担，减缓学习曲线。比如引入 NLL 特性来改进借用检查系统，使得开发者可以编写更加符合直觉的代码。
* 虽然从 Haskell 那里借鉴了很多类型系统相关的内容，但是 Rust 团队在设计和宣传语言特性的时候，会特意地去学术化，让 Rust 的概念更加亲民。
* 在类型系统基础上提供了混合编程范式的支持，提供了强大而简洁的抽象表达能力，极大地提升了开发者的开发效率。
* 提供更加严格且智能的编译器。基于类型系统，编译器可以严格地检查代码中隐藏的问题。Rust 官方团队还在不断优化编译器的诊断信息，使得开发者可以更加轻松地定位错误，并快速理解错误发生的原因。

Rust 虽然有很多优势，但肯定也存在一些缺点。

* Rust 编译速度很慢。虽然 Rust 官方也一直在改进 Rust 编译速度，包括增量编译支持，引入新的编译后端（ cranelift ），并行编译等措施，但还是慢。而且 增量编译目前也有 Bug。
* 学习曲线陡峭。
* IDE 支持不够完善。比如，对宏代码的支持不是很好（技术上不好实现）。
* 缺乏针对 Rust 语言特有内存不安全问题的各种检测工具。



## 前置知识

导读：回顾软件开发的基础概念：堆、栈、函数、闭包、虚表、泛型、同步和异步等。编程语言只不过是这些概念的具体表达和载体。

* 内存 - 堆、栈
* 数据 - 程序操作的对象：值、类型、指针、引用
* 代码 - 程序运行的主体：函数、方法、闭包、接口、虚表
* 运行方式 - 程序的执行效率：并发、并行、同步、异步
* 编程范式 - 提升代码的质量：泛型编程

### 内存

对于存入栈上的值，它的大小在编译期就需要确定。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。

堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。

一句话对比总结：栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。

#### Demo

```rs
let s = "hello world".to_string();

println!("addr of ss: {:p}, s: {:p}, len: {}, capacity: {}, size: {}", 
        &"hello world", &s, s.len(), s.capacity(), std::mem::size_of_val(&s));
// addr of ss: 0x555aacaad358, s: 0x7ffcb23067d0, len: 11, capacity: 11, size: 24
// s 在栈中包含 ptr len capacity 三个存储单元，在64位系统下为24个字节
```

这段代码跟「只读数据段 RODATA」「堆」「栈」分别有深度交互
* `"hello world"` 作为一个字符串常量，在编译时被存入可执行文件的 `.RODATA` 段（GCC）或 `.RDATA`段（VC++） 然后在程序加载时，获得一个固定的内存地址
* 当执行 `"hello world".to_string()` 时，在堆上一块新的内存被分配出来，并把 "hello world" 逐个字节拷贝过去
* 当我们把对上的数据赋值给 `s` 时，s 作为分配在栈上的一个变量，它需要知道堆上的内存地址。另外 Rust 实现的是 **胖指针**，还记录了分配的堆内存的 `len` 和 `capacity`

#### 栈

栈是程序运行的基础，每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为 **帧 frame**。

栈是自顶向下增长的，一个程序的调用栈最底部，除去「入口帧 entry frame」就是main函数对应的帧。随着函数一层层调用，栈会一层层扩展；调用结束，栈又会一层层回溯，把内存释放回去。

在调用的过程中，一个新的帧会分配足够的空间 *存储寄存器的上下文*。函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器的上下文，就像什么都没有经历一样。此外，函数所需要使用到的 *局部变量*，也都会在帧分配的时候被预留出来。

<img src="https://static001.geekbang.org/resource/image/56/8f/568023dcb61859029aa0eb48c5eb1c8f.jpg" width="412"/>

那一个函数运行时，怎么确定究竟需要多大的帧呢？这要归功于编译器。在编译并优化代码的时候，一个函数就是一个最小的编译单元。在这个函数里，编译器得知道要用到哪些寄存器、栈上要放哪些局部变量，而这些都要在编译时确定。所以编译器就需要明确每个局部变量的大小，以便于预留空间。*在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上*。

栈上的内存分配是非常高效的，只需要改动栈指针（stack pointer），就可以预留相应的空间；把栈指针改动回来，预留的空间又会被释放掉。预留和释放只是动动寄存器，不涉及额外计算、不涉及系统调用，因而效率很高。所以理论上说，只要可能，我们应该把变量分配到栈上，这样可以达到更好的运行速度。那为什么在实际工作中，我们又要避免把大量的数据分配在栈上呢？这主要是考虑到调用栈的大小，避免栈溢出（stack overflow）。

#### 堆

当我们 *需要动态大小的内存时只能使用堆*，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上。

堆上分配内存时，一般都会预留一些空间，这是最佳实践。如果我们需要多少就分配多少，那列表每次新增值，都要新分配一大块的内存，先拷贝已有数据，再把新的值添加进去，最后释放旧的内存，这样效率很低。

除了动态大小的内存需要被分配到堆上外，*动态生命周期的内存也需要分配到堆上*。堆上分配出来的每一块内存需要显式地释放，这就使堆上内存有更加灵活的生命周期，可以在不同的调用栈之间共享数据。

堆内存的这种灵活性也给内存管理带来很多挑战。
* 堆上内存分配后忘记释放，就会造成*内存泄漏*
* *堆越界*是第一大内存安全问题
* *悬空指针*第二大内存安全问题

为了避免堆内存手动管理造成的这些问题
* 以 Java 为首的一系列编程语言，采用了追踪式垃圾回收（Tracing GC）的方法，来自动管理堆内存。这种方式通过定期标记（mark）找出不再被引用的对象，然后将其清理（sweep）掉，来自动管理内存，减轻开发者的负担。
* 而 ObjC 和 Swift 则走了另一条路：自动引用计数（Automatic Reference Counting）。在编译时，它为每个函数插入 retain/release 语句来自动维护堆上对象的引用计数，当引用计数为零的时候，release 语句就释放对象。

### 其他基本概念

#### 数据

值和类型、指针和引用

原生类型（primitive type）是编程语言提供的最基础的数据类型。比如字符、整数、浮点数、布尔值、数组（array）、元组（tuple）、指针、引用、函数、闭包等。所有原生类型的大小都是固定的，因此它们可以被分配到栈上。

指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到任意数据类型。引用（reference）和指针非常类似，不同的是，引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用。


#### 代码

函数、方法、闭包、接口和虚表

数据是程序操作的对象，而代码是程序运行的主体，也是我们开发者把物理世界中的需求转换成数字世界中逻辑的载体。

**闭包** 是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。一般来说，如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包。

很多编程语言都有 **接口** 的概念，允许开发者面向接口设计，比如 Java 的 `interface`、Elixir 的 `behaviour`、Swift 的 `protocol` 和 Rust 的 `trait`。

当我们在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力。但是，在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，我们无法单纯从一个指针分析出这个引用具备什么样的能力。因此，在生成这个引用的时候，我们需要构建胖指针，除了指向数据本身外，还需要指向 *一张涵盖了这个接口所支持方法的列表*。这个列表，就是我们熟知的 **虚表 virtual table**。为每个数据构造他们各自对接口实现的虚表，这样可以依旧调用到属于该类型的实现。虚表在编译时就生成并放在了二进制文件中（大多是 RODATA 段中）。所以虚表是每个 (Trait, Type) 一份。并且在编译时就生成好了。

#### 运行方式

并发并行、同步异步、Promise/async/await

**并发**是同时与多件事情打交道的 *能力*，比如系统可以在任务1做到一定程度后，保存该任务的上下文，挂起并切换到任务2，然后过段时间再切换回任务1。**并行**是同时处理多件事情的*手段*。

**异步**是指一个任务开始执行后，与它没有因果关系的其它任务可以正常执行，不必等待前一个任务结束。在异步操作里，异步处理完成后的结果，一般用 Promise 来保存，它是一个对象，用来描述在未来的某个时刻才能获得的结果的值。如果你对 Promise 这个词不太熟悉，在很多支持异步的语言中，`Promise` 也叫 `Future` / `Delay` / `Deferred` 等。

大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用状态机将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读。

#### 编程范式

泛型编程

为了在不断迭代时，更好地维护代码，我们还会引入各种各样的编程范式，来提升代码的质量。

数据结构的泛型是一种高级抽象。让我们可以延迟绑定，让数据结构的通用性更强，适用场合更广阔；也大大减少了代码的重复，提高了可维护性。




## 核心知识点

导读：深入浅出地探讨 Rust 变量的所有权和生命周期，并对比几种主流的内存管理方式，包括 C 的手工管理、Java 的 GC、Swift 的 ARC。之后围绕所有权和生命周期，来讨论Rust的几大语言特性：函数式编程、类型系统、泛型编程 以及 错误处理。

### 所有权

对于堆内存多次引用的问题
* C/C++ 要求开发者手工处理。非常不方便，一个不慎就会内存泄漏
* Java/Go 等语言使用追踪式GC，即通过定期扫描堆上数据的引用来替开发者管理堆内存。但GC带来的STW问题让使用场景受限，性能损耗也不小
* Objective/Swift 使用自动引用计数(ARC)，在编译时自动添加维护引用计数的代码，也有不小的运行时性能损耗
* Rust 通过单一所有权限制任意引用的行为
  - 所有权共享势必会带来使用和释放上的不明确，只能采用 追踪式GC 或 ARC 这些影响运行时性能的方案来解决
  - 相比 GC 和 ARC，Rust 增加了很多概念，单一所有权限制 和 新增的概念 明显提高了语言门槛
  - 相比 C 来说，提供了一种 不影响运行时性能的 内存管理方案

Rust 针对单一所有权给出了3条规则

* 一个值只能被一个变量所拥有，这个变量被称为所有者 （Each value in Rust has a variable that’s called its owner）
* 一个值同一时刻只能有一个所有者 （There can only be one owner at a time）
* 当所有者离开作用域，其拥有的值被丢弃 （When the owner goes out of scope, the value will be dropped）

---

* Move 
* Copy
* Borrow 为了跟其他语言的「引用」做区分，这里用了「借用」


如果数据结构实现了 Copy trait，就会使用 Copy 语义，自动把值复制一份，原有的变量还能继续访问。

Rust 下堆变量的生命周期不具备独立性，是跟栈上的所有者牢牢绑定的。所以堆变量引用栈变量不会导致生命周期错乱。


Rust 处理很多问题的思路：编译时，处理大部分使用场景，保证安全性和效率；运行时，处理无法在编译时处理的场景，会牺牲一部分效率，提高灵活性。

### 生命周期



## 类型系统

导读：Pascal 之父有一个著名的公式：算法 + 数据结构 = 程序。想随心所欲地使用 Rust 为你的系统构建数据结构，深度掌握类型系统必不可少。


在 Rust 里，你可以使用 Trait 做接口设计、使用泛型做编译期多态、使用 Trait Object 做运行时多态。在你的代码里用好 Trait 和泛型，可以非常高效地解决复杂的问题。

随后我们会介绍 unsafe rust，不要被这个名字吓到。所谓 unsafe，不过是把 Rust 编译器在编译器做的严格检查退步成为 C++ 的样子，由开发者自己为其所撰写的代码的正确性做担保。

最后我们还会讲到 FFI，这是 Rust 和其它语言互通操作的桥梁。掌握好 FFI，你就可以用 Rust 为你的 Python/JavaScript/Elixir/Swift 等主力语言在关键路径上提供更高的性能，也能很方便地引入 Rust 生态中特定的库。




Rust 语言通过精致的设计，将机器可以检查控制的部分都交给编译器来执行，而将机器无法控制的部分交给开发者自己来执行。

以下是我总结的五条使用 Unsafe 的简单规范，方便大家做权衡：

* 能用 Safe Rust 就用 Safe Rust
* 为了性能可以使用 Unsafe Rust
* 在使用 Unsafe Rust 的时候确保不要产生UB，并且尽量判断其安全边界，抽象为 Safe 方法
* 如果无法抽象为 Safe，需要标注为 Unsafe，并配以产生 UB 的条件文档
* 对于 Unsafe 的代码，大家可以重点 review


## 并发



从没有一门语言像 Rust 这样，在提供如此广博的并发原语支持的前提下，还能保证并发安全，所以 Rust 敢自称无畏并发（Fearless Concurrency）。在并发篇，我带你从 atomics 一路向上，历经 Mutex、Semaphore、Channel，直至 actor model。其他语言中被标榜为实践典范的并发手段，在 Rust 这里，只不过是一种并发工具。Rust 还有目前最优秀的异步处理模型，我相信假以时日，这种用状态机巧妙实现零成本抽象的异步处理机制，必然会在更多新涌现出来的语言中被采用。在并发处理这个领域，Rust 就像天秤座圣衣，刀枪剑戟斧钺钩叉，十八般兵器都提供给你，让你用最合适的工具解决最合适的问题。




## 实战篇


