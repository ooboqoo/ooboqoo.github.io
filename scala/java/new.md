# Java 新特性

Java 的发展从 1995 年开始经历了许多过程，但是其中有如下4个最具代表性的 JDK 版本。
  * 1995年的 JDK1.0，标志着 Java 正式登场
  * 1998年的 JDK1.2，加入 javax.swing 组件
  * 2005年的 JDK1.5，引入自动装箱与拆箱、可变参数、泛型、枚举、Annotation 等核心特性，并且这些特性一直被广泛使用
  * 2014年的 JDK1.8，引入 Lamda 表达式(函数式编程)，同时针对接口定义也有所增强

### 可变参数

开发中可能会出现这样一种情况：不确定要传递的参数个数。最早的时候，为了解决这个问题，往往需要将多个参数封装为数组。从JDK1.5开始，为了解决这个问题，专门在方法定义上提供了可变参数的概念，语法形式如下：

```java
返回值类型 方法名称(参数类型 ... 变量) { /* 方法体 */ }
```

方法在使用可变参数定义后，调用处可以任意传递多个参数，或者直接传递一个数组。而方法本身对于多个参数的处理都统一使用数组进行接收。

### foreach 循环

从 JDK1.5开始，对于数组循环提供了一种简化的写法：

```java
for (数据类型 变量 : 数组或集合) { /* 循环体 */ }
```

### 静态导入

如果一个类中的方法全部都是 static 类型，那么其他类要引用此类时必须先使用 import 导入所需要的包，再使用 `类名.方法()` 进行调用。而使用静态导入，则不再需要写类名即可直接使用静态方法：

```java
import static 包.类.*;
```

### 泛型

利用对象的多态性可以解决方法参数的统一问题，但是随之而来的是一个新问题：向下转型会存在类转换异常，且编译期无法发现。

JDK1.5 引入了泛型技术，此技术的核心意义在于：类属性或方法的参数在定义数据类型时，可以直接使用一个标记进行占位，在具体使用时才设置其对应的实际数据类型，这样当设置的数据类型出现错误后，就可以在程序编译时检测出来。

```java
calss 类名<泛型标记1, 泛型标记2> {
  // 类内部使用泛型标记来表示类型
}
```

使用泛型后，所有类中属性的类型都是动态设置的，而所有使用泛型标记的方法参数类型也都发生了改变，这样就相当于避免了向下转型的问题，从而解决了类对象转换的安全隐患。

注1：因为历史原因，实例化含泛型类的对象时，允许不设置泛型类型，系统会采用 Object 类型，此时编译器不会报错但会给出警告。
注2：泛型的类型，只能够是引用类型，不能是基本类型。
注3：从JDK1.7开始，对泛型操作进行了一些简化，只要在类对象声明时指定了泛型类型，那么实例化对象时不用再重复指定：`Message<Integer> m = new Message();`

#### 通配符

引入泛型技术解决了向下转型所带来的安全隐患，但同时又会产生一个新问题：即便是同一个类，由于设置泛型类型不同，其对象表示的含义也不同，因此不能够直接进行引用传递操作。而在方法定义时，参数类型又不对泛型进行区分，因此需要通配符 `?` 来解决参数传递上造成的新问题。

```java
// 报错，泛型类型不兼容
Message<Double> m = new Message<String>();

// 以下这样重载方法不被允许，报错，因为方法重载只要求参数类型不同，而对泛型不做区分
void foo(Message<String> p) { }
void foo(Message<Integer> p) { }

// 使用通配符 `?` 解决参数传递问题
void foo(Message<?> p) { }
```

#### 泛型接口

泛型不仅可以定义在类中，也可以定义在接口上。定义在接口上的泛型被称为泛型接口。

#### 泛型方法

泛型除了可以应用在类上，也可以应用在方法上。在方法上定义泛型时，这个方法不一定非要在泛型类中定义。


### 枚举









