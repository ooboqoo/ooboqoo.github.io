# 宏观视角下的浏览器

## Chrome 架构

仅仅打开了1个页面，为什么会有4个进程？

### 进程和线程

多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。一个进程就是一个程序的运行实例。进程和线程之间的关系有以下 4 个特点。
1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。进程隔离是为保护系统中进程互不干扰的技术。进程之间需要进行数据通信就要使用 IPC 机制了。

### 单进程浏览器时代

顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。
1. 不稳定
  * 早期浏览器需要借助 *插件* 来实现一些功能增强，但插件是最容易出问题的模块，一个插件的意外崩溃会导致整个浏览器崩溃
  * *渲染引擎模块* 也是不稳定的，通常一些复杂的 JS 代码就可能引起渲染引擎模块的崩溃，进而导致浏览器崩溃
2. 不流畅
  * 所有页面的渲染模块、JS执行环境以及插件都是运行在统一线程中的，这就意味着同一时刻只能有一个模块可以执行
  * 除了脚本或者插件会让单进程浏览器变卡顿外，*页面的内存泄露*也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。
3. 不安全
  * 插件可以使用 C/C++ 等代码编写，插件可以获取到操作系统的任意资源，当你在页面中运行插件时你的电脑信息将完全暴露
  * 页面脚本可以通过浏览器的漏洞来获取系统权限，获取系统权限之后也可以对你的电脑做一些恶意的事情

### 多进程浏览器时代

2008年 Chrome 刚发布时的进程架构，每个页面都运行在单独的渲染进程中，同时页面里的插件也运行在单独的插件进程中，而进程之间通过 IPC 机制进行通信。

<img src="images/browser-single-process.png" width="571">

1. 解决不稳定：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面经常或者插件进程
2. 解决不流程：即使 JS 阻塞了渲染进程，影响到的也只是当前页面；至于内存泄露问题就更简单了，当一个页面关闭时，整个渲染进程也会被关闭，其所占资源都会被系统回收
3. 解决不安全：采用多进程架构的额外好处是可以使用 *安全沙箱*，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。恶意程序也无法突破沙箱去获取系统权限。

### 目前多进程架构

Chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。

<img src="images/chrome-multi-process.png" width="571">

最新的 Chrome 浏览器包括：1个浏览器主进程、1个 GPU 进程、1个网络进程、多个渲染进程和多个插件进程。

* 浏览器进程，主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
* 渲染进程，核心任务是将 HTML、CSS 和 JS 转换为用户可以与之交互的网页，排版引擎 Blink 和 JS 引擎 V8 都运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。。出于安全考虑，渲染进程都运行在沙箱模式下。
* GPU 进程，Chrome 刚开始发布的时候并没有 GPU 进程。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求，于是有了独立的 GPU 进程。
* 网络进程，主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来。
* 插件进程，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

* 更高的资源占用，因为每个进程都会包含公共基础结构的副本(如 JS 运行环境)，这就意味着浏览器会消耗更多的内存资源。
* 更复杂的体系架构，浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。

> 问答：同站点进程复用  
> 当根域名和协议都相同时即为同站点，这跟同源策略是有区别的  
> Chrome 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。

### 未来面向服务的架构

<img src="images/chrome-soa-1.png" width="571">
<img src="images/chrome-soa-2.png" width="571">

为了解决多进程架构带来的问题，在 2016年 Chrome 团队使用 面向服务的架构(Services Oriented Architecture, SOA) 的思想设计了新的机构。原来的各种模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义好的接口，通过 IPC 来通信，从而 *构建一个更内聚、松耦合、易于维护和扩展的系统*，更好实现 Chrome 简单、稳定、高速、安全的目标。目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。

同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上，Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

### 总结

本文我主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。

最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。

鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。

总体说来，Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利。


## TCP 协议

在衡量 Web 页面性能的时候有一个重要的指标叫 FP(First Paint)，是指从页面加载到首次开始绘制的时长，这个指标直接影响了用户的跳出率。那什么影响 FP 指标呢？其中一个重要的因素是 *网络加载速度*。

互联网，实际上是一套理念和协议组成的体系架构。其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。

#### IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合 **网际协议(Internet Protocol，IP)标准**。互联网上不同的在线设备都有唯一的地址，地址只是一串数字，这和大部分家庭收件地址类似，你只需要知道一个家庭的具体地址，就可以往这个地址发送包裹，这样物流系统就能把物品送到目的地。计算机的地址就称为 **IP 地址**，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 **IP 头**的数据结构里。IP 头是 IP 数据包开头的信息，*包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息*。

#### UDP：把数据包送达应用程序

<img src="images/udp.png" width="571">

IP 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，因此，需要基于 IP 之上开发能和应用打交道的协议，最常见的是 **用户数据包协议(User Datagram Protocol，UDP)**。

UDP 中一个最重要的信息是 **端口号**，每个想访问网络的程序都需要绑定一个端口号。通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以 *IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序*。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。虽说 *UDP 不能保证数据可靠性，但是传输速度却非常快*，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

#### TCP：把数据完整地送达应用程序

<img src="images/tcp.png" width="571">

对于浏览器请求，或者邮件这类要求数据传输可靠性(reliability)的应用，如果使用 UDP 来传输会存在两个问题：
* 数据包在传输过程中容易丢失；
* 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

基于这两个问题，引入 **传输控制协议(Transmission Control Protocol，TCP)**，TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:
* 对于数据包丢失的情况，TCP 提供重传机制；
* TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

一个完整的 TCP 连接的生命周期包括了 建立连接、传输数据、断开连接 三个阶段。TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。


## HTTP 请求流程

![](images/http.png)

HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件。此外，HTTP 也是浏览器使用最广的协议，所以要想学好浏览器，就要先深入了解 HTTP。

### 浏览器端发起 HTTP 请求流程

1. 构建请求。浏览器构建 **请求行**信息(如 `GET /index.html HTTP1.1`)，准备发起网络请求。
2. 查找缓存。在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。如果存有副本，就拦截请求，返回该资源的副本，并直接结束请求。
3. 准备 IP 地址和端口。浏览器使用 *HTTP协议作为应用层协议*，用来封装请求的文本信息；并使用 *TCP/IP 作传输层协议*将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。由于 IP 地址是数字标识难以记忆，但使用域名就好记多了，所以基于这个需求又出现了一个服务 **域名系统(Domain Name System，DNS)**，负责把域名和 IP 地址做一一映射关系。这样一路推导下来，你会发现在 *第一步浏览器会请求 DNS 返回域名对应的 IP*。当然浏览器还提供了 **DNS 数据缓存服务**，如果某个域名已经解析过了，浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。
4. 等待 TCP 队列。Chrome 下同一个域名同时最多只能建立 6 个 TCP 连接，其余请求会进入排队等待状态。
5. 建立 TCP 连接。在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。
6. 发送 HTTP 请求。TCP 连接一旦建立，浏览器就可以和服务器进行通信了，HTTP 中的数据正是在这个通信过程中传输的。
  * 首先浏览器会向服务器发送**请求行**，它包括了请求方法、请求 URI(Uniform Resource Identifier)和 HTTP 版本协议。
  * 之后，还要以**请求头**的形式发送一些其他信息，比如 UA、当前请求的域名、Cookie 等等。
  * 最后发送**请求体**(如果有的话)。

### 服务器端处理 HTTP 请求流程

```text
curl -v http://ngapps.cn

* Rebuilt URL to: http://ngapps.cn/
*   Trying 47.102.130.191...
* TCP_NODELAY set
* Connected to ngapps.cn (47.102.130.191) port 80 (#0)
> GET / HTTP/1.1
> Host: ngapps.cn
> User-Agent: curl/7.58.0
> Accept: */*
>
< HTTP/1.1 301 Moved Permanently
< Server: nginx/1.14.0 (Ubuntu)
< Date: Mon, 14 Oct 2019 10:09:54 GMT
< Content-Type: text/html
< Content-Length: 194
< Connection: keep-alive
< Location: https://ngapps.cn/
<
<html>
<head><title>301 Moved Permanently</title></head>
<body bgcolor="white">
<center><h1>301 Moved Permanently</h1></center>
<hr><center>nginx/1.14.0 (Ubuntu)</center>
</body>
</html>
* Connection #0 to host ngapps.cn left intact
```

### 补充知识

#### 持久连接

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。如果浏览器或服务器在其头信息中加入了：`Connection: Keep-Alive`，那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。*保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度*。

#### 浏览器缓存

<img src="images/cache.png" width="571">



## 导航流程


## 渲染流程


