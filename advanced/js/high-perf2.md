# 高性能 JavaScript

## 6. 快速响应的用户界面

### 6.1 浏览器 UI 线程

用于执行 JS 和更新用户界面的进程通常被称为 "浏览器 UI 线程"。UI 线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是执行 JS 代码，要么是执行 UI 更新，包括重绘和重排。也许这个进程最有趣的部分在于每一次输入可能会导致一个或多个任务被加入队列。

空闲状态是理想的，因为用户所有的交互都会立刻触发 UI 更新。如果用户试图在任务运行期间与页面交互，不仅没有即时的 UI 更新，甚至可能新的 UI 更新任务都不会被创建并加入队列。事实上，大多数浏览器在 JS 运行时会停止把新任务加入 UI 线程的队列中，也就是说 JS 任务必须尽快结束，以避免对用户体验造成不良影响。

#### 浏览器限制

浏览器限制了 JS 任务的运行时间。这种限制是有必要的，它确保某些恶意代码不能通过永不停止的密集操作锁住用户的浏览器或计算机。此类限制分两种：调用栈大小限制和长时间运行脚本限制。

浏览器允许脚本持续运行好几秒，但这并不意味着你也允许它这样做。事实上，为了更好的用户体验，你的 JS 代码运行的持续时间应当远远小于浏览器的限制。单个 JS 操作花费的总时间不应该超过 100 毫秒。超过 100 毫秒用户就能够感觉到卡顿了。

当脚本执行时，UI 不随用户交互而更新。执行时间段内用户交互行为所引发的 JS 会被加入队列中，但这段时间内由用户交互行为引发的 UI 更新会被自动跳过，因为页面中的动态变化部分会被优先考虑。因此，在一个脚本运行期间点击一个按钮，将无法看到它被按下的样式，尽管它的 onclick 事件处理器会被执行。


### 6.2 使用定时器让出时间片段

尽管你尽了最大努力，但难免会有一些复杂的 JS 任务不能再 100 毫秒或更短事件内完成。这个时候，最理想的方法是让出 UI 线程的控制权，使得 UI 可以更新。让出控制权意味着停止执行 JS，于是 JS 定时器走进了我们的视野。

创建一个定时器会造成 UI 线程暂停，如同它从一个任务切换到下一个任务。因此，定时器代码会重置所有相关的浏览器限制，包括长时间运行脚本定时器。此外，调用栈也在定时器的代码中重置为 0。这一特性使得定时器成为长时间运行 JS 代码理想的跨浏览器解决方案。

#### 定时器的精度

JS 定时器延迟通常都不太精准，相差约几毫秒，因此不可用户测量实际时间。大多数浏览器在定时器延时等于或小于10 毫秒是表现不太一致，所以延迟的最小值建议不小于 20 毫秒。

#### 分割任务

我们通常会把一个任务分解成一系列子任务。如果一个函数运行时间太长，那么检查一下是否可以把它拆分为一系列能在较短时间内完成的子函数。

```js
var tasks = [openDocument, writeText, closeDocument, updateUI];
setTimeout(function run() {
  var task = tasks.shift();
  task();
  if (tasks.length > 0) { setTimeout(run, 20) }
}, 20);
```

有时如果单个任务的执行时间很短，这样使用刚才的方法，效率就显得低下。我们可以换一种方式，每个任务执行完毕后判断代码持续时长是否超过 50 毫秒，超过就设置定时器然后中断，否则继续下个任务。

```js
function run () {
  var start = +new Date();
  while (true) {
    someLongProcess();
    if(new Date() - start > 50) { return setTimeout(run, 20); }
  }
}
```

### 6.3 Web Workers

自 JS 诞生以来，还没有办法在浏览器 UI 线程之外运行代码。 Web Workers API 改变了这种状况，它引入了一个接口，能使代码运行且不占用浏览器 UI 线程的时间。Web Workers 给 Web 应用带来潜在的巨大性能提升，因为每个新的 Worker 都在自己的线程中运行代码。

#### Worker 运行环境

由于 Web Workers 没有绑定 UI 线程，这也意味着它们不能访问浏览器的许多资源。JS 和 UI 共享同一进程的部分原因是它们之间互相访问频繁。

每个 Web Worker 都有自己的全局运行环境，其功能只是 JS 特性的一个子集。Worker 运行环境由如下部分组成：
* 一个 `navigator` 对象，只包括四个属性：`appName` `appVersion` `userAgent` 和 `platform`
* 一个 `location` 对象，与 `window.lcation` 相同，但所有属性都是只读的
* 一个 `self` 对象，指向全局 worker 对象
* 一个 `importScripts()` 方法，用来加载 Worker 所用到的外部 JS 文件
* 所有 ECMAScript 对象
* `XMLHttpRequest` 构造器
* `setTimeout()` 和 `setInterval()` 方法
* 一个 `close()` 方法，用于停止 Worker 自身运行 (外部关闭用 `myWorker.terminate();`)

由于Web Worker 有着不同的全局运行环境，因此你需要创建一个完全独立的 JS 文件，来包含 Worker 中运行的代码。创建工人线程，需要传入这个 JS 文件的 URL，`var worker = new Worker('path/to/code.js');` 此代码一旦执行，将为这个文件创建一个新的线程和一个新的 Worker 运行环境。该文件会被异步下载，直到文件下载并执行完成后才会启动此 Worker。

#### 与 Worker 通信

Worker 与网页代码通过事件接口进行通信 postMessage() 用于发送信息，通过监听 onmessage 事件接收信息。

#### 实际应用

Web Workers 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。尽管它看上去用处不大，但 Web 应用中通常有一些数据处理功能将受益与 Worker 而不是定时器。

解析一个大字符串只是许多受益任务之一，其他可能受益的任务是：
  * 编码/解码大字符串
  * 复杂数学运算(包括图像或视频处理)
  * 大数组排序

任何超过 100 毫秒的处理过程，都应当优先考虑 Worker 方案而不是定时器方案。


## 7. Ajax

Ajax 是高性能 JS 的基础。它可以通过延迟下载体积较大的资源文件来使得页面加载速度更快。它通过异步的方式在客户端和服务器之间传输数据，从而避免页面资源一窝蜂地下载。它甚至可以只用一个 HTTP 请求就获取整个页面的资源。选择适合的传输方式和最有效的数据格式，可以显著改善用户和网站的交互体验。

本章会介绍从服务器收发数据速度最快的技术，以及最为有效的数据编码格式。

### 7.1 数据传输

Ajax，从最基本的层面来说，是一种与服务器通信而无须重载页面的方法；数据可以从服务器获取或发送给服务器。有多种不同的方法建立这种通信通道，每种方法都有各自的优点和限制。

#### 请求数据

有五种常用技术用于向服务器请求数据：XMLHttpRequest(XHR); Dynamic script tag insertion; iframes; Comet; Multipart XHR。XHR、动态脚本注入、multipart XHR 是常用的三种技术，Comet 和 iframes 往往用在极端情况下，暂不讨论。

XHR 是最常用也最强大的数据请求技术，它允许异步发送和接收数据。由于 XHR 提供了高级的控制，跨域请求默认被阻止。

动态脚本技术克服了 XHR 的最大限制：跨域，这是一个 Hack，你不需要实例化一个专用对象，而可使用 JS 创建一个新的脚本标签，并设置它的 src 属性为不同域的 URL。但与 XHR 相比，动态脚本注入提供的控制是有限的，你不能设置请求头，参数传递也只能用 GET，你也无法知道请求是否超时。

使用动态脚本这种技术从那些你无法直接控制的服务器上请求数据时需要小心。JS 没有任何权限和访问控制概念，因此你使用动态脚本注入添加到页面中的任何代码都可以完全控制整个页面。包括修改任何内容，把用户重定向到其他网站，甚至跟踪用户在页面上的操作并发送数据到第三方服务器。

MXHR 允许客户端只用一个 HTTP 请求就可以从服务端向客户端传送多个资源。它通过在服务端将资源打包成一个由双方约定的字符串分隔的长字符串并发送到客户端。然后用 JS 代码处理，并根据它的 mime-type 类型和传入的其他头信息解析出每个资源。

由于 MXHR 响应消息的体积越来越大，因此有必要在每个资源收到时就立刻处理，而不是等到整个响应消息接收完成。这可以通过监听 readyState 为 3 的状态来实现：

```js
var req = new XMLHttpRequest();
var intervalFlag, lastLength = 0;
req.open('GET', 'rollup_image.php', true);
req.onreadystatechange = readyStateHandler;
req.sen(null);

function readyStateHandler() {
  if (req.readyState === 3 && intervalFlag === null) {
    intervalFlag = window.setInterval(getLatestPacket, 15);  // 开始轮询
  }
  if (req.readyState === 3) {
    clearInterval(intervalFlag);
    getLatestPacket();           // 获取最后一个数据包
  }
}

function getLatestPacket() {
  var length = req.responseText.length;
  var packet = req.responseText.substring(lastLength, length);  // 这是一种基于流的思想
  processPacket(packet);
  lastLength = length;
}
```

MXHR 技术的最大缺点是资源不能被浏览器缓存。由于 HTTP 请求是 Ajax 中最大的瓶颈，通过 MXHR 传送大量小的文件时，可以提速 4 - 10 倍。

#### 发送数据

有时候你不关心接受数据，而只需要将数据发送给服务器。你可以发送不涉及隐私的用户信息以备日后分析，或者也可以捕获所有脚本错误并把细节发送到服务器进行记录和报警。当数据只需要发送到服务器时，有两种广泛使用的技术：XHR 和信标 beacons。

虽然 XHR 主要用于从服务器获取数据，但它同样能用于把数据传回服务器。当使用 XHR 发送数据时，GET 方式会更快，因为，对于少量数据而言，一个 GET 请求只发送一个数据包，而一个 POST 请求至少要发送两个数据包，一个装载头信息，另一个装载 POST 正文。POST 更适合发送大量数据到服务器，因为它不关心额外数据包的数量。

图像灯塔 Beacons 技术非常类似动态脚本注入。使用 JS 创建一个新的 Image 对象，并把 src 属性设置为服务器上脚本的 URL，该 URL 包含了我们要通过 GET 传回的键值对数据。

```js
var url = '/status_tracker.php';
var params = ['step=2', 'time=1248027314'];
new Image().src = url + '?' + params.joint('&');  // 无须添加到页面中，指定或更改 src 都会立马会执行
```

服务器会接收到数据并保存下来，它无需向客户端发送任何回馈信息，因此也没有图片会实际显示出来。这是给服务器回传信息最有效的方式。它的性能消耗很小，而且服务端的错误完全不会影响到客户端。

如果不需要在响应中返回数据，服务器应该发送一个不带消息正文的 204 No Content 状态码，它将阻止客户端继续等待永远不会到来的消息正文。

### 7.2 数据格式

当考虑数据传输技术时，你必须考虑功能集、兼容性、性能以及方向。当考虑数据格式时，唯一需要比较的标准就是速度。

通常来说，数据格式越轻量级越好，JSON 和字符串分隔的自定义格式是最好的。如果数据集很大并且对解析时间有要求，那么就从如下两种格式中作出选择：
  * JSON-P 数据，使用动态脚本注入获取，它把数据当做可执行 JS 而不是字符串，解析速度极快。它能跨域使用，但涉及敏感数据时不应该使用它。
  * 字符分隔的自定义格式，使用 XHR 或动态脚本注入获取，用 `split()` 解析。这项技术解析大数据集比 JSON-P 略快，而且通常文件尺寸更小。

### 7.3 Ajax 性能指南

一旦你选择了合适的数据传输技术和数据格式，那么就可以开始考虑其他优化技术了。

#### 缓存数据

最快的 Ajax 请求是没有请求，有两种主要的方法可避免发送不必要的请求：
  * 在服务端，设置 HTTP 头信息以确保你的响应会被浏览器缓存。这种技术简单且好维护
  * 在客户端，把获取的信息存储到本地，从而避免再次请求。这种技术给你最大的控制权

服务器端设置 `Expires` 头信息，可以在 Nginx 服务器中配置，还可以对个别资源通过脚本手动设置 `Expires` 头实现精确控制。

本地数据存储，除了依赖浏览器处理缓存外，你还可以用更手工的方式来实现，及直接把从服务器中接收到的数据存储起来。

#### 了解 Ajax 类库的局限

所有的 JS 类库都允许你访问一个 Ajax 对象，它屏蔽了浏览器之间的差异，给你一个统一的接口。大多数情况下这是好事，然而，为了给你一个统一的接口，这些类库必须简化接口，这使得你不能访问 XHR 的完整功能，譬如前面提到的 MXHR 技术，多数类库都不允许你直接访问 `readystatechange` 事件，也就无法使用。

直接操作 XHR 对象减少了函数开销，进一步提升了性能。需要注意的是，如果放弃使用 Ajax 类库，你可能在一些古怪的浏览器上遇到一些问题。


## 8. 编程实践

#### 避免双重求值

JS 像其他很多脚本语言一样，允许你在程序中提取一个包含代码的字符串，然后动态执行它。有4种标准方法可以实现：`eval()`、`Function()` 构造函数、`setTimeout()` 和 `setInterval()`。

当你在 JS 代码中执行另一段 JS 代码时，都会导致双重求值的性能消耗。双重求值是一项代价昂贵的操作，每次都要创建一个新的解析器/编译器实例，这必然使得代码执行的速度变慢。

#### 使用 Object/Array 字面量

#### 避免重复工作

也许最常见的重复工作就是浏览器探测。可以通过延迟加载 lazy loading 或 条件预加载 conditional advance loading 来规避。

调用延迟加载函数时，第一次总会消耗较长的时间，因为它必须运行检测接着再调用另一个函数完成任务。当一个函数在页面中不会立刻调用时，延迟加载时最好的选择。

条件预加载会在脚本加载期间提前检测，而不会等到函数被调用。检测操作依然只有一次，只是过程来得更早一些。预加载适用于一个函数马上就要被用到，并且在整个页面的生命周期中频繁出现的场合。

```js
// 延迟加载
function addHandler(target, eventType, handler) {
  if (target.addEventListener) {
    addHandler = function (target, eventType, handler) {
      target.addEventListener(eventType, handler, false);
    };
  } else {
    addHandler = function (target, eventType, handler) {
      target.attachEvent('on' + eventType, handler);
    };
  }
  addHandler(target, eventType, handler);
}

// 条件预加载
var addHandler = document.body.addEventListener ?
  function (target, eventType, handler) {
    target.addEventListener(eventType, handler, false);
  } :
  function (target, eventType, handler) {
    target.attachEvent('on' + eventType, handler);
  };
```

#### 使用速度快的部分

尽管 JS 经常被指责运行缓慢，但这门语言的某些部分运行却快地让人难以置信。这并不足为奇，因为 JS 引擎是由低级语言构建的。虽然 JS 速度慢很容易被归咎于引擎，然而引擎通常是处理过程中最快的部分，运行速度慢的实际上是你的代码。

##### 位操作

位操作是 JS 中最容易被误解的方面之一。普遍认为，开发者们不知道如何使用这些操作符，而且经常被误用在布尔表达式中，于是就导致开发中很少使用位操作符，尽管它们具有优势。(具体还是略了吧，普通人写代码不可能玩到这么高深的优化)

##### 原生方法

无论你的 JS 代码如何优化，都永远比不上 JS 引擎提供的原生方法快。当原生方法可用时，尽量使用它们，特别是数学运算(`Math` 对象下各种方法) 和 DOM 操作(如 `querySelectorAll`)。


## 9. 构建并部署高性能 JS 应用

有必要确保那些基于 JS 的 Web 应用尽可能高效的传输。如果在这个环节不够小心，你的应用的性能将受影响，无论你怎样努力都无法使它更快。

#### 合并多个 JS 文件

网站提速指南中第一条也是最重要的一条规则，就是减少页面渲染所需的 HTTP 请求数，特别是针对那些首次访问网站的用户。

#### JS 压缩

JS 压缩指的是把 JS 文件中所有与运行无关的部分进行剥离的过程。剥离的内容包括注释和不必要的空白字符，该过程通常可以将文件大小减半。

#### 构建时处理对比运行时处理

合并、预处理和压缩这些步骤可以在构建时进行，也可以在运行时进行。在开发过程中，运行时处理会非常有帮助。但由于扩展性原因一般不建议在产品环境中使用。开发高性能应用的一个普遍规则是，只要是能在构建时完成的工作，就不要留到运行时去做。

#### JS 的 HTTP 压缩

当 Web 浏览器请求一个资源时，它通常会发送一个 `Accept-Encoding` HTTP 头来告诉 Web 服务器它支持哪种编码转换类型。这个信息主要用来压缩文档以获得更快的下载，从而改善用户体验。`Accept-Encoding` 可用的值包括：gzip compress deflate 和 identity。

如果 Web 服务器在请求中看到这些信息头，它会选择最适合的编码方法，并通过 `Content-Encoding` HTTP 头通知 Web 浏览器它的决定。

gzip 是目前最流行的编码方式。它通常能减少 70% 的下载量，成为提升 Web 应用性能的首选武器。记住 Gzip 压缩主要适用于文本，包括 JS 文件。其他类型，诸如图片和 PDF 文件，不应该使用 Gzip 压缩，因为它们本身已经被压缩过，试图重复压缩只会浪费服务器资源。

#### 缓存 JS 文件

缓存 HTTP 组件能极大提高网站回访用户的体验。

Web 服务器通过 `Expires` HTTP 响应头 来告诉客户端一个资源应当缓存多长时间。它的值是一个遵循 RFC 1123 标准的绝对时间戳，如 `Expires: Thu, 01 Dec 1994 16:00:00 GMT`。按照标准，服务器发送的 `Expires` 日期不应超过 1 年。

某些 Web 浏览器，特别是移动设备里的浏览器，可能会有缓存限制，如 Safari 不会缓存解压后超过 25KB 的文件。这种情况下，应该权衡 HTTP 组件数量和它们的可缓存性，考虑将它们分解成更小的块。

你也可以考虑在条件允许的情况下，采用客户端存储机制，此时 JS 代码必须自行控制到期日期。

最后，还有一种技术是使用 HTML5 离线应用缓存，这项技术依赖一个清单文件 manifest file，来列出所有待缓存的资源。(具体略)

#### 处理缓存问题

适当的缓存控制能切实提升用户体验，但它有一个缺点：当应用升级时，你需要确保用户下载到最新的静态资源内容。这个问题可以通过把改动过的静态资源重命名来解决。

多数情况下，开发者会给文件增加一个版本号或开发编号。有些人喜欢附加一个校验和 checksum。个人而言，我更偏向使用时间戳。

#### 使用内容分发网络 CDN

内容分发网络 CDN 是在互联网上按地理位置分布计算网络，它负责传递内容给终端用户。通过向地理位置最近的用户传输内容，CDN 能极大地减少网络延时。切换到 CDN 只需改写少量的代码，却很有可能明显提升终端用户的相应速度。

#### 部署 JS 资源

部署 JS 资源的过程通常需要复制大量文件到一台或多台远程主机，有时还需要在远程主机上执行一系列 shell 命令。

#### 敏捷 JS 构建过程


## 10. 工具





























